/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/style.css":
/*!*************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/style.css ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `#layout-container {\n    background-color: #1e1e1e; /* Dark background */\n    color: #ffffff; /* White text */\n  }\n  \n  .gl-content {\n    background-color: #2b2b2b !important; /* Dark panel background */\n  }\n  \n  .gl-component {\n    color: #ffffff !important; /* Ensures all text inside components is white */\n\n\n  }\n\n  .lm_header {\n    display: flex !important; /* Ensure header (tabs) is visible */\n  }\n  \n.lm_content {\n    padding: 20px; /* Add space inside the content area */\n    box-sizing: border-box; /* Ensures padding doesn't overflow */\n}\n\n  .lm_tab {\n    display: inline-block !important; /* Ensure individual tabs are visible */\n    background-color: #444; /* Dark tab background */\n    color: #fff; /* Light text */\n    padding: 5px;\n    border-radius: 3px;\n  }\n  \n  .lm_tab.lm_active {\n    background-color: #666; /* Highlight active tab */\n  }\n  \n\n  /* Ensure the header (tabs area) is visible */\n.lm_header {\n    display: flex !important;\n    background-color: #333; /* Dark header background */\n    border-bottom: 1px solid #444; /* Subtle border for separation */\n  }\n  \n  /* Style for individual tabs */\n  .lm_tab {\n    display: inline-block !important;\n    background-color: #555; /* Tab background */\n    color: #fff; /* Tab text color */\n    padding: 8px 12px;\n    margin: 2px;\n    border-radius: 4px;\n    font-family: Arial, sans-serif;\n    cursor: pointer;\n  }\n  \n  /* Highlight active tab */\n  .lm_tab.lm_active {\n    background-color: #007acc; /* Blue for active tab */\n    color: #fff;\n  }\n  \n  /* Add some hover effects for better interactivity */\n  .lm_tab:hover {\n    background-color: #007acc;\n    color: #fff;\n  }\n  `, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://dpv/./src/style.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://dpv/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://dpv/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/config/config.js":
/*!*****************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/config/config.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ComponentItemConfig: () => (/* binding */ ComponentItemConfig),\n/* harmony export */   HeaderedItemConfig: () => (/* binding */ HeaderedItemConfig),\n/* harmony export */   ItemConfig: () => (/* binding */ ItemConfig),\n/* harmony export */   LayoutConfig: () => (/* binding */ LayoutConfig),\n/* harmony export */   PopoutLayoutConfig: () => (/* binding */ PopoutLayoutConfig),\n/* harmony export */   RootItemConfig: () => (/* binding */ RootItemConfig),\n/* harmony export */   RowOrColumnItemConfig: () => (/* binding */ RowOrColumnItemConfig),\n/* harmony export */   StackItemConfig: () => (/* binding */ StackItemConfig),\n/* harmony export */   formatSize: () => (/* binding */ formatSize),\n/* harmony export */   formatUndefinableSize: () => (/* binding */ formatUndefinableSize),\n/* harmony export */   parseSize: () => (/* binding */ parseSize)\n/* harmony export */ });\n/* harmony import */ var _errors_external_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/external-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/external-error.js\");\n/* harmony import */ var _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors/internal-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js\");\n/* harmony import */ var _utils_i18n_strings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/i18n-strings */ \"./node_modules/golden-layout/dist/esm/ts/utils/i18n-strings.js\");\n/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/types */ \"./node_modules/golden-layout/dist/esm/ts/utils/types.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/golden-layout/dist/esm/ts/utils/utils.js\");\n/* harmony import */ var _resolved_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resolved-config */ \"./node_modules/golden-layout/dist/esm/ts/config/resolved-config.js\");\n\n\n\n\n\n\n/** @public */\nvar ItemConfig;\n(function (ItemConfig) {\n    /** @internal */\n    function resolve(itemConfig, rowAndColumnChildLegacySizeDefault) {\n        switch (itemConfig.type) {\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.ground:\n                throw new _errors_external_error__WEBPACK_IMPORTED_MODULE_1__.ConfigurationError('ItemConfig cannot specify type ground', JSON.stringify(itemConfig));\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.row:\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.column:\n                return RowOrColumnItemConfig.resolve(itemConfig, rowAndColumnChildLegacySizeDefault);\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.stack:\n                return StackItemConfig.resolve(itemConfig, rowAndColumnChildLegacySizeDefault);\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.component:\n                return ComponentItemConfig.resolve(itemConfig, rowAndColumnChildLegacySizeDefault);\n            default:\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__.UnreachableCaseError('UCUICR55499', itemConfig.type);\n        }\n    }\n    ItemConfig.resolve = resolve;\n    /** @internal */\n    function resolveContent(content) {\n        if (content === undefined) {\n            return [];\n        }\n        else {\n            const count = content.length;\n            const result = new Array(count);\n            for (let i = 0; i < count; i++) {\n                result[i] = ItemConfig.resolve(content[i], false);\n            }\n            return result;\n        }\n    }\n    ItemConfig.resolveContent = resolveContent;\n    /** @internal */\n    function resolveId(id) {\n        if (id === undefined) {\n            return _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedItemConfig.defaults.id;\n        }\n        else {\n            if (Array.isArray(id)) {\n                if (id.length === 0) {\n                    return _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedItemConfig.defaults.id;\n                }\n                else {\n                    return id[0];\n                }\n            }\n            else {\n                return id;\n            }\n        }\n    }\n    ItemConfig.resolveId = resolveId;\n    /** @internal */\n    function resolveSize(size, width, height, rowAndColumnChildLegacySizeDefault) {\n        // Remove support for rowAndColumnChildLegacySizeDefault in a major version release\n        if (size !== undefined) {\n            return parseSize(size, [_utils_types__WEBPACK_IMPORTED_MODULE_0__.SizeUnitEnum.Percent, _utils_types__WEBPACK_IMPORTED_MODULE_0__.SizeUnitEnum.Fractional]);\n        }\n        else {\n            if (width !== undefined || height !== undefined) {\n                if (width !== undefined) {\n                    return { size: width, sizeUnit: _utils_types__WEBPACK_IMPORTED_MODULE_0__.SizeUnitEnum.Percent };\n                }\n                else {\n                    if (height !== undefined) {\n                        return { size: height, sizeUnit: _utils_types__WEBPACK_IMPORTED_MODULE_0__.SizeUnitEnum.Percent };\n                    }\n                    else {\n                        throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__.UnexpectedUndefinedError('CRS33390');\n                    }\n                }\n            }\n            else {\n                if (rowAndColumnChildLegacySizeDefault) {\n                    return { size: 50, sizeUnit: _utils_types__WEBPACK_IMPORTED_MODULE_0__.SizeUnitEnum.Percent };\n                }\n                else {\n                    return { size: _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedItemConfig.defaults.size, sizeUnit: _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedItemConfig.defaults.sizeUnit };\n                }\n            }\n        }\n    }\n    ItemConfig.resolveSize = resolveSize;\n    /** @internal */\n    function resolveMinSize(minSize, minWidth, minHeight) {\n        if (minSize !== undefined) {\n            return parseSize(minSize, [_utils_types__WEBPACK_IMPORTED_MODULE_0__.SizeUnitEnum.Pixel]);\n        }\n        else {\n            const minWidthDefined = minWidth !== undefined;\n            const minHeightDefined = minHeight !== undefined;\n            if (minWidthDefined || minHeightDefined) {\n                if (minWidthDefined) {\n                    return { size: minWidth, sizeUnit: _utils_types__WEBPACK_IMPORTED_MODULE_0__.SizeUnitEnum.Pixel };\n                }\n                else {\n                    return { size: minHeight, sizeUnit: _utils_types__WEBPACK_IMPORTED_MODULE_0__.SizeUnitEnum.Pixel };\n                }\n            }\n            else {\n                return { size: _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedItemConfig.defaults.minSize, sizeUnit: _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedItemConfig.defaults.minSizeUnit };\n            }\n        }\n    }\n    ItemConfig.resolveMinSize = resolveMinSize;\n    /** @internal */\n    function calculateSizeWidthHeightSpecificationType(config) {\n        if (config.size !== undefined) {\n            return 1 /* Size */;\n        }\n        else {\n            if (config.width !== undefined || config.height !== undefined) {\n                return 2 /* WidthOrHeight */;\n            }\n            else {\n                return 0 /* None */;\n            }\n        }\n    }\n    ItemConfig.calculateSizeWidthHeightSpecificationType = calculateSizeWidthHeightSpecificationType;\n    function isGround(config) {\n        return config.type === _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.ground;\n    }\n    ItemConfig.isGround = isGround;\n    function isRow(config) {\n        return config.type === _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.row;\n    }\n    ItemConfig.isRow = isRow;\n    function isColumn(config) {\n        return config.type === _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.column;\n    }\n    ItemConfig.isColumn = isColumn;\n    function isStack(config) {\n        return config.type === _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.stack;\n    }\n    ItemConfig.isStack = isStack;\n    function isComponent(config) {\n        return config.type === _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.component;\n    }\n    ItemConfig.isComponent = isComponent;\n})(ItemConfig || (ItemConfig = {}));\n/** @public */\nvar HeaderedItemConfig;\n(function (HeaderedItemConfig) {\n    const legacyMaximisedId = '__glMaximised';\n    let Header;\n    (function (Header) {\n        function resolve(header, hasHeaders) {\n            var _a;\n            if (header === undefined && hasHeaders === undefined) {\n                return undefined;\n            }\n            else {\n                const result = {\n                    show: (_a = header === null || header === void 0 ? void 0 : header.show) !== null && _a !== void 0 ? _a : (hasHeaders === undefined ? undefined : hasHeaders ? _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Header.defaults.show : false),\n                    popout: header === null || header === void 0 ? void 0 : header.popout,\n                    maximise: header === null || header === void 0 ? void 0 : header.maximise,\n                    close: header === null || header === void 0 ? void 0 : header.close,\n                    minimise: header === null || header === void 0 ? void 0 : header.minimise,\n                    tabDropdown: header === null || header === void 0 ? void 0 : header.tabDropdown,\n                };\n                return result;\n            }\n        }\n        Header.resolve = resolve;\n    })(Header = HeaderedItemConfig.Header || (HeaderedItemConfig.Header = {}));\n    /** @internal */\n    function resolveIdAndMaximised(config) {\n        let id;\n        // To support legacy configs with Id saved as an array of string, assign config.id to a type which includes string array\n        let legacyId = config.id;\n        let legacyMaximised = false;\n        if (legacyId === undefined) {\n            id = _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedItemConfig.defaults.id;\n        }\n        else {\n            if (Array.isArray(legacyId)) {\n                const idx = legacyId.findIndex((id) => id === legacyMaximisedId);\n                if (idx > 0) {\n                    legacyMaximised = true;\n                    legacyId = legacyId.splice(idx, 1);\n                }\n                if (legacyId.length > 0) {\n                    id = legacyId[0];\n                }\n                else {\n                    id = _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedItemConfig.defaults.id;\n                }\n            }\n            else {\n                id = legacyId;\n            }\n        }\n        let maximised;\n        if (config.maximised !== undefined) {\n            maximised = config.maximised;\n        }\n        else {\n            maximised = legacyMaximised;\n        }\n        return { id, maximised };\n    }\n    HeaderedItemConfig.resolveIdAndMaximised = resolveIdAndMaximised;\n})(HeaderedItemConfig || (HeaderedItemConfig = {}));\n/** @public */\nvar StackItemConfig;\n(function (StackItemConfig) {\n    /** @internal */\n    function resolve(itemConfig, rowAndColumnChildLegacySizeDefault) {\n        var _a, _b;\n        const { id, maximised } = HeaderedItemConfig.resolveIdAndMaximised(itemConfig);\n        const { size, sizeUnit } = ItemConfig.resolveSize(itemConfig.size, itemConfig.width, itemConfig.height, rowAndColumnChildLegacySizeDefault);\n        const { size: minSize, sizeUnit: minSizeUnit } = ItemConfig.resolveMinSize(itemConfig.minSize, itemConfig.minWidth, itemConfig.minHeight);\n        const result = {\n            type: _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.stack,\n            content: resolveContent(itemConfig.content),\n            size,\n            sizeUnit,\n            minSize,\n            minSizeUnit,\n            id,\n            maximised,\n            isClosable: (_a = itemConfig.isClosable) !== null && _a !== void 0 ? _a : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedItemConfig.defaults.isClosable,\n            activeItemIndex: (_b = itemConfig.activeItemIndex) !== null && _b !== void 0 ? _b : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedStackItemConfig.defaultActiveItemIndex,\n            header: HeaderedItemConfig.Header.resolve(itemConfig.header, itemConfig.hasHeaders),\n        };\n        return result;\n    }\n    StackItemConfig.resolve = resolve;\n    /** @internal */\n    function fromResolved(resolvedConfig) {\n        const result = {\n            type: _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.stack,\n            content: fromResolvedContent(resolvedConfig.content),\n            size: formatSize(resolvedConfig.size, resolvedConfig.sizeUnit),\n            minSize: formatUndefinableSize(resolvedConfig.minSize, resolvedConfig.minSizeUnit),\n            id: resolvedConfig.id,\n            maximised: resolvedConfig.maximised,\n            isClosable: resolvedConfig.isClosable,\n            activeItemIndex: resolvedConfig.activeItemIndex,\n            header: _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedHeaderedItemConfig.Header.createCopy(resolvedConfig.header),\n        };\n        return result;\n    }\n    StackItemConfig.fromResolved = fromResolved;\n    /** @internal */\n    function resolveContent(content) {\n        if (content === undefined) {\n            return [];\n        }\n        else {\n            const count = content.length;\n            const result = new Array(count);\n            for (let i = 0; i < count; i++) {\n                const childItemConfig = content[i];\n                const itemConfig = ItemConfig.resolve(childItemConfig, false);\n                if (!_resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedItemConfig.isComponentItem(itemConfig)) {\n                    throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__.AssertError('UCUSICRC91114', JSON.stringify(itemConfig));\n                }\n                else {\n                    result[i] = itemConfig;\n                }\n            }\n            return result;\n        }\n    }\n    /** @internal */\n    function fromResolvedContent(resolvedContent) {\n        const count = resolvedContent.length;\n        const result = new Array(count);\n        for (let i = 0; i < count; i++) {\n            const resolvedContentConfig = resolvedContent[i];\n            result[i] = ComponentItemConfig.fromResolved(resolvedContentConfig);\n        }\n        return result;\n    }\n})(StackItemConfig || (StackItemConfig = {}));\n/** @public */\nvar ComponentItemConfig;\n(function (ComponentItemConfig) {\n    /** @internal */\n    function resolve(itemConfig, rowAndColumnChildLegacySizeDefault) {\n        var _a, _b, _c;\n        let componentType = itemConfig.componentType;\n        if (componentType === undefined) {\n            componentType = itemConfig.componentName;\n        }\n        if (componentType === undefined) {\n            throw new Error('ComponentItemConfig.componentType is undefined');\n        }\n        else {\n            const { id, maximised } = HeaderedItemConfig.resolveIdAndMaximised(itemConfig);\n            let title;\n            if (itemConfig.title === undefined || itemConfig.title === '') {\n                title = ComponentItemConfig.componentTypeToTitle(componentType);\n            }\n            else {\n                title = itemConfig.title;\n            }\n            const { size, sizeUnit } = ItemConfig.resolveSize(itemConfig.size, itemConfig.width, itemConfig.height, rowAndColumnChildLegacySizeDefault);\n            const { size: minSize, sizeUnit: minSizeUnit } = ItemConfig.resolveMinSize(itemConfig.minSize, itemConfig.minWidth, itemConfig.minHeight);\n            const result = {\n                type: itemConfig.type,\n                content: [],\n                size,\n                sizeUnit,\n                minSize,\n                minSizeUnit,\n                id,\n                maximised,\n                isClosable: (_a = itemConfig.isClosable) !== null && _a !== void 0 ? _a : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedItemConfig.defaults.isClosable,\n                reorderEnabled: (_b = itemConfig.reorderEnabled) !== null && _b !== void 0 ? _b : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedComponentItemConfig.defaultReorderEnabled,\n                title,\n                header: HeaderedItemConfig.Header.resolve(itemConfig.header, itemConfig.hasHeaders),\n                componentType,\n                componentState: (_c = itemConfig.componentState) !== null && _c !== void 0 ? _c : {},\n            };\n            return result;\n        }\n    }\n    ComponentItemConfig.resolve = resolve;\n    /** @internal */\n    function fromResolved(resolvedConfig) {\n        const result = {\n            type: _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.component,\n            size: formatSize(resolvedConfig.size, resolvedConfig.sizeUnit),\n            minSize: formatUndefinableSize(resolvedConfig.minSize, resolvedConfig.minSizeUnit),\n            id: resolvedConfig.id,\n            maximised: resolvedConfig.maximised,\n            isClosable: resolvedConfig.isClosable,\n            reorderEnabled: resolvedConfig.reorderEnabled,\n            title: resolvedConfig.title,\n            header: _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedHeaderedItemConfig.Header.createCopy(resolvedConfig.header),\n            componentType: resolvedConfig.componentType,\n            componentState: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.deepExtendValue)(undefined, resolvedConfig.componentState),\n        };\n        return result;\n    }\n    ComponentItemConfig.fromResolved = fromResolved;\n    function componentTypeToTitle(componentType) {\n        const componentTypeType = typeof componentType;\n        switch (componentTypeType) {\n            case 'string': return componentType;\n            case 'number': return componentType.toString();\n            case 'boolean': return componentType.toString();\n            default: return '';\n        }\n    }\n    ComponentItemConfig.componentTypeToTitle = componentTypeToTitle;\n})(ComponentItemConfig || (ComponentItemConfig = {}));\n/** @public */\nvar RowOrColumnItemConfig;\n(function (RowOrColumnItemConfig) {\n    function isChildItemConfig(itemConfig) {\n        switch (itemConfig.type) {\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.row:\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.column:\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.stack:\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.component:\n                return true;\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.ground:\n                return false;\n            default:\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__.UnreachableCaseError('UROCOSPCICIC13687', itemConfig.type);\n        }\n    }\n    RowOrColumnItemConfig.isChildItemConfig = isChildItemConfig;\n    /** @internal */\n    function resolve(itemConfig, rowAndColumnChildLegacySizeDefault) {\n        var _a;\n        const { size, sizeUnit } = ItemConfig.resolveSize(itemConfig.size, itemConfig.width, itemConfig.height, rowAndColumnChildLegacySizeDefault);\n        const { size: minSize, sizeUnit: minSizeUnit } = ItemConfig.resolveMinSize(itemConfig.minSize, itemConfig.minWidth, itemConfig.minHeight);\n        const result = {\n            type: itemConfig.type,\n            content: RowOrColumnItemConfig.resolveContent(itemConfig.content),\n            size,\n            sizeUnit,\n            minSize,\n            minSizeUnit,\n            id: ItemConfig.resolveId(itemConfig.id),\n            isClosable: (_a = itemConfig.isClosable) !== null && _a !== void 0 ? _a : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedItemConfig.defaults.isClosable,\n        };\n        return result;\n    }\n    RowOrColumnItemConfig.resolve = resolve;\n    /** @internal */\n    function fromResolved(resolvedConfig) {\n        const result = {\n            type: resolvedConfig.type,\n            content: fromResolvedContent(resolvedConfig.content),\n            size: formatSize(resolvedConfig.size, resolvedConfig.sizeUnit),\n            minSize: formatUndefinableSize(resolvedConfig.minSize, resolvedConfig.minSizeUnit),\n            id: resolvedConfig.id,\n            isClosable: resolvedConfig.isClosable,\n        };\n        return result;\n    }\n    RowOrColumnItemConfig.fromResolved = fromResolved;\n    /** @internal */\n    function resolveContent(content) {\n        if (content === undefined) {\n            return [];\n        }\n        else {\n            const count = content.length;\n            const childItemConfigs = new Array(count);\n            let widthOrHeightSpecifiedAtLeastOnce = false;\n            let sizeSpecifiedAtLeastOnce = false;\n            for (let i = 0; i < count; i++) {\n                const childItemConfig = content[i];\n                if (!RowOrColumnItemConfig.isChildItemConfig(childItemConfig)) {\n                    throw new _errors_external_error__WEBPACK_IMPORTED_MODULE_1__.ConfigurationError('ItemConfig is not Row, Column or Stack', childItemConfig);\n                }\n                else {\n                    if (!sizeSpecifiedAtLeastOnce) {\n                        const sizeWidthHeightSpecificationType = ItemConfig.calculateSizeWidthHeightSpecificationType(childItemConfig);\n                        switch (sizeWidthHeightSpecificationType) {\n                            case 0 /* None */:\n                                break;\n                            case 2 /* WidthOrHeight */:\n                                widthOrHeightSpecifiedAtLeastOnce = true;\n                                break;\n                            case 1 /* Size */:\n                                sizeSpecifiedAtLeastOnce = true;\n                                break;\n                            default:\n                                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__.UnreachableCaseError('ROCICRC87556', sizeWidthHeightSpecificationType);\n                        }\n                    }\n                    childItemConfigs[i] = childItemConfig;\n                }\n            }\n            let legacySizeDefault;\n            if (sizeSpecifiedAtLeastOnce) {\n                legacySizeDefault = false;\n            }\n            else {\n                if (widthOrHeightSpecifiedAtLeastOnce) {\n                    legacySizeDefault = true;\n                }\n                else {\n                    legacySizeDefault = false;\n                }\n            }\n            const result = new Array(count);\n            for (let i = 0; i < count; i++) {\n                const childItemConfig = childItemConfigs[i];\n                const resolvedChildItemConfig = ItemConfig.resolve(childItemConfig, legacySizeDefault);\n                if (!_resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedRowOrColumnItemConfig.isChildItemConfig(resolvedChildItemConfig)) {\n                    throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__.AssertError('UROCOSPIC99512', JSON.stringify(resolvedChildItemConfig));\n                }\n                else {\n                    result[i] = resolvedChildItemConfig;\n                }\n            }\n            return result;\n        }\n    }\n    RowOrColumnItemConfig.resolveContent = resolveContent;\n    /** @internal */\n    function fromResolvedContent(resolvedContent) {\n        const count = resolvedContent.length;\n        const result = new Array(count);\n        for (let i = 0; i < count; i++) {\n            const resolvedContentConfig = resolvedContent[i];\n            const type = resolvedContentConfig.type;\n            let contentConfig;\n            switch (type) {\n                case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.row:\n                case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.column:\n                    contentConfig = RowOrColumnItemConfig.fromResolved(resolvedContentConfig);\n                    break;\n                case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.stack:\n                    contentConfig = StackItemConfig.fromResolved(resolvedContentConfig);\n                    break;\n                case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.component:\n                    contentConfig = ComponentItemConfig.fromResolved(resolvedContentConfig);\n                    break;\n                default:\n                    throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__.UnreachableCaseError('ROCICFRC44797', type);\n            }\n            result[i] = contentConfig;\n        }\n        return result;\n    }\n})(RowOrColumnItemConfig || (RowOrColumnItemConfig = {}));\n/** @public */\nvar RootItemConfig;\n(function (RootItemConfig) {\n    function isRootItemConfig(itemConfig) {\n        switch (itemConfig.type) {\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.row:\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.column:\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.stack:\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.component:\n                return true;\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.ground:\n                return false;\n            default:\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__.UnreachableCaseError('URICIR23687', itemConfig.type);\n        }\n    }\n    RootItemConfig.isRootItemConfig = isRootItemConfig;\n    /** @internal */\n    function resolve(itemConfig) {\n        if (itemConfig === undefined) {\n            return undefined;\n        }\n        else {\n            const result = ItemConfig.resolve(itemConfig, false);\n            if (!_resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedRootItemConfig.isRootItemConfig(result)) {\n                throw new _errors_external_error__WEBPACK_IMPORTED_MODULE_1__.ConfigurationError('ItemConfig is not Row, Column or Stack', JSON.stringify(itemConfig));\n            }\n            else {\n                return result;\n            }\n        }\n    }\n    RootItemConfig.resolve = resolve;\n    /** @internal */\n    function fromResolvedOrUndefined(resolvedItemConfig) {\n        if (resolvedItemConfig === undefined) {\n            return undefined;\n        }\n        else {\n            const type = resolvedItemConfig.type;\n            switch (type) {\n                case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.row:\n                case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.column:\n                    return RowOrColumnItemConfig.fromResolved(resolvedItemConfig);\n                case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.stack:\n                    return StackItemConfig.fromResolved(resolvedItemConfig);\n                case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.component:\n                    return ComponentItemConfig.fromResolved(resolvedItemConfig);\n                default:\n                    throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__.UnreachableCaseError('RICFROU89921', type);\n            }\n        }\n    }\n    RootItemConfig.fromResolvedOrUndefined = fromResolvedOrUndefined;\n})(RootItemConfig || (RootItemConfig = {}));\n/** Use to specify LayoutConfig with defaults or deserialise a LayoutConfig.\n * Deserialisation will handle backwards compatibility.\n * Note that LayoutConfig should be used for serialisation (not LayoutConfig)\n * @public\n */\nvar LayoutConfig;\n(function (LayoutConfig) {\n    let Settings;\n    (function (Settings) {\n        function resolve(settings) {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n            const result = {\n                constrainDragToContainer: (_a = settings === null || settings === void 0 ? void 0 : settings.constrainDragToContainer) !== null && _a !== void 0 ? _a : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Settings.defaults.constrainDragToContainer,\n                reorderEnabled: (_b = settings === null || settings === void 0 ? void 0 : settings.reorderEnabled) !== null && _b !== void 0 ? _b : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Settings.defaults.reorderEnabled,\n                popoutWholeStack: (_c = settings === null || settings === void 0 ? void 0 : settings.popoutWholeStack) !== null && _c !== void 0 ? _c : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Settings.defaults.popoutWholeStack,\n                blockedPopoutsThrowError: (_d = settings === null || settings === void 0 ? void 0 : settings.blockedPopoutsThrowError) !== null && _d !== void 0 ? _d : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Settings.defaults.blockedPopoutsThrowError,\n                closePopoutsOnUnload: (_e = settings === null || settings === void 0 ? void 0 : settings.closePopoutsOnUnload) !== null && _e !== void 0 ? _e : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Settings.defaults.closePopoutsOnUnload,\n                responsiveMode: (_f = settings === null || settings === void 0 ? void 0 : settings.responsiveMode) !== null && _f !== void 0 ? _f : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Settings.defaults.responsiveMode,\n                tabOverlapAllowance: (_g = settings === null || settings === void 0 ? void 0 : settings.tabOverlapAllowance) !== null && _g !== void 0 ? _g : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Settings.defaults.tabOverlapAllowance,\n                reorderOnTabMenuClick: (_h = settings === null || settings === void 0 ? void 0 : settings.reorderOnTabMenuClick) !== null && _h !== void 0 ? _h : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Settings.defaults.reorderOnTabMenuClick,\n                tabControlOffset: (_j = settings === null || settings === void 0 ? void 0 : settings.tabControlOffset) !== null && _j !== void 0 ? _j : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Settings.defaults.tabControlOffset,\n                popInOnClose: (_k = settings === null || settings === void 0 ? void 0 : settings.popInOnClose) !== null && _k !== void 0 ? _k : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Settings.defaults.popInOnClose,\n            };\n            return result;\n        }\n        Settings.resolve = resolve;\n    })(Settings = LayoutConfig.Settings || (LayoutConfig.Settings = {}));\n    let Dimensions;\n    (function (Dimensions) {\n        /** @internal */\n        function resolve(dimensions) {\n            var _a, _b, _c, _d, _e;\n            const { size: defaultMinItemHeight, sizeUnit: defaultMinItemHeightUnit } = Dimensions.resolveDefaultMinItemHeight(dimensions);\n            const { size: defaultMinItemWidth, sizeUnit: defaultMinItemWidthUnit } = Dimensions.resolveDefaultMinItemWidth(dimensions);\n            const result = {\n                borderWidth: (_a = dimensions === null || dimensions === void 0 ? void 0 : dimensions.borderWidth) !== null && _a !== void 0 ? _a : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Dimensions.defaults.borderWidth,\n                borderGrabWidth: (_b = dimensions === null || dimensions === void 0 ? void 0 : dimensions.borderGrabWidth) !== null && _b !== void 0 ? _b : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Dimensions.defaults.borderGrabWidth,\n                defaultMinItemHeight,\n                defaultMinItemHeightUnit,\n                defaultMinItemWidth,\n                defaultMinItemWidthUnit,\n                headerHeight: (_c = dimensions === null || dimensions === void 0 ? void 0 : dimensions.headerHeight) !== null && _c !== void 0 ? _c : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Dimensions.defaults.headerHeight,\n                dragProxyWidth: (_d = dimensions === null || dimensions === void 0 ? void 0 : dimensions.dragProxyWidth) !== null && _d !== void 0 ? _d : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Dimensions.defaults.dragProxyWidth,\n                dragProxyHeight: (_e = dimensions === null || dimensions === void 0 ? void 0 : dimensions.dragProxyHeight) !== null && _e !== void 0 ? _e : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Dimensions.defaults.dragProxyHeight,\n            };\n            return result;\n        }\n        Dimensions.resolve = resolve;\n        /** @internal */\n        function fromResolved(resolvedDimensions) {\n            const result = {\n                borderWidth: resolvedDimensions.borderWidth,\n                borderGrabWidth: resolvedDimensions.borderGrabWidth,\n                defaultMinItemHeight: formatSize(resolvedDimensions.defaultMinItemHeight, resolvedDimensions.defaultMinItemHeightUnit),\n                defaultMinItemWidth: formatSize(resolvedDimensions.defaultMinItemWidth, resolvedDimensions.defaultMinItemWidthUnit),\n                headerHeight: resolvedDimensions.headerHeight,\n                dragProxyWidth: resolvedDimensions.dragProxyWidth,\n                dragProxyHeight: resolvedDimensions.dragProxyHeight,\n            };\n            return result;\n        }\n        Dimensions.fromResolved = fromResolved;\n        /** @internal */\n        function resolveDefaultMinItemHeight(dimensions) {\n            const height = dimensions === null || dimensions === void 0 ? void 0 : dimensions.defaultMinItemHeight;\n            if (height === undefined) {\n                return { size: _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Dimensions.defaults.defaultMinItemHeight, sizeUnit: _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Dimensions.defaults.defaultMinItemHeightUnit };\n            }\n            else {\n                return parseSize(height, [_utils_types__WEBPACK_IMPORTED_MODULE_0__.SizeUnitEnum.Pixel]);\n            }\n        }\n        Dimensions.resolveDefaultMinItemHeight = resolveDefaultMinItemHeight;\n        /** @internal */\n        function resolveDefaultMinItemWidth(dimensions) {\n            const width = dimensions === null || dimensions === void 0 ? void 0 : dimensions.defaultMinItemWidth;\n            if (width === undefined) {\n                return { size: _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Dimensions.defaults.defaultMinItemWidth, sizeUnit: _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Dimensions.defaults.defaultMinItemWidthUnit };\n            }\n            else {\n                return parseSize(width, [_utils_types__WEBPACK_IMPORTED_MODULE_0__.SizeUnitEnum.Pixel]);\n            }\n        }\n        Dimensions.resolveDefaultMinItemWidth = resolveDefaultMinItemWidth;\n    })(Dimensions = LayoutConfig.Dimensions || (LayoutConfig.Dimensions = {}));\n    let Header;\n    (function (Header) {\n        /** @internal */\n        function resolve(header, settings, labels) {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n            let show;\n            if ((header === null || header === void 0 ? void 0 : header.show) !== undefined) {\n                show = header.show;\n            }\n            else {\n                if (settings !== undefined && settings.hasHeaders !== undefined) {\n                    show = settings.hasHeaders ? _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Header.defaults.show : false;\n                }\n                else {\n                    show = _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Header.defaults.show;\n                }\n            }\n            const result = {\n                show,\n                popout: (_b = (_a = header === null || header === void 0 ? void 0 : header.popout) !== null && _a !== void 0 ? _a : labels === null || labels === void 0 ? void 0 : labels.popout) !== null && _b !== void 0 ? _b : ((settings === null || settings === void 0 ? void 0 : settings.showPopoutIcon) === false ? false : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Header.defaults.popout),\n                dock: (_d = (_c = header === null || header === void 0 ? void 0 : header.popin) !== null && _c !== void 0 ? _c : labels === null || labels === void 0 ? void 0 : labels.popin) !== null && _d !== void 0 ? _d : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Header.defaults.dock,\n                maximise: (_f = (_e = header === null || header === void 0 ? void 0 : header.maximise) !== null && _e !== void 0 ? _e : labels === null || labels === void 0 ? void 0 : labels.maximise) !== null && _f !== void 0 ? _f : ((settings === null || settings === void 0 ? void 0 : settings.showMaximiseIcon) === false ? false : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Header.defaults.maximise),\n                close: (_h = (_g = header === null || header === void 0 ? void 0 : header.close) !== null && _g !== void 0 ? _g : labels === null || labels === void 0 ? void 0 : labels.close) !== null && _h !== void 0 ? _h : ((settings === null || settings === void 0 ? void 0 : settings.showCloseIcon) === false ? false : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Header.defaults.close),\n                minimise: (_k = (_j = header === null || header === void 0 ? void 0 : header.minimise) !== null && _j !== void 0 ? _j : labels === null || labels === void 0 ? void 0 : labels.minimise) !== null && _k !== void 0 ? _k : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Header.defaults.minimise,\n                tabDropdown: (_m = (_l = header === null || header === void 0 ? void 0 : header.tabDropdown) !== null && _l !== void 0 ? _l : labels === null || labels === void 0 ? void 0 : labels.tabDropdown) !== null && _m !== void 0 ? _m : _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Header.defaults.tabDropdown,\n            };\n            return result;\n        }\n        Header.resolve = resolve;\n    })(Header = LayoutConfig.Header || (LayoutConfig.Header = {}));\n    function isPopout(config) {\n        return 'parentId' in config || 'indexInParent' in config || 'window' in config;\n    }\n    LayoutConfig.isPopout = isPopout;\n    /** @internal */\n    function resolve(layoutConfig) {\n        if (isPopout(layoutConfig)) {\n            return PopoutLayoutConfig.resolve(layoutConfig);\n        }\n        else {\n            let root;\n            if (layoutConfig.root !== undefined) {\n                root = layoutConfig.root;\n            }\n            else {\n                if (layoutConfig.content !== undefined && layoutConfig.content.length > 0) {\n                    root = layoutConfig.content[0];\n                }\n                else {\n                    root = undefined;\n                }\n            }\n            const config = {\n                resolved: true,\n                root: RootItemConfig.resolve(root),\n                openPopouts: LayoutConfig.resolveOpenPopouts(layoutConfig.openPopouts),\n                dimensions: LayoutConfig.Dimensions.resolve(layoutConfig.dimensions),\n                settings: LayoutConfig.Settings.resolve(layoutConfig.settings),\n                header: LayoutConfig.Header.resolve(layoutConfig.header, layoutConfig.settings, layoutConfig.labels),\n            };\n            return config;\n        }\n    }\n    LayoutConfig.resolve = resolve;\n    function fromResolved(config) {\n        const result = {\n            root: RootItemConfig.fromResolvedOrUndefined(config.root),\n            openPopouts: PopoutLayoutConfig.fromResolvedArray(config.openPopouts),\n            settings: _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Settings.createCopy(config.settings),\n            dimensions: LayoutConfig.Dimensions.fromResolved(config.dimensions),\n            header: _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Header.createCopy(config.header),\n        };\n        return result;\n    }\n    LayoutConfig.fromResolved = fromResolved;\n    function isResolved(configOrResolvedConfig) {\n        const config = configOrResolvedConfig;\n        return config.resolved !== undefined && (config.resolved === true);\n    }\n    LayoutConfig.isResolved = isResolved;\n    /** @internal */\n    function resolveOpenPopouts(popoutConfigs) {\n        if (popoutConfigs === undefined) {\n            return [];\n        }\n        else {\n            const count = popoutConfigs.length;\n            const result = new Array(count);\n            for (let i = 0; i < count; i++) {\n                result[i] = PopoutLayoutConfig.resolve(popoutConfigs[i]);\n            }\n            return result;\n        }\n    }\n    LayoutConfig.resolveOpenPopouts = resolveOpenPopouts;\n})(LayoutConfig || (LayoutConfig = {}));\n/** @public */\nvar PopoutLayoutConfig;\n(function (PopoutLayoutConfig) {\n    let Window;\n    (function (Window) {\n        /** @internal */\n        function resolve(window, dimensions) {\n            var _a, _b, _c, _d, _e, _f, _g, _h;\n            let result;\n            const defaults = _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedPopoutLayoutConfig.Window.defaults;\n            if (window !== undefined) {\n                result = {\n                    width: (_a = window.width) !== null && _a !== void 0 ? _a : defaults.width,\n                    height: (_b = window.height) !== null && _b !== void 0 ? _b : defaults.height,\n                    left: (_c = window.left) !== null && _c !== void 0 ? _c : defaults.left,\n                    top: (_d = window.top) !== null && _d !== void 0 ? _d : defaults.top,\n                };\n            }\n            else {\n                result = {\n                    width: (_e = dimensions === null || dimensions === void 0 ? void 0 : dimensions.width) !== null && _e !== void 0 ? _e : defaults.width,\n                    height: (_f = dimensions === null || dimensions === void 0 ? void 0 : dimensions.height) !== null && _f !== void 0 ? _f : defaults.height,\n                    left: (_g = dimensions === null || dimensions === void 0 ? void 0 : dimensions.left) !== null && _g !== void 0 ? _g : defaults.left,\n                    top: (_h = dimensions === null || dimensions === void 0 ? void 0 : dimensions.top) !== null && _h !== void 0 ? _h : defaults.top,\n                };\n            }\n            return result;\n        }\n        Window.resolve = resolve;\n        /** @internal */\n        function fromResolved(resolvedWindow) {\n            const result = {\n                width: resolvedWindow.width === null ? undefined : resolvedWindow.width,\n                height: resolvedWindow.height === null ? undefined : resolvedWindow.height,\n                left: resolvedWindow.left === null ? undefined : resolvedWindow.left,\n                top: resolvedWindow.top === null ? undefined : resolvedWindow.top,\n            };\n            return result;\n        }\n        Window.fromResolved = fromResolved;\n    })(Window = PopoutLayoutConfig.Window || (PopoutLayoutConfig.Window = {}));\n    /** @internal */\n    function resolve(popoutConfig) {\n        var _a, _b;\n        let root;\n        if (popoutConfig.root !== undefined) {\n            root = popoutConfig.root;\n        }\n        else {\n            if (popoutConfig.content !== undefined && popoutConfig.content.length > 0) {\n                root = popoutConfig.content[0];\n            }\n            else {\n                root = undefined;\n            }\n        }\n        const config = {\n            root: RootItemConfig.resolve(root),\n            openPopouts: LayoutConfig.resolveOpenPopouts(popoutConfig.openPopouts),\n            dimensions: LayoutConfig.Dimensions.resolve(popoutConfig.dimensions),\n            settings: LayoutConfig.Settings.resolve(popoutConfig.settings),\n            header: LayoutConfig.Header.resolve(popoutConfig.header, popoutConfig.settings, popoutConfig.labels),\n            parentId: (_a = popoutConfig.parentId) !== null && _a !== void 0 ? _a : null,\n            indexInParent: (_b = popoutConfig.indexInParent) !== null && _b !== void 0 ? _b : null,\n            window: PopoutLayoutConfig.Window.resolve(popoutConfig.window, popoutConfig.dimensions),\n            resolved: true,\n        };\n        return config;\n    }\n    PopoutLayoutConfig.resolve = resolve;\n    /** @internal */\n    function fromResolved(resolvedConfig) {\n        const result = {\n            root: RootItemConfig.fromResolvedOrUndefined(resolvedConfig.root),\n            openPopouts: fromResolvedArray(resolvedConfig.openPopouts),\n            dimensions: LayoutConfig.Dimensions.fromResolved(resolvedConfig.dimensions),\n            settings: _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Settings.createCopy(resolvedConfig.settings),\n            header: _resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedLayoutConfig.Header.createCopy(resolvedConfig.header),\n            parentId: resolvedConfig.parentId,\n            indexInParent: resolvedConfig.indexInParent,\n            window: PopoutLayoutConfig.Window.fromResolved(resolvedConfig.window),\n        };\n        return result;\n    }\n    PopoutLayoutConfig.fromResolved = fromResolved;\n    /** @internal */\n    function fromResolvedArray(resolvedArray) {\n        const resolvedOpenPopoutCount = resolvedArray.length;\n        const result = new Array(resolvedOpenPopoutCount);\n        for (let i = 0; i < resolvedOpenPopoutCount; i++) {\n            const resolvedOpenPopout = resolvedArray[i];\n            result[i] = PopoutLayoutConfig.fromResolved(resolvedOpenPopout);\n        }\n        return result;\n    }\n    PopoutLayoutConfig.fromResolvedArray = fromResolvedArray;\n})(PopoutLayoutConfig || (PopoutLayoutConfig = {}));\n/** @internal */\nfunction parseSize(sizeString, allowableSizeUnits) {\n    const { numericPart: digitsPart, firstNonNumericCharPart: firstNonDigitPart } = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.splitStringAtFirstNonNumericChar)(sizeString);\n    const size = Number.parseInt(digitsPart, 10);\n    if (isNaN(size)) {\n        throw new _errors_external_error__WEBPACK_IMPORTED_MODULE_1__.ConfigurationError(`${_utils_i18n_strings__WEBPACK_IMPORTED_MODULE_5__.i18nStrings[7 /* InvalidNumberPartInSizeString */]}: ${sizeString}`);\n    }\n    else {\n        const sizeUnit = _utils_types__WEBPACK_IMPORTED_MODULE_0__.SizeUnitEnum.tryParse(firstNonDigitPart);\n        if (sizeUnit === undefined) {\n            throw new _errors_external_error__WEBPACK_IMPORTED_MODULE_1__.ConfigurationError(`${_utils_i18n_strings__WEBPACK_IMPORTED_MODULE_5__.i18nStrings[8 /* UnknownUnitInSizeString */]}: ${sizeString}`);\n        }\n        else {\n            if (!allowableSizeUnits.includes(sizeUnit)) {\n                throw new _errors_external_error__WEBPACK_IMPORTED_MODULE_1__.ConfigurationError(`${_utils_i18n_strings__WEBPACK_IMPORTED_MODULE_5__.i18nStrings[9 /* UnsupportedUnitInSizeString */]}: ${sizeString}`);\n            }\n            else {\n                return { size, sizeUnit };\n            }\n        }\n    }\n}\n/** @internal */\nfunction formatSize(size, sizeUnit) {\n    return size.toString(10) + _utils_types__WEBPACK_IMPORTED_MODULE_0__.SizeUnitEnum.format(sizeUnit);\n}\n/** @internal */\nfunction formatUndefinableSize(size, sizeUnit) {\n    if (size === undefined) {\n        return undefined;\n    }\n    else {\n        return size.toString(10) + _utils_types__WEBPACK_IMPORTED_MODULE_0__.SizeUnitEnum.format(sizeUnit);\n    }\n}\n//# sourceMappingURL=config.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/config/config.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/config/resolved-config.js":
/*!**************************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/config/resolved-config.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResolvedComponentItemConfig: () => (/* binding */ ResolvedComponentItemConfig),\n/* harmony export */   ResolvedGroundItemConfig: () => (/* binding */ ResolvedGroundItemConfig),\n/* harmony export */   ResolvedHeaderedItemConfig: () => (/* binding */ ResolvedHeaderedItemConfig),\n/* harmony export */   ResolvedItemConfig: () => (/* binding */ ResolvedItemConfig),\n/* harmony export */   ResolvedLayoutConfig: () => (/* binding */ ResolvedLayoutConfig),\n/* harmony export */   ResolvedPopoutLayoutConfig: () => (/* binding */ ResolvedPopoutLayoutConfig),\n/* harmony export */   ResolvedRootItemConfig: () => (/* binding */ ResolvedRootItemConfig),\n/* harmony export */   ResolvedRowOrColumnItemConfig: () => (/* binding */ ResolvedRowOrColumnItemConfig),\n/* harmony export */   ResolvedStackItemConfig: () => (/* binding */ ResolvedStackItemConfig)\n/* harmony export */ });\n/* harmony import */ var _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/internal-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js\");\n/* harmony import */ var _utils_config_minifier__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/config-minifier */ \"./node_modules/golden-layout/dist/esm/ts/utils/config-minifier.js\");\n/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/types */ \"./node_modules/golden-layout/dist/esm/ts/utils/types.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/golden-layout/dist/esm/ts/utils/utils.js\");\n\n\n\n\n/** @public */\nvar ResolvedItemConfig;\n(function (ResolvedItemConfig) {\n    ResolvedItemConfig.defaults = {\n        type: _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.ground,\n        content: [],\n        size: 1,\n        sizeUnit: _utils_types__WEBPACK_IMPORTED_MODULE_0__.SizeUnitEnum.Fractional,\n        minSize: undefined,\n        minSizeUnit: _utils_types__WEBPACK_IMPORTED_MODULE_0__.SizeUnitEnum.Pixel,\n        id: '',\n        isClosable: true,\n    };\n    /** Creates a copy of the original ResolvedItemConfig using an alternative content if specified */\n    function createCopy(original, content) {\n        switch (original.type) {\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.ground:\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.row:\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.column:\n                return ResolvedRowOrColumnItemConfig.createCopy(original, content);\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.stack:\n                return ResolvedStackItemConfig.createCopy(original, content);\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.component:\n                return ResolvedComponentItemConfig.createCopy(original);\n            default:\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.UnreachableCaseError('CICC91354', original.type, 'Invalid Config Item type specified');\n        }\n    }\n    ResolvedItemConfig.createCopy = createCopy;\n    function createDefault(type) {\n        switch (type) {\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.ground:\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.AssertError('CICCDR91562'); // Get default root from LayoutConfig\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.row:\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.column:\n                return ResolvedRowOrColumnItemConfig.createDefault(type);\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.stack:\n                return ResolvedStackItemConfig.createDefault();\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.component:\n                return ResolvedComponentItemConfig.createDefault();\n            default:\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.UnreachableCaseError('CICCDD91563', type, 'Invalid Config Item type specified');\n        }\n    }\n    ResolvedItemConfig.createDefault = createDefault;\n    function isComponentItem(itemConfig) {\n        return itemConfig.type === _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.component;\n    }\n    ResolvedItemConfig.isComponentItem = isComponentItem;\n    function isStackItem(itemConfig) {\n        return itemConfig.type === _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.stack;\n    }\n    ResolvedItemConfig.isStackItem = isStackItem;\n    /** @internal */\n    function isGroundItem(itemConfig) {\n        return itemConfig.type === _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.ground;\n    }\n    ResolvedItemConfig.isGroundItem = isGroundItem;\n})(ResolvedItemConfig || (ResolvedItemConfig = {}));\n/** @public */\nvar ResolvedHeaderedItemConfig;\n(function (ResolvedHeaderedItemConfig) {\n    ResolvedHeaderedItemConfig.defaultMaximised = false;\n    let Header;\n    (function (Header) {\n        function createCopy(original, show) {\n            if (original === undefined) {\n                return undefined;\n            }\n            else {\n                return {\n                    show: show !== null && show !== void 0 ? show : original.show,\n                    popout: original.popout,\n                    close: original.close,\n                    maximise: original.maximise,\n                    minimise: original.minimise,\n                    tabDropdown: original.tabDropdown,\n                };\n            }\n        }\n        Header.createCopy = createCopy;\n    })(Header = ResolvedHeaderedItemConfig.Header || (ResolvedHeaderedItemConfig.Header = {}));\n})(ResolvedHeaderedItemConfig || (ResolvedHeaderedItemConfig = {}));\n/** @public */\nvar ResolvedStackItemConfig;\n(function (ResolvedStackItemConfig) {\n    ResolvedStackItemConfig.defaultActiveItemIndex = 0;\n    function createCopy(original, content) {\n        const result = {\n            type: original.type,\n            content: content !== undefined ? copyContent(content) : copyContent(original.content),\n            size: original.size,\n            sizeUnit: original.sizeUnit,\n            minSize: original.minSize,\n            minSizeUnit: original.minSizeUnit,\n            id: original.id,\n            maximised: original.maximised,\n            isClosable: original.isClosable,\n            activeItemIndex: original.activeItemIndex,\n            header: ResolvedHeaderedItemConfig.Header.createCopy(original.header),\n        };\n        return result;\n    }\n    ResolvedStackItemConfig.createCopy = createCopy;\n    function copyContent(original) {\n        const count = original.length;\n        const result = new Array(count);\n        for (let i = 0; i < count; i++) {\n            result[i] = ResolvedItemConfig.createCopy(original[i]);\n        }\n        return result;\n    }\n    ResolvedStackItemConfig.copyContent = copyContent;\n    function createDefault() {\n        const result = {\n            type: _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.stack,\n            content: [],\n            size: ResolvedItemConfig.defaults.size,\n            sizeUnit: ResolvedItemConfig.defaults.sizeUnit,\n            minSize: ResolvedItemConfig.defaults.minSize,\n            minSizeUnit: ResolvedItemConfig.defaults.minSizeUnit,\n            id: ResolvedItemConfig.defaults.id,\n            maximised: ResolvedHeaderedItemConfig.defaultMaximised,\n            isClosable: ResolvedItemConfig.defaults.isClosable,\n            activeItemIndex: ResolvedStackItemConfig.defaultActiveItemIndex,\n            header: undefined,\n        };\n        return result;\n    }\n    ResolvedStackItemConfig.createDefault = createDefault;\n})(ResolvedStackItemConfig || (ResolvedStackItemConfig = {}));\n/** @public */\nvar ResolvedComponentItemConfig;\n(function (ResolvedComponentItemConfig) {\n    ResolvedComponentItemConfig.defaultReorderEnabled = true;\n    function resolveComponentTypeName(itemConfig) {\n        const componentType = itemConfig.componentType;\n        if (typeof componentType === 'string') {\n            return componentType;\n        }\n        else {\n            return undefined;\n        }\n    }\n    ResolvedComponentItemConfig.resolveComponentTypeName = resolveComponentTypeName;\n    function createCopy(original) {\n        const result = {\n            type: original.type,\n            content: [],\n            size: original.size,\n            sizeUnit: original.sizeUnit,\n            minSize: original.minSize,\n            minSizeUnit: original.minSizeUnit,\n            id: original.id,\n            maximised: original.maximised,\n            isClosable: original.isClosable,\n            reorderEnabled: original.reorderEnabled,\n            title: original.title,\n            header: ResolvedHeaderedItemConfig.Header.createCopy(original.header),\n            componentType: original.componentType,\n            componentState: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.deepExtendValue)(undefined, original.componentState),\n        };\n        return result;\n    }\n    ResolvedComponentItemConfig.createCopy = createCopy;\n    function createDefault(componentType = '', componentState, title = '') {\n        const result = {\n            type: _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.component,\n            content: [],\n            size: ResolvedItemConfig.defaults.size,\n            sizeUnit: ResolvedItemConfig.defaults.sizeUnit,\n            minSize: ResolvedItemConfig.defaults.minSize,\n            minSizeUnit: ResolvedItemConfig.defaults.minSizeUnit,\n            id: ResolvedItemConfig.defaults.id,\n            maximised: ResolvedHeaderedItemConfig.defaultMaximised,\n            isClosable: ResolvedItemConfig.defaults.isClosable,\n            reorderEnabled: ResolvedComponentItemConfig.defaultReorderEnabled,\n            title,\n            header: undefined,\n            componentType,\n            componentState,\n        };\n        return result;\n    }\n    ResolvedComponentItemConfig.createDefault = createDefault;\n    function copyComponentType(componentType) {\n        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.deepExtendValue)({}, componentType);\n    }\n    ResolvedComponentItemConfig.copyComponentType = copyComponentType;\n})(ResolvedComponentItemConfig || (ResolvedComponentItemConfig = {}));\n/** @public */\nvar ResolvedRowOrColumnItemConfig;\n(function (ResolvedRowOrColumnItemConfig) {\n    function isChildItemConfig(itemConfig) {\n        switch (itemConfig.type) {\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.row:\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.column:\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.stack:\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.component:\n                return true;\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.ground:\n                return false;\n            default:\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.UnreachableCaseError('CROCOSPCICIC13687', itemConfig.type);\n        }\n    }\n    ResolvedRowOrColumnItemConfig.isChildItemConfig = isChildItemConfig;\n    function createCopy(original, content) {\n        const result = {\n            type: original.type,\n            content: content !== undefined ? copyContent(content) : copyContent(original.content),\n            size: original.size,\n            sizeUnit: original.sizeUnit,\n            minSize: original.minSize,\n            minSizeUnit: original.minSizeUnit,\n            id: original.id,\n            isClosable: original.isClosable,\n        };\n        return result;\n    }\n    ResolvedRowOrColumnItemConfig.createCopy = createCopy;\n    function copyContent(original) {\n        const count = original.length;\n        const result = new Array(count);\n        for (let i = 0; i < count; i++) {\n            result[i] = ResolvedItemConfig.createCopy(original[i]);\n        }\n        return result;\n    }\n    ResolvedRowOrColumnItemConfig.copyContent = copyContent;\n    function createDefault(type) {\n        const result = {\n            type,\n            content: [],\n            size: ResolvedItemConfig.defaults.size,\n            sizeUnit: ResolvedItemConfig.defaults.sizeUnit,\n            minSize: ResolvedItemConfig.defaults.minSize,\n            minSizeUnit: ResolvedItemConfig.defaults.minSizeUnit,\n            id: ResolvedItemConfig.defaults.id,\n            isClosable: ResolvedItemConfig.defaults.isClosable,\n        };\n        return result;\n    }\n    ResolvedRowOrColumnItemConfig.createDefault = createDefault;\n})(ResolvedRowOrColumnItemConfig || (ResolvedRowOrColumnItemConfig = {}));\n/** @public */\nvar ResolvedRootItemConfig;\n(function (ResolvedRootItemConfig) {\n    function createCopy(config) {\n        return ResolvedItemConfig.createCopy(config);\n    }\n    ResolvedRootItemConfig.createCopy = createCopy;\n    function isRootItemConfig(itemConfig) {\n        switch (itemConfig.type) {\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.row:\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.column:\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.stack:\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.component:\n                return true;\n            case _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.ground:\n                return false;\n            default:\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.UnreachableCaseError('CROCOSPCICIC13687', itemConfig.type);\n        }\n    }\n    ResolvedRootItemConfig.isRootItemConfig = isRootItemConfig;\n})(ResolvedRootItemConfig || (ResolvedRootItemConfig = {}));\n/** @internal */\nvar ResolvedGroundItemConfig;\n(function (ResolvedGroundItemConfig) {\n    function create(rootItemConfig) {\n        const content = rootItemConfig === undefined ? [] : [rootItemConfig];\n        return {\n            type: _utils_types__WEBPACK_IMPORTED_MODULE_0__.ItemType.ground,\n            content,\n            size: 100,\n            sizeUnit: _utils_types__WEBPACK_IMPORTED_MODULE_0__.SizeUnitEnum.Percent,\n            minSize: 0,\n            minSizeUnit: _utils_types__WEBPACK_IMPORTED_MODULE_0__.SizeUnitEnum.Pixel,\n            id: '',\n            isClosable: false,\n            title: '',\n            reorderEnabled: false,\n        };\n    }\n    ResolvedGroundItemConfig.create = create;\n})(ResolvedGroundItemConfig || (ResolvedGroundItemConfig = {}));\n/** @public */\nvar ResolvedLayoutConfig;\n(function (ResolvedLayoutConfig) {\n    let Settings;\n    (function (Settings) {\n        Settings.defaults = {\n            constrainDragToContainer: true,\n            reorderEnabled: true,\n            popoutWholeStack: false,\n            blockedPopoutsThrowError: true,\n            closePopoutsOnUnload: true,\n            responsiveMode: _utils_types__WEBPACK_IMPORTED_MODULE_0__.ResponsiveMode.none,\n            tabOverlapAllowance: 0,\n            reorderOnTabMenuClick: true,\n            tabControlOffset: 10,\n            popInOnClose: false,\n        };\n        function createCopy(original) {\n            return {\n                constrainDragToContainer: original.constrainDragToContainer,\n                reorderEnabled: original.reorderEnabled,\n                popoutWholeStack: original.popoutWholeStack,\n                blockedPopoutsThrowError: original.blockedPopoutsThrowError,\n                closePopoutsOnUnload: original.closePopoutsOnUnload,\n                responsiveMode: original.responsiveMode,\n                tabOverlapAllowance: original.tabOverlapAllowance,\n                reorderOnTabMenuClick: original.reorderOnTabMenuClick,\n                tabControlOffset: original.tabControlOffset,\n                popInOnClose: original.popInOnClose,\n            };\n        }\n        Settings.createCopy = createCopy;\n    })(Settings = ResolvedLayoutConfig.Settings || (ResolvedLayoutConfig.Settings = {}));\n    let Dimensions;\n    (function (Dimensions) {\n        function createCopy(original) {\n            return {\n                borderWidth: original.borderWidth,\n                borderGrabWidth: original.borderGrabWidth,\n                defaultMinItemHeight: original.defaultMinItemHeight,\n                defaultMinItemHeightUnit: original.defaultMinItemHeightUnit,\n                defaultMinItemWidth: original.defaultMinItemWidth,\n                defaultMinItemWidthUnit: original.defaultMinItemWidthUnit,\n                headerHeight: original.headerHeight,\n                dragProxyWidth: original.dragProxyWidth,\n                dragProxyHeight: original.dragProxyHeight,\n            };\n        }\n        Dimensions.createCopy = createCopy;\n        Dimensions.defaults = {\n            borderWidth: 5,\n            borderGrabWidth: 5,\n            defaultMinItemHeight: 0,\n            defaultMinItemHeightUnit: _utils_types__WEBPACK_IMPORTED_MODULE_0__.SizeUnitEnum.Pixel,\n            defaultMinItemWidth: 10,\n            defaultMinItemWidthUnit: _utils_types__WEBPACK_IMPORTED_MODULE_0__.SizeUnitEnum.Pixel,\n            headerHeight: 20,\n            dragProxyWidth: 300,\n            dragProxyHeight: 200\n        };\n    })(Dimensions = ResolvedLayoutConfig.Dimensions || (ResolvedLayoutConfig.Dimensions = {}));\n    let Header;\n    (function (Header) {\n        function createCopy(original) {\n            return {\n                show: original.show,\n                popout: original.popout,\n                dock: original.dock,\n                close: original.close,\n                maximise: original.maximise,\n                minimise: original.minimise,\n                tabDropdown: original.tabDropdown,\n            };\n        }\n        Header.createCopy = createCopy;\n        Header.defaults = {\n            show: _utils_types__WEBPACK_IMPORTED_MODULE_0__.Side.top,\n            popout: 'open in new window',\n            dock: 'dock',\n            maximise: 'maximise',\n            minimise: 'minimise',\n            close: 'close',\n            tabDropdown: 'additional tabs'\n        };\n    })(Header = ResolvedLayoutConfig.Header || (ResolvedLayoutConfig.Header = {}));\n    function isPopout(config) {\n        return 'parentId' in config;\n    }\n    ResolvedLayoutConfig.isPopout = isPopout;\n    function createDefault() {\n        const result = {\n            root: undefined,\n            openPopouts: [],\n            dimensions: ResolvedLayoutConfig.Dimensions.defaults,\n            settings: ResolvedLayoutConfig.Settings.defaults,\n            header: ResolvedLayoutConfig.Header.defaults,\n            resolved: true,\n        };\n        return result;\n    }\n    ResolvedLayoutConfig.createDefault = createDefault;\n    function createCopy(config) {\n        if (isPopout(config)) {\n            return ResolvedPopoutLayoutConfig.createCopy(config);\n        }\n        else {\n            const result = {\n                root: config.root === undefined ? undefined : ResolvedRootItemConfig.createCopy(config.root),\n                openPopouts: ResolvedLayoutConfig.copyOpenPopouts(config.openPopouts),\n                settings: ResolvedLayoutConfig.Settings.createCopy(config.settings),\n                dimensions: ResolvedLayoutConfig.Dimensions.createCopy(config.dimensions),\n                header: ResolvedLayoutConfig.Header.createCopy(config.header),\n                resolved: config.resolved,\n            };\n            return result;\n        }\n    }\n    ResolvedLayoutConfig.createCopy = createCopy;\n    function copyOpenPopouts(original) {\n        const count = original.length;\n        const result = new Array(count);\n        for (let i = 0; i < count; i++) {\n            result[i] = ResolvedPopoutLayoutConfig.createCopy(original[i]);\n        }\n        return result;\n    }\n    ResolvedLayoutConfig.copyOpenPopouts = copyOpenPopouts;\n    /**\n     * Takes a GoldenLayout configuration object and\n     * replaces its keys and values recursively with\n     * one letter counterparts\n     */\n    function minifyConfig(layoutConfig) {\n        return _utils_config_minifier__WEBPACK_IMPORTED_MODULE_3__.ConfigMinifier.translateObject(layoutConfig, true);\n    }\n    ResolvedLayoutConfig.minifyConfig = minifyConfig;\n    /**\n     * Takes a configuration Object that was previously minified\n     * using minifyConfig and returns its original version\n     */\n    function unminifyConfig(minifiedConfig) {\n        return _utils_config_minifier__WEBPACK_IMPORTED_MODULE_3__.ConfigMinifier.translateObject(minifiedConfig, false);\n    }\n    ResolvedLayoutConfig.unminifyConfig = unminifyConfig;\n})(ResolvedLayoutConfig || (ResolvedLayoutConfig = {}));\n/** @public */\nvar ResolvedPopoutLayoutConfig;\n(function (ResolvedPopoutLayoutConfig) {\n    let Window;\n    (function (Window) {\n        function createCopy(original) {\n            return {\n                width: original.width,\n                height: original.height,\n                left: original.left,\n                top: original.top,\n            };\n        }\n        Window.createCopy = createCopy;\n        Window.defaults = {\n            width: null,\n            height: null,\n            left: null,\n            top: null,\n        };\n    })(Window = ResolvedPopoutLayoutConfig.Window || (ResolvedPopoutLayoutConfig.Window = {}));\n    function createCopy(original) {\n        const result = {\n            root: original.root === undefined ? undefined : ResolvedRootItemConfig.createCopy(original.root),\n            openPopouts: ResolvedLayoutConfig.copyOpenPopouts(original.openPopouts),\n            settings: ResolvedLayoutConfig.Settings.createCopy(original.settings),\n            dimensions: ResolvedLayoutConfig.Dimensions.createCopy(original.dimensions),\n            header: ResolvedLayoutConfig.Header.createCopy(original.header),\n            parentId: original.parentId,\n            indexInParent: original.indexInParent,\n            window: ResolvedPopoutLayoutConfig.Window.createCopy(original.window),\n            resolved: original.resolved,\n        };\n        return result;\n    }\n    ResolvedPopoutLayoutConfig.createCopy = createCopy;\n})(ResolvedPopoutLayoutConfig || (ResolvedPopoutLayoutConfig = {}));\n//# sourceMappingURL=resolved-config.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/config/resolved-config.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/container/component-container.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/container/component-container.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ComponentContainer: () => (/* binding */ ComponentContainer)\n/* harmony export */ });\n/* harmony import */ var _config_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../config/config */ \"./node_modules/golden-layout/dist/esm/ts/config/config.js\");\n/* harmony import */ var _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/internal-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js\");\n/* harmony import */ var _utils_event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/event-emitter */ \"./node_modules/golden-layout/dist/esm/ts/utils/event-emitter.js\");\n/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/types */ \"./node_modules/golden-layout/dist/esm/ts/utils/types.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/golden-layout/dist/esm/ts/utils/utils.js\");\n\n\n\n\n\n/** @public */\nclass ComponentContainer extends _utils_event_emitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    /** @internal */\n    constructor(\n    /** @internal */\n    _config, \n    /** @internal */\n    _parent, \n    /** @internal */\n    _layoutManager, \n    /** @internal */\n    _element, \n    /** @internal */\n    _updateItemConfigEvent, \n    /** @internal */\n    _showEvent, \n    /** @internal */\n    _hideEvent, \n    /** @internal */\n    _focusEvent, \n    /** @internal */\n    _blurEvent) {\n        super();\n        this._config = _config;\n        this._parent = _parent;\n        this._layoutManager = _layoutManager;\n        this._element = _element;\n        this._updateItemConfigEvent = _updateItemConfigEvent;\n        this._showEvent = _showEvent;\n        this._hideEvent = _hideEvent;\n        this._focusEvent = _focusEvent;\n        this._blurEvent = _blurEvent;\n        /** @internal */\n        this._stackMaximised = false;\n        this._width = 0;\n        this._height = 0;\n        this._visible = true;\n        this._isShownWithZeroDimensions = true;\n        this._componentType = _config.componentType;\n        this._isClosable = _config.isClosable;\n        this._initialState = _config.componentState;\n        this._state = this._initialState;\n        this._boundComponent = this.layoutManager.bindComponent(this, _config);\n        this.updateElementPositionPropertyFromBoundComponent();\n    }\n    get width() { return this._width; }\n    get height() { return this._height; }\n    get parent() { return this._parent; }\n    /** @internal @deprecated use {@link (ComponentContainer:class).componentType} */\n    get componentName() { return this._componentType; }\n    get componentType() { return this._componentType; }\n    get virtual() { return this._boundComponent.virtual; }\n    get component() { return this._boundComponent.component; }\n    get tab() { return this._tab; }\n    get title() { return this._parent.title; }\n    get layoutManager() { return this._layoutManager; }\n    get isHidden() { return !this._visible; }\n    get visible() { return this._visible; }\n    get state() { return this._state; }\n    /** Return the initial component state */\n    get initialState() { return this._initialState; }\n    /** The inner DOM element where the container's content is intended to live in */\n    get element() { return this._element; }\n    /** @internal */\n    destroy() {\n        this.releaseComponent();\n        this.stateRequestEvent = undefined;\n        this.emit('destroy');\n    }\n    /** @deprecated use {@link (ComponentContainer:class).element } */\n    getElement() {\n        return this._element;\n    }\n    /**\n     * Hides the container's component item (and hence, the container) if not already hidden.\n     * Emits hide event prior to hiding the container.\n     */\n    hide() {\n        this._hideEvent();\n    }\n    /**\n     * Shows the container's component item (and hence, the container) if not visible.\n     * Emits show event prior to hiding the container.\n     */\n    show() {\n        this._showEvent();\n    }\n    /**\n     * Focus this component in Layout.\n     */\n    focus(suppressEvent = false) {\n        this._focusEvent(suppressEvent);\n    }\n    /**\n     * Remove focus from this component in Layout.\n     */\n    blur(suppressEvent = false) {\n        this._blurEvent(suppressEvent);\n    }\n    /**\n     * Set the size from within the container. Traverses up\n     * the item tree until it finds a row or column element\n     * and resizes its items accordingly.\n     *\n     * If this container isn't a descendant of a row or column\n     * it returns false\n     * @param width - The new width in pixel\n     * @param height - The new height in pixel\n     *\n     * @returns resizeSuccesful\n     *\n     * @internal\n     */\n    setSize(width, height) {\n        let ancestorItem = this._parent;\n        if (ancestorItem.isColumn || ancestorItem.isRow || ancestorItem.parent === null) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.AssertError('ICSSPRC', 'ComponentContainer cannot have RowColumn Parent');\n        }\n        else {\n            let ancestorChildItem;\n            do {\n                ancestorChildItem = ancestorItem;\n                ancestorItem = ancestorItem.parent;\n            } while (ancestorItem !== null && !ancestorItem.isColumn && !ancestorItem.isRow);\n            if (ancestorItem === null) {\n                // no Row or Column found\n                return false;\n            }\n            else {\n                // ancestorItem is Row or Column\n                const direction = ancestorItem.isColumn ? 'height' : 'width';\n                const currentSize = this[direction];\n                if (currentSize === null) {\n                    throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.UnexpectedNullError('ICSSCS11194');\n                }\n                else {\n                    const newSize = direction === 'height' ? height : width;\n                    const totalPixel = currentSize * (1 / (ancestorChildItem.size / 100));\n                    const percentage = (newSize / totalPixel) * 100;\n                    const delta = (ancestorChildItem.size - percentage) / (ancestorItem.contentItems.length - 1);\n                    for (let i = 0; i < ancestorItem.contentItems.length; i++) {\n                        const ancestorItemContentItem = ancestorItem.contentItems[i];\n                        if (ancestorItemContentItem === ancestorChildItem) {\n                            ancestorItemContentItem.size = percentage;\n                        }\n                        else {\n                            ancestorItemContentItem.size += delta;\n                        }\n                    }\n                    ancestorItem.updateSize(false);\n                    return true;\n                }\n            }\n        }\n    }\n    /**\n     * Closes the container if it is closable. Can be called by\n     * both the component within at as well as the contentItem containing\n     * it. Emits a close event before the container itself is closed.\n     */\n    close() {\n        if (this._isClosable) {\n            this.emit('close');\n            this._parent.close();\n        }\n    }\n    /** Replaces component without affecting layout */\n    replaceComponent(itemConfig) {\n        this.releaseComponent();\n        if (!_config_config__WEBPACK_IMPORTED_MODULE_2__.ItemConfig.isComponent(itemConfig)) {\n            throw new Error('ReplaceComponent not passed a component ItemConfig');\n        }\n        else {\n            const config = _config_config__WEBPACK_IMPORTED_MODULE_2__.ComponentItemConfig.resolve(itemConfig, false);\n            this._initialState = config.componentState;\n            this._state = this._initialState;\n            this._componentType = config.componentType;\n            this._updateItemConfigEvent(config);\n            this._boundComponent = this.layoutManager.bindComponent(this, config);\n            this.updateElementPositionPropertyFromBoundComponent();\n            if (this._boundComponent.virtual) {\n                if (this.virtualVisibilityChangeRequiredEvent !== undefined) {\n                    this.virtualVisibilityChangeRequiredEvent(this, this._visible);\n                }\n                if (this.virtualRectingRequiredEvent !== undefined) {\n                    this._layoutManager.fireBeforeVirtualRectingEvent(1);\n                    try {\n                        this.virtualRectingRequiredEvent(this, this._width, this._height);\n                    }\n                    finally {\n                        this._layoutManager.fireAfterVirtualRectingEvent();\n                    }\n                }\n                this.setBaseLogicalZIndex();\n            }\n            this.emit('stateChanged');\n        }\n    }\n    /**\n     * Returns the initial component state or the latest passed in setState()\n     * @returns state\n     * @deprecated Use {@link (ComponentContainer:class).initialState}\n     */\n    getState() {\n        return this._state;\n    }\n    /**\n     * Merges the provided state into the current one\n     * @deprecated Use {@link (ComponentContainer:class).stateRequestEvent}\n     */\n    extendState(state) {\n        const extendedState = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_3__.deepExtend)(this._state, state);\n        this.setState(extendedState);\n    }\n    /**\n     * Sets the component state\n     * @deprecated Use {@link (ComponentContainer:class).stateRequestEvent}\n     */\n    setState(state) {\n        this._state = state;\n        this._parent.emitBaseBubblingEvent('stateChanged');\n    }\n    /**\n     * Set's the components title\n     */\n    setTitle(title) {\n        this._parent.setTitle(title);\n    }\n    /** @internal */\n    setTab(tab) {\n        this._tab = tab;\n        this.emit('tab', tab);\n    }\n    /** @internal */\n    setVisibility(value) {\n        if (this._boundComponent.virtual) {\n            if (this.virtualVisibilityChangeRequiredEvent !== undefined) {\n                this.virtualVisibilityChangeRequiredEvent(this, value);\n            }\n        }\n        if (value) {\n            if (!this._visible) {\n                this._visible = true;\n                if (this._height === 0 && this._width === 0) {\n                    this._isShownWithZeroDimensions = true;\n                }\n                else {\n                    this._isShownWithZeroDimensions = false;\n                    this.setSizeToNodeSize(this._width, this._height, true);\n                    this.emitShow();\n                }\n            }\n            else {\n                if (this._isShownWithZeroDimensions && (this._height !== 0 || this._width !== 0)) {\n                    this._isShownWithZeroDimensions = false;\n                    this.setSizeToNodeSize(this._width, this._height, true);\n                    this.emitShow();\n                }\n            }\n        }\n        else {\n            if (this._visible) {\n                this._visible = false;\n                this._isShownWithZeroDimensions = false;\n                this.emitHide();\n            }\n        }\n    }\n    setBaseLogicalZIndex() {\n        this.setLogicalZIndex(_utils_types__WEBPACK_IMPORTED_MODULE_4__.LogicalZIndex.base);\n    }\n    setLogicalZIndex(logicalZIndex) {\n        if (logicalZIndex !== this._logicalZIndex) {\n            this._logicalZIndex = logicalZIndex;\n            this.notifyVirtualZIndexChangeRequired();\n        }\n    }\n    /**\n     * Set the container's size, but considered temporary (for dragging)\n     * so don't emit any events.\n     * @internal\n     */\n    enterDragMode(width, height) {\n        this._width = width;\n        this._height = height;\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_3__.setElementWidth)(this._element, width);\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_3__.setElementHeight)(this._element, height);\n        this.setLogicalZIndex(_utils_types__WEBPACK_IMPORTED_MODULE_4__.LogicalZIndex.drag);\n        this.drag();\n    }\n    /** @internal */\n    exitDragMode() {\n        this.setBaseLogicalZIndex();\n    }\n    /** @internal */\n    enterStackMaximised() {\n        this._stackMaximised = true;\n        this.setLogicalZIndex(_utils_types__WEBPACK_IMPORTED_MODULE_4__.LogicalZIndex.stackMaximised);\n    }\n    /** @internal */\n    exitStackMaximised() {\n        this.setBaseLogicalZIndex();\n        this._stackMaximised = false;\n    }\n    /** @internal */\n    drag() {\n        if (this._boundComponent.virtual) {\n            if (this.virtualRectingRequiredEvent !== undefined) {\n                this._layoutManager.fireBeforeVirtualRectingEvent(1);\n                try {\n                    this.virtualRectingRequiredEvent(this, this._width, this._height);\n                }\n                finally {\n                    this._layoutManager.fireAfterVirtualRectingEvent();\n                }\n            }\n        }\n    }\n    /**\n     * Sets the container's size. Called by the container's component item.\n     * To instead set the size programmatically from within the component itself,\n     * use the public setSize method\n     * @param width - in px\n     * @param height - in px\n     * @param force - set even if no change\n     * @internal\n     */\n    setSizeToNodeSize(width, height, force) {\n        if (width !== this._width || height !== this._height || force) {\n            this._width = width;\n            this._height = height;\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_3__.setElementWidth)(this._element, width);\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_3__.setElementHeight)(this._element, height);\n            if (this._boundComponent.virtual) {\n                this.addVirtualSizedContainerToLayoutManager();\n            }\n            else {\n                this.emit('resize');\n                this.checkShownFromZeroDimensions();\n            }\n        }\n    }\n    /** @internal */\n    notifyVirtualRectingRequired() {\n        if (this.virtualRectingRequiredEvent !== undefined) {\n            this.virtualRectingRequiredEvent(this, this._width, this._height);\n            this.emit('resize');\n            this.checkShownFromZeroDimensions();\n        }\n    }\n    /** @internal */\n    notifyVirtualZIndexChangeRequired() {\n        if (this.virtualZIndexChangeRequiredEvent !== undefined) {\n            const logicalZIndex = this._logicalZIndex;\n            const defaultZIndex = _utils_types__WEBPACK_IMPORTED_MODULE_4__.LogicalZIndexToDefaultMap[logicalZIndex];\n            this.virtualZIndexChangeRequiredEvent(this, logicalZIndex, defaultZIndex);\n        }\n    }\n    /** @internal */\n    updateElementPositionPropertyFromBoundComponent() {\n        if (this._boundComponent.virtual) {\n            this._element.style.position = 'static';\n        }\n        else {\n            this._element.style.position = ''; // set it back to attribute value\n        }\n    }\n    /** @internal */\n    addVirtualSizedContainerToLayoutManager() {\n        this._layoutManager.beginVirtualSizedContainerAdding();\n        try {\n            this._layoutManager.addVirtualSizedContainer(this);\n        }\n        finally {\n            this._layoutManager.endVirtualSizedContainerAdding();\n        }\n    }\n    /** @internal */\n    checkShownFromZeroDimensions() {\n        if (this._isShownWithZeroDimensions && (this._height !== 0 || this._width !== 0)) {\n            this._isShownWithZeroDimensions = false;\n            this.emitShow();\n        }\n    }\n    /** @internal */\n    emitShow() {\n        this.emit('shown');\n        this.emit('show');\n    }\n    /** @internal */\n    emitHide() {\n        this.emit('hide');\n    }\n    /** @internal */\n    releaseComponent() {\n        if (this._stackMaximised) {\n            this.exitStackMaximised();\n        }\n        this.emit('beforeComponentRelease', this._boundComponent.component);\n        this.layoutManager.unbindComponent(this, this._boundComponent.virtual, this._boundComponent.component);\n    }\n}\n//# sourceMappingURL=component-container.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/container/component-container.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/controls/browser-popout.js":
/*!***************************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/controls/browser-popout.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BrowserPopout: () => (/* binding */ BrowserPopout)\n/* harmony export */ });\n/* harmony import */ var _config_resolved_config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../config/resolved-config */ \"./node_modules/golden-layout/dist/esm/ts/config/resolved-config.js\");\n/* harmony import */ var _errors_external_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../errors/external-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/external-error.js\");\n/* harmony import */ var _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/internal-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js\");\n/* harmony import */ var _utils_event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/event-emitter */ \"./node_modules/golden-layout/dist/esm/ts/utils/event-emitter.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/golden-layout/dist/esm/ts/utils/utils.js\");\n\n\n\n\n\n/**\n * Pops a content item out into a new browser window.\n * This is achieved by\n *\n *    - Creating a new configuration with the content item as root element\n *    - Serializing and minifying the configuration\n *    - Opening the current window's URL with the configuration as a GET parameter\n *    - GoldenLayout when opened in the new window will look for the GET parameter\n *      and use it instead of the provided configuration\n * @public\n */\nclass BrowserPopout extends _utils_event_emitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    /**\n     * @param _config - GoldenLayout item config\n     * @param _initialWindowSize - A map with width, height, top and left\n     * @internal\n     */\n    constructor(\n    /** @internal */\n    _config, \n    /** @internal */\n    _initialWindowSize, \n    /** @internal */\n    _layoutManager) {\n        super();\n        this._config = _config;\n        this._initialWindowSize = _initialWindowSize;\n        this._layoutManager = _layoutManager;\n        this._isInitialised = false;\n        this._popoutWindow = null;\n        this.createWindow();\n    }\n    toConfig() {\n        var _a, _b;\n        if (this._isInitialised === false) {\n            throw new Error('Can\\'t create config, layout not yet initialised');\n        }\n        const glInstance = this.getGlInstance();\n        const glInstanceConfig = glInstance.saveLayout();\n        let left;\n        let top;\n        if (this._popoutWindow === null) {\n            left = null;\n            top = null;\n        }\n        else {\n            left = (_a = this._popoutWindow.screenX) !== null && _a !== void 0 ? _a : this._popoutWindow.screenLeft;\n            top = (_b = this._popoutWindow.screenY) !== null && _b !== void 0 ? _b : this._popoutWindow.screenTop;\n        }\n        const window = {\n            width: this.getGlInstance().width,\n            height: this.getGlInstance().height,\n            left,\n            top,\n        };\n        const config = {\n            root: glInstanceConfig.root,\n            openPopouts: glInstanceConfig.openPopouts,\n            settings: glInstanceConfig.settings,\n            dimensions: glInstanceConfig.dimensions,\n            header: glInstanceConfig.header,\n            window,\n            parentId: this._config.parentId,\n            indexInParent: this._config.indexInParent,\n            resolved: true,\n        };\n        return config;\n    }\n    getGlInstance() {\n        if (this._popoutWindow === null) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.UnexpectedNullError('BPGGI24693');\n        }\n        return this._popoutWindow.__glInstance;\n    }\n    /**\n     * Retrieves the native BrowserWindow backing this popout.\n     * Might throw an UnexpectedNullError exception when the window is not initialized yet.\n     * @public\n     */\n    getWindow() {\n        if (this._popoutWindow === null) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.UnexpectedNullError('BPGW087215');\n        }\n        return this._popoutWindow;\n    }\n    close() {\n        if (this.getGlInstance()) {\n            this.getGlInstance().closeWindow();\n        }\n        else {\n            try {\n                this.getWindow().close();\n            }\n            catch (e) {\n                //\n            }\n        }\n    }\n    /**\n     * Returns the popped out item to its original position. If the original\n     * parent isn't available anymore it falls back to the layout's topmost element\n     */\n    popIn() {\n        let parentItem;\n        let index = this._config.indexInParent;\n        if (!this._config.parentId) {\n            return;\n        }\n        /*\n        * The deepExtend call seems a bit pointless, but it's crucial to\n        * copy the config returned by this.getGlInstance().toConfig()\n        * onto a new object. Internet Explorer keeps the references\n        * to objects on the child window, resulting in the following error\n        * once the child window is closed:\n        *\n        * The callee (server [not server application]) is not available and disappeared\n        */\n        const glInstanceLayoutConfig = this.getGlInstance().saveLayout();\n        const copiedGlInstanceLayoutConfig = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.deepExtend)({}, glInstanceLayoutConfig);\n        const copiedRoot = copiedGlInstanceLayoutConfig.root;\n        if (copiedRoot === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.UnexpectedUndefinedError('BPPIR19998');\n        }\n        const groundItem = this._layoutManager.groundItem;\n        if (groundItem === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.UnexpectedUndefinedError('BPPIG34972');\n        }\n        parentItem = groundItem.getItemsByPopInParentId(this._config.parentId)[0];\n        /*\n        * Fallback if parentItem is not available. Either add it to the topmost\n        * item or make it the topmost item if the layout is empty\n        */\n        if (!parentItem) {\n            if (groundItem.contentItems.length > 0) {\n                parentItem = groundItem.contentItems[0];\n            }\n            else {\n                parentItem = groundItem;\n            }\n            index = 0;\n        }\n        const newContentItem = this._layoutManager.createAndInitContentItem(copiedRoot, parentItem);\n        parentItem.addChild(newContentItem, index);\n        if (this._layoutManager.layoutConfig.settings.popInOnClose) {\n            this._onClose();\n        }\n        else {\n            this.close();\n        }\n    }\n    /**\n     * Creates the URL and window parameter\n     * and opens a new window\n     * @internal\n     */\n    createWindow() {\n        const url = this.createUrl();\n        /**\n         * Bogus title to prevent re-usage of existing window with the\n         * same title. The actual title will be set by the new window's\n         * GoldenLayout instance if it detects that it is in subWindowMode\n         */\n        const target = Math.floor(Math.random() * 1000000).toString(36);\n        /**\n         * The options as used in the window.open string\n         */\n        const features = this.serializeWindowFeatures({\n            width: this._initialWindowSize.width,\n            height: this._initialWindowSize.height,\n            innerWidth: this._initialWindowSize.width,\n            innerHeight: this._initialWindowSize.height,\n            menubar: 'no',\n            toolbar: 'no',\n            location: 'no',\n            personalbar: 'no',\n            resizable: 'yes',\n            scrollbars: 'no',\n            status: 'no'\n        });\n        this._popoutWindow = globalThis.open(url, target, features);\n        if (!this._popoutWindow) {\n            if (this._layoutManager.layoutConfig.settings.blockedPopoutsThrowError === true) {\n                const error = new _errors_external_error__WEBPACK_IMPORTED_MODULE_3__.PopoutBlockedError('Popout blocked');\n                throw error;\n            }\n            else {\n                return;\n            }\n        }\n        this._popoutWindow.addEventListener('load', () => this.positionWindow(), { passive: true });\n        this._popoutWindow.addEventListener('beforeunload', () => {\n            if (this._layoutManager.layoutConfig.settings.popInOnClose) {\n                this.popIn();\n            }\n            else {\n                this._onClose();\n            }\n        }, { passive: true });\n        /**\n         * Polling the childwindow to find out if GoldenLayout has been initialised\n         * doesn't seem optimal, but the alternatives - adding a callback to the parent\n         * window or raising an event on the window object - both would introduce knowledge\n         * about the parent to the child window which we'd rather avoid\n         */\n        this._checkReadyInterval = setInterval(() => this.checkReady(), 10);\n    }\n    /** @internal */\n    checkReady() {\n        if (this._popoutWindow === null) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.UnexpectedNullError('BPCR01844');\n        }\n        else {\n            if (this._popoutWindow.__glInstance && this._popoutWindow.__glInstance.isInitialised) {\n                this.onInitialised();\n                if (this._checkReadyInterval !== undefined) {\n                    clearInterval(this._checkReadyInterval);\n                    this._checkReadyInterval = undefined;\n                }\n            }\n        }\n    }\n    /**\n     * Serialises a map of key:values to a window options string\n     *\n     * @param windowOptions -\n     *\n     * @returns serialised window options\n     * @internal\n     */\n    serializeWindowFeatures(windowOptions) {\n        const windowOptionsString = [];\n        for (const key in windowOptions) {\n            windowOptionsString.push(key + '=' + windowOptions[key].toString());\n        }\n        return windowOptionsString.join(',');\n    }\n    /**\n     * Creates the URL for the new window, including the\n     * config GET parameter\n     *\n     * @returns URL\n     * @internal\n     */\n    createUrl() {\n        const storageKey = 'gl-window-config-' + (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.getUniqueId)();\n        const config = _config_resolved_config__WEBPACK_IMPORTED_MODULE_4__.ResolvedLayoutConfig.minifyConfig(this._config);\n        try {\n            localStorage.setItem(storageKey, JSON.stringify(config));\n        }\n        catch (e) {\n            throw new Error('Error while writing to localStorage ' + (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(e));\n        }\n        const url = new URL(location.href);\n        url.searchParams.set('gl-window', storageKey);\n        return url.toString();\n    }\n    /**\n     * Move the newly created window roughly to\n     * where the component used to be.\n     * @internal\n     */\n    positionWindow() {\n        if (this._popoutWindow === null) {\n            throw new Error('BrowserPopout.positionWindow: null popoutWindow');\n        }\n        else {\n            this._popoutWindow.moveTo(this._initialWindowSize.left, this._initialWindowSize.top);\n            this._popoutWindow.focus();\n        }\n    }\n    /**\n     * Callback when the new window is opened and the GoldenLayout instance\n     * within it is initialised\n     * @internal\n     */\n    onInitialised() {\n        this._isInitialised = true;\n        this.getGlInstance().on('popIn', () => this.popIn());\n        this.emit('initialised');\n    }\n    /**\n     * Invoked 50ms after the window unload event\n     * @internal\n     */\n    _onClose() {\n        setTimeout(() => this.emit('closed'), 50);\n    }\n}\n//# sourceMappingURL=browser-popout.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/controls/browser-popout.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/controls/drag-proxy.js":
/*!***********************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/controls/drag-proxy.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DragProxy: () => (/* binding */ DragProxy)\n/* harmony export */ });\n/* harmony import */ var _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/internal-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js\");\n/* harmony import */ var _items_stack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../items/stack */ \"./node_modules/golden-layout/dist/esm/ts/items/stack.js\");\n/* harmony import */ var _utils_event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/event-emitter */ \"./node_modules/golden-layout/dist/esm/ts/utils/event-emitter.js\");\n/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/types */ \"./node_modules/golden-layout/dist/esm/ts/utils/types.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/golden-layout/dist/esm/ts/utils/utils.js\");\n\n\n\n\n\n/**\n * This class creates a temporary container\n * for the component whilst it is being dragged\n * and handles drag events\n * @internal\n */\nclass DragProxy extends _utils_event_emitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    /**\n     * @param x - The initial x position\n     * @param y - The initial y position\n     * @internal\n     */\n    constructor(x, y, _dragListener, _layoutManager, _componentItem, _originalParent) {\n        super();\n        this._dragListener = _dragListener;\n        this._layoutManager = _layoutManager;\n        this._componentItem = _componentItem;\n        this._originalParent = _originalParent;\n        this._area = null;\n        this._lastValidArea = null;\n        this._dragListener.on('drag', (offsetX, offsetY, event) => this.onDrag(offsetX, offsetY, event));\n        this._dragListener.on('dragStop', () => this.onDrop());\n        this.createDragProxyElements(x, y);\n        if (this._componentItem.parent === null) {\n            // Note that _contentItem will have dummy GroundItem as parent if initiated by a external drag source\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.UnexpectedNullError('DPC10097');\n        }\n        this._componentItemFocused = this._componentItem.focused;\n        if (this._componentItemFocused) {\n            this._componentItem.blur();\n        }\n        this._componentItem.parent.removeChild(this._componentItem, true);\n        this.setDimensions();\n        document.body.appendChild(this._element);\n        this.determineMinMaxXY();\n        this._layoutManager.calculateItemAreas();\n        this.setDropPosition(x, y);\n    }\n    get element() { return this._element; }\n    /** Create Stack-like structure to contain the dragged component */\n    createDragProxyElements(initialX, initialY) {\n        this._element = document.createElement('div');\n        this._element.classList.add(\"lm_dragProxy\" /* DragProxy */);\n        const headerElement = document.createElement('div');\n        headerElement.classList.add(\"lm_header\" /* Header */);\n        const tabsElement = document.createElement('div');\n        tabsElement.classList.add(\"lm_tabs\" /* Tabs */);\n        const tabElement = document.createElement('div');\n        tabElement.classList.add(\"lm_tab\" /* Tab */);\n        const titleElement = document.createElement('span');\n        titleElement.classList.add(\"lm_title\" /* Title */);\n        tabElement.appendChild(titleElement);\n        tabsElement.appendChild(tabElement);\n        headerElement.appendChild(tabsElement);\n        this._proxyContainerElement = document.createElement('div');\n        this._proxyContainerElement.classList.add(\"lm_content\" /* Content */);\n        this._element.appendChild(headerElement);\n        this._element.appendChild(this._proxyContainerElement);\n        if (this._originalParent instanceof _items_stack__WEBPACK_IMPORTED_MODULE_2__.Stack && this._originalParent.headerShow) {\n            this._sided = this._originalParent.headerLeftRightSided;\n            this._element.classList.add('lm_' + this._originalParent.headerSide);\n            if ([_utils_types__WEBPACK_IMPORTED_MODULE_3__.Side.right, _utils_types__WEBPACK_IMPORTED_MODULE_3__.Side.bottom].indexOf(this._originalParent.headerSide) >= 0) {\n                this._proxyContainerElement.insertAdjacentElement('afterend', headerElement);\n            }\n        }\n        this._element.style.left = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.numberToPixels)(initialX);\n        this._element.style.top = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.numberToPixels)(initialY);\n        tabElement.setAttribute('title', this._componentItem.title);\n        titleElement.insertAdjacentText('afterbegin', this._componentItem.title);\n        this._proxyContainerElement.appendChild(this._componentItem.element);\n    }\n    determineMinMaxXY() {\n        const groundItem = this._layoutManager.groundItem;\n        if (groundItem === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.UnexpectedUndefinedError('DPDMMXY73109');\n        }\n        else {\n            const groundElement = groundItem.element;\n            const rect = groundElement.getBoundingClientRect();\n            this._minX = rect.left + document.body.scrollLeft;\n            this._minY = rect.top + document.body.scrollTop;\n            this._maxX = this._minX + rect.width;\n            this._maxY = this._minY + rect.height;\n        }\n    }\n    /**\n     * Callback on every mouseMove event during a drag. Determines if the drag is\n     * still within the valid drag area and calls the layoutManager to highlight the\n     * current drop area\n     *\n     * @param offsetX - The difference from the original x position in px\n     * @param offsetY - The difference from the original y position in px\n     * @param event -\n     * @internal\n     */\n    onDrag(offsetX, offsetY, event) {\n        const x = event.pageX;\n        const y = event.pageY;\n        this.setDropPosition(x, y);\n        this._componentItem.drag();\n    }\n    /**\n     * Sets the target position, highlighting the appropriate area\n     *\n     * @param x - The x position in px\n     * @param y - The y position in px\n     *\n     * @internal\n     */\n    setDropPosition(x, y) {\n        if (this._layoutManager.layoutConfig.settings.constrainDragToContainer) {\n            if (x <= this._minX) {\n                x = Math.ceil(this._minX);\n            }\n            else if (x >= this._maxX) {\n                x = Math.floor(this._maxX);\n            }\n            if (y <= this._minY) {\n                y = Math.ceil(this._minY);\n            }\n            else if (y >= this._maxY) {\n                y = Math.floor(this._maxY);\n            }\n        }\n        this._element.style.left = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.numberToPixels)(x);\n        this._element.style.top = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.numberToPixels)(y);\n        this._area = this._layoutManager.getArea(x, y);\n        if (this._area !== null) {\n            this._lastValidArea = this._area;\n            this._area.contentItem.highlightDropZone(x, y, this._area);\n        }\n    }\n    /**\n     * Callback when the drag has finished. Determines the drop area\n     * and adds the child to it\n     * @internal\n     */\n    onDrop() {\n        const dropTargetIndicator = this._layoutManager.dropTargetIndicator;\n        if (dropTargetIndicator === null) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.UnexpectedNullError('DPOD30011');\n        }\n        else {\n            dropTargetIndicator.hide();\n        }\n        this._componentItem.exitDragMode();\n        /*\n         * Valid drop area found\n         */\n        let droppedComponentItem;\n        if (this._area !== null) {\n            droppedComponentItem = this._componentItem;\n            this._area.contentItem.onDrop(droppedComponentItem, this._area);\n            /**\n             * No valid drop area available at present, but one has been found before.\n             * Use it\n             */\n        }\n        else if (this._lastValidArea !== null) {\n            droppedComponentItem = this._componentItem;\n            const newParentContentItem = this._lastValidArea.contentItem;\n            newParentContentItem.onDrop(droppedComponentItem, this._lastValidArea);\n            /**\n             * No valid drop area found during the duration of the drag. Return\n             * content item to its original position if a original parent is provided.\n             * (Which is not the case if the drag had been initiated by createDragSource)\n             */\n        }\n        else if (this._originalParent) {\n            droppedComponentItem = this._componentItem;\n            this._originalParent.addChild(droppedComponentItem);\n            /**\n             * The drag didn't ultimately end up with adding the content item to\n             * any container. In order to ensure clean up happens, destroy the\n             * content item.\n             */\n        }\n        else {\n            this._componentItem.destroy(); // contentItem children are now destroyed as well\n        }\n        this._element.remove();\n        this._layoutManager.emit('itemDropped', this._componentItem);\n        if (this._componentItemFocused && droppedComponentItem !== undefined) {\n            droppedComponentItem.focus();\n        }\n    }\n    /**\n     * Updates the Drag Proxy's dimensions\n     * @internal\n     */\n    setDimensions() {\n        const dimensions = this._layoutManager.layoutConfig.dimensions;\n        if (dimensions === undefined) {\n            throw new Error('DragProxy.setDimensions: dimensions undefined');\n        }\n        let width = dimensions.dragProxyWidth;\n        let height = dimensions.dragProxyHeight;\n        if (width === undefined || height === undefined) {\n            throw new Error('DragProxy.setDimensions: width and/or height undefined');\n        }\n        const headerHeight = this._layoutManager.layoutConfig.header.show === false ? 0 : dimensions.headerHeight;\n        this._element.style.width = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.numberToPixels)(width);\n        this._element.style.height = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.numberToPixels)(height);\n        width -= (this._sided ? headerHeight : 0);\n        height -= (!this._sided ? headerHeight : 0);\n        this._proxyContainerElement.style.width = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.numberToPixels)(width);\n        this._proxyContainerElement.style.height = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.numberToPixels)(height);\n        this._componentItem.enterDragMode(width, height);\n        this._componentItem.show();\n    }\n}\n//# sourceMappingURL=drag-proxy.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/controls/drag-proxy.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/controls/drag-source.js":
/*!************************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/controls/drag-source.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DragSource: () => (/* binding */ DragSource)\n/* harmony export */ });\n/* harmony import */ var _config_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config/config */ \"./node_modules/golden-layout/dist/esm/ts/config/config.js\");\n/* harmony import */ var _config_resolved_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/resolved-config */ \"./node_modules/golden-layout/dist/esm/ts/config/resolved-config.js\");\n/* harmony import */ var _errors_internal_error__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../errors/internal-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js\");\n/* harmony import */ var _items_component_item__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../items/component-item */ \"./node_modules/golden-layout/dist/esm/ts/items/component-item.js\");\n/* harmony import */ var _items_ground_item__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../items/ground-item */ \"./node_modules/golden-layout/dist/esm/ts/items/ground-item.js\");\n/* harmony import */ var _utils_drag_listener__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/drag-listener */ \"./node_modules/golden-layout/dist/esm/ts/utils/drag-listener.js\");\n/* harmony import */ var _drag_proxy__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./drag-proxy */ \"./node_modules/golden-layout/dist/esm/ts/controls/drag-proxy.js\");\n // remove alias in version 3\n\n\n\n\n\n\n/**\n * Allows for any DOM item to create a component on drag\n * start to be dragged into the Layout\n * @public\n */\nclass DragSource {\n    /** @internal */\n    constructor(\n    /** @internal */\n    _layoutManager, \n    /** @internal */\n    _element, \n    /** @internal */\n    _extraAllowableChildTargets, \n    /** @internal @deprecated replace with componentItemConfigOrFtn in version 3 */\n    _componentTypeOrFtn, \n    /** @internal @deprecated remove in version 3 */\n    _componentState, \n    /** @internal @deprecated remove in version 3 */\n    _title, \n    /** @internal @deprecated remove in version 3 */\n    _id) {\n        this._layoutManager = _layoutManager;\n        this._element = _element;\n        this._extraAllowableChildTargets = _extraAllowableChildTargets;\n        this._componentTypeOrFtn = _componentTypeOrFtn;\n        this._componentState = _componentState;\n        this._title = _title;\n        this._id = _id;\n        this._dragListener = null;\n        this._dummyGroundContainer = document.createElement('div');\n        const dummyRootItemConfig = _config_resolved_config__WEBPACK_IMPORTED_MODULE_0__.ResolvedRowOrColumnItemConfig.createDefault('row');\n        this._dummyGroundContentItem = new _items_ground_item__WEBPACK_IMPORTED_MODULE_1__.GroundItem(this._layoutManager, dummyRootItemConfig, this._dummyGroundContainer);\n        this.createDragListener();\n    }\n    /**\n     * Disposes of the drag listeners so the drag source is not usable any more.\n     * @internal\n     */\n    destroy() {\n        this.removeDragListener();\n    }\n    /**\n     * Called initially and after every drag\n     * @internal\n     */\n    createDragListener() {\n        this.removeDragListener();\n        this._dragListener = new _utils_drag_listener__WEBPACK_IMPORTED_MODULE_2__.DragListener(this._element, this._extraAllowableChildTargets);\n        this._dragListener.on('dragStart', (x, y) => this.onDragStart(x, y));\n        this._dragListener.on('dragStop', () => this.onDragStop());\n    }\n    /**\n     * Callback for the DragListener's dragStart event\n     *\n     * @param x - The x position of the mouse on dragStart\n     * @param y - The x position of the mouse on dragStart\n     * @internal\n     */\n    onDragStart(x, y) {\n        var _a;\n        const type = 'component';\n        let dragSourceItemConfig;\n        if (typeof this._componentTypeOrFtn === \"function\") {\n            const ftnDragSourceItemConfig = this._componentTypeOrFtn();\n            // If the componentType property exists, then it is already a ComponentItemConfig so nothing to do\n            if (DragSource.isDragSourceComponentItemConfig(ftnDragSourceItemConfig)) {\n                dragSourceItemConfig = {\n                    type,\n                    componentState: ftnDragSourceItemConfig.state,\n                    componentType: ftnDragSourceItemConfig.type,\n                    title: (_a = ftnDragSourceItemConfig.title) !== null && _a !== void 0 ? _a : this._title,\n                };\n            }\n            else {\n                dragSourceItemConfig = ftnDragSourceItemConfig;\n            }\n        }\n        else {\n            dragSourceItemConfig = {\n                type,\n                componentState: this._componentState,\n                componentType: this._componentTypeOrFtn,\n                title: this._title,\n                id: this._id,\n            };\n        }\n        // Create a dummy ContentItem only for drag purposes\n        // All ContentItems (except for GroundItem) need a parent.  When dragging, the parent is not used.\n        // Instead of allowing null parents (as Javascript version did), use a temporary dummy GroundItem parent and add ContentItem to that\n        // If this does not work, need to create alternative GroundItem class\n        const resolvedItemConfig = _config_config__WEBPACK_IMPORTED_MODULE_3__.ComponentItemConfig.resolve(dragSourceItemConfig, false);\n        const componentItem = new _items_component_item__WEBPACK_IMPORTED_MODULE_4__.ComponentItem(this._layoutManager, resolvedItemConfig, this._dummyGroundContentItem);\n        this._dummyGroundContentItem.contentItems.push(componentItem);\n        if (this._dragListener === null) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_5__.UnexpectedNullError('DSODSD66746');\n        }\n        else {\n            const dragProxy = new _drag_proxy__WEBPACK_IMPORTED_MODULE_6__.DragProxy(x, y, this._dragListener, this._layoutManager, componentItem, this._dummyGroundContentItem);\n            const transitionIndicator = this._layoutManager.transitionIndicator;\n            if (transitionIndicator === null) {\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_5__.UnexpectedNullError('DSODST66746');\n            }\n            else {\n                transitionIndicator.transitionElements(this._element, dragProxy.element);\n            }\n        }\n    }\n    /** @internal */\n    onDragStop() {\n        // if (this._dummyGroundContentItem === undefined) {\n        //     throw new UnexpectedUndefinedError('DSODSDRU08116');\n        // } else {\n        //     this._dummyGroundContentItem._$destroy\n        //     this._dummyGroundContentItem = undefined;\n        // }\n        this.createDragListener();\n    }\n    /**\n     * Called after every drag and when the drag source is being disposed of.\n     * @internal\n     */\n    removeDragListener() {\n        if (this._dragListener !== null) {\n            this._dragListener.destroy();\n            this._dragListener = null;\n        }\n    }\n}\n/** @public */\n(function (DragSource) {\n    /** @deprecated remove in version 3 */\n    function isDragSourceComponentItemConfig(config) {\n        return !(\"componentType\" in config);\n    }\n    DragSource.isDragSourceComponentItemConfig = isDragSourceComponentItemConfig;\n})(DragSource || (DragSource = {}));\n//# sourceMappingURL=drag-source.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/controls/drag-source.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/controls/drop-target-indicator.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/controls/drop-target-indicator.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DropTargetIndicator: () => (/* binding */ DropTargetIndicator)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/golden-layout/dist/esm/ts/utils/utils.js\");\n\n/** @internal */\nclass DropTargetIndicator {\n    constructor() {\n        // Maybe use container instead of Document Body?\n        this._element = document.createElement('div');\n        this._element.classList.add(\"lm_dropTargetIndicator\" /* DropTargetIndicator */);\n        const innerElement = document.createElement('div');\n        innerElement.classList.add(\"lm_inner\" /* Inner */);\n        this._element.appendChild(innerElement);\n        document.body.appendChild(this._element);\n    }\n    destroy() {\n        this._element.remove();\n    }\n    highlightArea(area, margin) {\n        this._element.style.left = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.numberToPixels)(area.x1 + margin);\n        this._element.style.top = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.numberToPixels)(area.y1 + margin);\n        this._element.style.width = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.numberToPixels)(area.x2 - area.x1 - margin);\n        this._element.style.height = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.numberToPixels)(area.y2 - area.y1 - margin);\n        this._element.style.display = 'block';\n    }\n    hide() {\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.setElementDisplayVisibility)(this._element, false);\n    }\n}\n//# sourceMappingURL=drop-target-indicator.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/controls/drop-target-indicator.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/controls/header-button.js":
/*!**************************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/controls/header-button.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HeaderButton: () => (/* binding */ HeaderButton)\n/* harmony export */ });\n/** @internal */\nclass HeaderButton {\n    constructor(_header, label, cssClass, _pushEvent) {\n        this._header = _header;\n        this._pushEvent = _pushEvent;\n        this._clickEventListener = (ev) => this.onClick(ev);\n        this._touchStartEventListener = (ev) => this.onTouchStart(ev);\n        this._element = document.createElement('div');\n        this._element.classList.add(cssClass);\n        this._element.title = label;\n        this._header.on('destroy', () => this.destroy());\n        this._element.addEventListener('click', this._clickEventListener, { passive: true });\n        this._element.addEventListener('touchstart', this._touchStartEventListener, { passive: true });\n        this._header.controlsContainerElement.appendChild(this._element);\n    }\n    get element() { return this._element; }\n    destroy() {\n        var _a;\n        this._element.removeEventListener('click', this._clickEventListener);\n        this._element.removeEventListener('touchstart', this._touchStartEventListener);\n        (_a = this._element.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this._element);\n    }\n    onClick(ev) {\n        this._pushEvent(ev);\n    }\n    onTouchStart(ev) {\n        this._pushEvent(ev);\n    }\n}\n//# sourceMappingURL=header-button.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/controls/header-button.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/controls/header.js":
/*!*******************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/controls/header.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Header: () => (/* binding */ Header)\n/* harmony export */ });\n/* harmony import */ var _errors_internal_error__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../errors/internal-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js\");\n/* harmony import */ var _utils_event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/event-emitter */ \"./node_modules/golden-layout/dist/esm/ts/utils/event-emitter.js\");\n/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/types */ \"./node_modules/golden-layout/dist/esm/ts/utils/types.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/golden-layout/dist/esm/ts/utils/utils.js\");\n/* harmony import */ var _header_button__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./header-button */ \"./node_modules/golden-layout/dist/esm/ts/controls/header-button.js\");\n/* harmony import */ var _tabs_container__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tabs-container */ \"./node_modules/golden-layout/dist/esm/ts/controls/tabs-container.js\");\n\n\n\n\n\n\n/**\n * This class represents a header above a Stack ContentItem.\n * @public\n */\nclass Header extends _utils_event_emitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    /** @internal */\n    constructor(\n    /** @internal */\n    _layoutManager, \n    /** @internal */\n    _parent, settings, \n    /** @internal */\n    _configClosable, \n    /** @internal */\n    _getActiveComponentItemEvent, closeEvent, \n    /** @internal */\n    _popoutEvent, \n    /** @internal */\n    _maximiseToggleEvent, \n    /** @internal */\n    _clickEvent, \n    /** @internal */\n    _touchStartEvent, \n    /** @internal */\n    _componentRemoveEvent, \n    /** @internal */\n    _componentFocusEvent, \n    /** @internal */\n    _componentDragStartEvent) {\n        super();\n        this._layoutManager = _layoutManager;\n        this._parent = _parent;\n        this._configClosable = _configClosable;\n        this._getActiveComponentItemEvent = _getActiveComponentItemEvent;\n        this._popoutEvent = _popoutEvent;\n        this._maximiseToggleEvent = _maximiseToggleEvent;\n        this._clickEvent = _clickEvent;\n        this._touchStartEvent = _touchStartEvent;\n        this._componentRemoveEvent = _componentRemoveEvent;\n        this._componentFocusEvent = _componentFocusEvent;\n        this._componentDragStartEvent = _componentDragStartEvent;\n        /** @internal */\n        this._clickListener = (ev) => this.onClick(ev);\n        /** @internal */\n        this._touchStartListener = (ev) => this.onTouchStart(ev);\n        /** @internal */\n        this._rowColumnClosable = true;\n        /** @internal */\n        this._closeButton = null;\n        /** @internal */\n        this._popoutButton = null;\n        this._tabsContainer = new _tabs_container__WEBPACK_IMPORTED_MODULE_1__.TabsContainer(this._layoutManager, (item) => this.handleTabInitiatedComponentRemoveEvent(item), (item) => this.handleTabInitiatedComponentFocusEvent(item), (x, y, dragListener, item) => this.handleTabInitiatedDragStartEvent(x, y, dragListener, item), () => this.processTabDropdownActiveChanged());\n        this._show = settings.show;\n        this._popoutEnabled = settings.popoutEnabled;\n        this._popoutLabel = settings.popoutLabel;\n        this._maximiseEnabled = settings.maximiseEnabled;\n        this._maximiseLabel = settings.maximiseLabel;\n        this._minimiseEnabled = settings.minimiseEnabled;\n        this._minimiseLabel = settings.minimiseLabel;\n        this._closeEnabled = settings.closeEnabled;\n        this._closeLabel = settings.closeLabel;\n        this._tabDropdownEnabled = settings.tabDropdownEnabled;\n        this._tabDropdownLabel = settings.tabDropdownLabel;\n        this.setSide(settings.side);\n        this._canRemoveComponent = this._configClosable;\n        this._element = document.createElement('section');\n        this._element.classList.add(\"lm_header\" /* Header */);\n        this._controlsContainerElement = document.createElement('section');\n        this._controlsContainerElement.classList.add(\"lm_controls\" /* Controls */);\n        this._element.appendChild(this._tabsContainer.element);\n        this._element.appendChild(this._controlsContainerElement);\n        this._element.appendChild(this._tabsContainer.dropdownElement);\n        this._element.addEventListener('click', this._clickListener, { passive: true });\n        this._element.addEventListener('touchstart', this._touchStartListener, { passive: true });\n        this._documentMouseUpListener = () => this._tabsContainer.hideAdditionalTabsDropdown();\n        globalThis.document.addEventListener('mouseup', this._documentMouseUpListener, { passive: true });\n        this._tabControlOffset = this._layoutManager.layoutConfig.settings.tabControlOffset;\n        if (this._tabDropdownEnabled) {\n            this._tabDropdownButton = new _header_button__WEBPACK_IMPORTED_MODULE_2__.HeaderButton(this, this._tabDropdownLabel, \"lm_tabdropdown\" /* TabDropdown */, () => this._tabsContainer.showAdditionalTabsDropdown());\n        }\n        if (this._popoutEnabled) {\n            this._popoutButton = new _header_button__WEBPACK_IMPORTED_MODULE_2__.HeaderButton(this, this._popoutLabel, \"lm_popout\" /* Popout */, () => this.handleButtonPopoutEvent());\n        }\n        /**\n         * Maximise control - set the component to the full size of the layout\n         */\n        if (this._maximiseEnabled) {\n            this._maximiseButton = new _header_button__WEBPACK_IMPORTED_MODULE_2__.HeaderButton(this, this._maximiseLabel, \"lm_maximise\" /* Maximise */, (ev) => this.handleButtonMaximiseToggleEvent(ev));\n        }\n        /**\n         * Close button\n         */\n        if (this._configClosable) {\n            this._closeButton = new _header_button__WEBPACK_IMPORTED_MODULE_2__.HeaderButton(this, this._closeLabel, \"lm_close\" /* Close */, () => closeEvent());\n        }\n        this.processTabDropdownActiveChanged();\n    }\n    // /** @internal */\n    // private _activeComponentItem: ComponentItem | null = null; // only used to identify active tab\n    get show() { return this._show; }\n    get side() { return this._side; }\n    get leftRightSided() { return this._leftRightSided; }\n    get layoutManager() { return this._layoutManager; }\n    get parent() { return this._parent; }\n    get tabs() { return this._tabsContainer.tabs; }\n    get lastVisibleTabIndex() { return this._tabsContainer.lastVisibleTabIndex; }\n    get element() { return this._element; }\n    get tabsContainerElement() { return this._tabsContainer.element; }\n    get controlsContainerElement() { return this._controlsContainerElement; }\n    /**\n     * Destroys the entire header\n     * @internal\n     */\n    destroy() {\n        this.emit('destroy');\n        this._popoutEvent = undefined;\n        this._maximiseToggleEvent = undefined;\n        this._clickEvent = undefined;\n        this._touchStartEvent = undefined;\n        this._componentRemoveEvent = undefined;\n        this._componentFocusEvent = undefined;\n        this._componentDragStartEvent = undefined;\n        this._tabsContainer.destroy();\n        globalThis.document.removeEventListener('mouseup', this._documentMouseUpListener);\n        this._element.remove();\n    }\n    /**\n     * Creates a new tab and associates it with a contentItem\n     * @param index - The position of the tab\n     * @internal\n     */\n    createTab(componentItem, index) {\n        this._tabsContainer.createTab(componentItem, index);\n    }\n    /**\n     * Finds a tab based on the contentItem its associated with and removes it.\n     * Cannot remove tab if it has the active ComponentItem\n     * @internal\n     */\n    removeTab(componentItem) {\n        this._tabsContainer.removeTab(componentItem);\n    }\n    /** @internal */\n    processActiveComponentChanged(newActiveComponentItem) {\n        this._tabsContainer.processActiveComponentChanged(newActiveComponentItem);\n        this.updateTabSizes();\n    }\n    /** @internal */\n    setSide(value) {\n        this._side = value;\n        this._leftRightSided = [_utils_types__WEBPACK_IMPORTED_MODULE_3__.Side.right, _utils_types__WEBPACK_IMPORTED_MODULE_3__.Side.left].includes(this._side);\n    }\n    /**\n     * Programmatically set closability.\n     * @param value - Whether to enable/disable closability.\n     * @returns Whether the action was successful\n     * @internal\n     */\n    setRowColumnClosable(value) {\n        this._rowColumnClosable = value;\n        this.updateClosability();\n    }\n    /**\n     * Updates the header's closability. If a stack/header is able\n     * to close, but has a non closable component added to it, the stack is no\n     * longer closable until all components are closable.\n     * @internal\n     */\n    updateClosability() {\n        let isClosable;\n        if (!this._configClosable) {\n            isClosable = false;\n        }\n        else {\n            if (!this._rowColumnClosable) {\n                isClosable = false;\n            }\n            else {\n                isClosable = true;\n                const len = this.tabs.length;\n                for (let i = 0; i < len; i++) {\n                    const tab = this._tabsContainer.tabs[i];\n                    const item = tab.componentItem;\n                    if (!item.isClosable) {\n                        isClosable = false;\n                        break;\n                    }\n                }\n            }\n        }\n        if (this._closeButton !== null) {\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.setElementDisplayVisibility)(this._closeButton.element, isClosable);\n        }\n        if (this._popoutButton !== null) {\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.setElementDisplayVisibility)(this._popoutButton.element, isClosable);\n        }\n        this._canRemoveComponent = isClosable || this._tabsContainer.tabCount > 1;\n    }\n    /** @internal */\n    applyFocusedValue(value) {\n        if (value) {\n            this._element.classList.add(\"lm_focused\" /* Focused */);\n        }\n        else {\n            this._element.classList.remove(\"lm_focused\" /* Focused */);\n        }\n    }\n    /** @internal */\n    processMaximised() {\n        if (this._maximiseButton === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_5__.UnexpectedUndefinedError('HPMAX16997');\n        }\n        else {\n            this._maximiseButton.element.setAttribute('title', this._minimiseLabel);\n        }\n    }\n    /** @internal */\n    processMinimised() {\n        if (this._maximiseButton === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_5__.UnexpectedUndefinedError('HPMIN16997');\n        }\n        else {\n            this._maximiseButton.element.setAttribute('title', this._maximiseLabel);\n        }\n    }\n    /**\n     * Pushes the tabs to the tab dropdown if the available space is not sufficient\n     * @internal\n     */\n    updateTabSizes() {\n        if (this._tabsContainer.tabCount > 0) {\n            const headerHeight = this._show ? this._layoutManager.layoutConfig.dimensions.headerHeight : 0;\n            if (this._leftRightSided) {\n                this._element.style.height = '';\n                this._element.style.width = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.numberToPixels)(headerHeight);\n            }\n            else {\n                this._element.style.width = '';\n                this._element.style.height = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.numberToPixels)(headerHeight);\n            }\n            let availableWidth;\n            if (this._leftRightSided) {\n                availableWidth = this._element.offsetHeight - this._controlsContainerElement.offsetHeight - this._tabControlOffset;\n            }\n            else {\n                availableWidth = this._element.offsetWidth - this._controlsContainerElement.offsetWidth - this._tabControlOffset;\n            }\n            this._tabsContainer.updateTabSizes(availableWidth, this._getActiveComponentItemEvent());\n        }\n    }\n    /** @internal */\n    handleTabInitiatedComponentRemoveEvent(componentItem) {\n        if (this._canRemoveComponent) {\n            if (this._componentRemoveEvent === undefined) {\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_5__.UnexpectedUndefinedError('HHTCE22294');\n            }\n            else {\n                this._componentRemoveEvent(componentItem);\n            }\n        }\n    }\n    /** @internal */\n    handleTabInitiatedComponentFocusEvent(componentItem) {\n        if (this._componentFocusEvent === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_5__.UnexpectedUndefinedError('HHTAE22294');\n        }\n        else {\n            this._componentFocusEvent(componentItem);\n        }\n    }\n    /** @internal */\n    handleTabInitiatedDragStartEvent(x, y, dragListener, componentItem) {\n        if (!this._canRemoveComponent) {\n            dragListener.cancelDrag();\n        }\n        else {\n            if (this._componentDragStartEvent === undefined) {\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_5__.UnexpectedUndefinedError('HHTDSE22294');\n            }\n            else {\n                this._componentDragStartEvent(x, y, dragListener, componentItem);\n            }\n        }\n    }\n    /** @internal */\n    processTabDropdownActiveChanged() {\n        if (this._tabDropdownButton !== undefined) {\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.setElementDisplayVisibility)(this._tabDropdownButton.element, this._tabsContainer.dropdownActive);\n        }\n    }\n    /** @internal */\n    handleButtonPopoutEvent() {\n        if (this._layoutManager.layoutConfig.settings.popoutWholeStack) {\n            if (this._popoutEvent === undefined) {\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_5__.UnexpectedUndefinedError('HHBPOE17834');\n            }\n            else {\n                this._popoutEvent();\n            }\n        }\n        else {\n            const activeComponentItem = this._getActiveComponentItemEvent();\n            if (activeComponentItem) {\n                activeComponentItem.popout();\n            }\n            // else: if the stack is empty there won't be an active item (and nothing to popout)\n        }\n    }\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    handleButtonMaximiseToggleEvent(ev) {\n        if (this._maximiseToggleEvent === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_5__.UnexpectedUndefinedError('HHBMTE16834');\n        }\n        else {\n            this._maximiseToggleEvent();\n        }\n    }\n    /**\n     * Invoked when the header's background is clicked (not it's tabs or controls)\n     * @internal\n     */\n    onClick(event) {\n        if (event.target === this._element) {\n            this.notifyClick(event);\n        }\n    }\n    /**\n     * Invoked when the header's background is touched (not it's tabs or controls)\n     * @internal\n     */\n    onTouchStart(event) {\n        if (event.target === this._element) {\n            this.notifyTouchStart(event);\n        }\n    }\n    /** @internal */\n    notifyClick(ev) {\n        if (this._clickEvent === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_5__.UnexpectedUndefinedError('HNHC46834');\n        }\n        else {\n            this._clickEvent(ev);\n        }\n    }\n    /** @internal */\n    notifyTouchStart(ev) {\n        if (this._touchStartEvent === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_5__.UnexpectedUndefinedError('HNHTS46834');\n        }\n        else {\n            this._touchStartEvent(ev);\n        }\n    }\n}\n//# sourceMappingURL=header.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/controls/header.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/controls/splitter.js":
/*!*********************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/controls/splitter.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Splitter: () => (/* binding */ Splitter)\n/* harmony export */ });\n/* harmony import */ var _utils_drag_listener__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/drag-listener */ \"./node_modules/golden-layout/dist/esm/ts/utils/drag-listener.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/golden-layout/dist/esm/ts/utils/utils.js\");\n\n\n/** @internal */\nclass Splitter {\n    constructor(_isVertical, _size, grabSize) {\n        this._isVertical = _isVertical;\n        this._size = _size;\n        this._grabSize = grabSize < this._size ? this._size : grabSize;\n        this._element = document.createElement('div');\n        this._element.classList.add(\"lm_splitter\" /* Splitter */);\n        const dragHandleElement = document.createElement('div');\n        dragHandleElement.classList.add(\"lm_drag_handle\" /* DragHandle */);\n        const handleExcessSize = this._grabSize - this._size;\n        const handleExcessPos = handleExcessSize / 2;\n        if (this._isVertical) {\n            dragHandleElement.style.top = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.numberToPixels)(-handleExcessPos);\n            dragHandleElement.style.height = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.numberToPixels)(this._size + handleExcessSize);\n            this._element.classList.add(\"lm_vertical\" /* Vertical */);\n            this._element.style.height = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.numberToPixels)(this._size);\n        }\n        else {\n            dragHandleElement.style.left = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.numberToPixels)(-handleExcessPos);\n            dragHandleElement.style.width = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.numberToPixels)(this._size + handleExcessSize);\n            this._element.classList.add(\"lm_horizontal\" /* Horizontal */);\n            this._element.style.width = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.numberToPixels)(this._size);\n        }\n        this._element.appendChild(dragHandleElement);\n        this._dragListener = new _utils_drag_listener__WEBPACK_IMPORTED_MODULE_1__.DragListener(this._element, [dragHandleElement]);\n    }\n    get element() { return this._element; }\n    destroy() {\n        this._element.remove();\n    }\n    on(eventName, callback) {\n        this._dragListener.on(eventName, callback);\n    }\n}\n//# sourceMappingURL=splitter.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/controls/splitter.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/controls/tab.js":
/*!****************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/controls/tab.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tab: () => (/* binding */ Tab)\n/* harmony export */ });\n/* harmony import */ var _errors_internal_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors/internal-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js\");\n/* harmony import */ var _utils_drag_listener__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/drag-listener */ \"./node_modules/golden-layout/dist/esm/ts/utils/drag-listener.js\");\n\n\n/**\n * Represents an individual tab within a Stack's header\n * @public\n */\nclass Tab {\n    /** @internal */\n    constructor(\n    /** @internal */\n    _layoutManager, \n    /** @internal */\n    _componentItem, \n    /** @internal */\n    _closeEvent, \n    /** @internal */\n    _focusEvent, \n    /** @internal */\n    _dragStartEvent) {\n        var _a;\n        this._layoutManager = _layoutManager;\n        this._componentItem = _componentItem;\n        this._closeEvent = _closeEvent;\n        this._focusEvent = _focusEvent;\n        this._dragStartEvent = _dragStartEvent;\n        /** @internal */\n        this._isActive = false;\n        /** @internal */\n        this._tabClickListener = (ev) => this.onTabClickDown(ev);\n        /** @internal */\n        this._tabTouchStartListener = (ev) => this.onTabTouchStart(ev);\n        /** @internal */\n        this._closeClickListener = () => this.onCloseClick();\n        /** @internal */\n        this._closeTouchStartListener = () => this.onCloseTouchStart();\n        // /** @internal */\n        // private readonly _closeMouseDownListener = () => this.onCloseMousedown();\n        /** @internal */\n        this._dragStartListener = (x, y) => this.onDragStart(x, y);\n        /** @internal */\n        this._contentItemDestroyListener = () => this.onContentItemDestroy();\n        /** @internal */\n        this._tabTitleChangedListener = (title) => this.setTitle(title);\n        this._element = document.createElement('div');\n        this._element.classList.add(\"lm_tab\" /* Tab */);\n        this._titleElement = document.createElement('span');\n        this._titleElement.classList.add(\"lm_title\" /* Title */);\n        this._closeElement = document.createElement('div');\n        this._closeElement.classList.add(\"lm_close_tab\" /* CloseTab */);\n        this._element.appendChild(this._titleElement);\n        this._element.appendChild(this._closeElement);\n        if (_componentItem.isClosable) {\n            this._closeElement.style.display = '';\n        }\n        else {\n            this._closeElement.style.display = 'none';\n        }\n        this.setTitle(_componentItem.title);\n        this._componentItem.on('titleChanged', this._tabTitleChangedListener);\n        const reorderEnabled = (_a = _componentItem.reorderEnabled) !== null && _a !== void 0 ? _a : this._layoutManager.layoutConfig.settings.reorderEnabled;\n        if (reorderEnabled) {\n            this.enableReorder();\n        }\n        this._element.addEventListener('click', this._tabClickListener, { passive: true });\n        this._element.addEventListener('touchstart', this._tabTouchStartListener, { passive: true });\n        if (this._componentItem.isClosable) {\n            this._closeElement.addEventListener('click', this._closeClickListener, { passive: true });\n            this._closeElement.addEventListener('touchstart', this._closeTouchStartListener, { passive: true });\n            // this._closeElement.addEventListener('mousedown', this._closeMouseDownListener, { passive: true });\n        }\n        else {\n            this._closeElement.remove();\n            this._closeElement = undefined;\n        }\n        this._componentItem.setTab(this);\n        this._layoutManager.emit('tabCreated', this);\n    }\n    get isActive() { return this._isActive; }\n    // get header(): Header { return this._header; }\n    get componentItem() { return this._componentItem; }\n    /** @deprecated use {@link (Tab:class).componentItem} */\n    get contentItem() { return this._componentItem; }\n    get element() { return this._element; }\n    get titleElement() { return this._titleElement; }\n    get closeElement() { return this._closeElement; }\n    get reorderEnabled() { return this._dragListener !== undefined; }\n    set reorderEnabled(value) {\n        if (value !== this.reorderEnabled) {\n            if (value) {\n                this.enableReorder();\n            }\n            else {\n                this.disableReorder();\n            }\n        }\n    }\n    /**\n     * Sets the tab's title to the provided string and sets\n     * its title attribute to a pure text representation (without\n     * html tags) of the same string.\n     */\n    setTitle(title) {\n        this._titleElement.innerText = title;\n        this._element.title = title;\n    }\n    /**\n     * Sets this tab's active state. To programmatically\n     * switch tabs, use Stack.setActiveComponentItem( item ) instead.\n     */\n    setActive(isActive) {\n        if (isActive === this._isActive) {\n            return;\n        }\n        this._isActive = isActive;\n        if (isActive) {\n            this._element.classList.add(\"lm_active\" /* Active */);\n        }\n        else {\n            this._element.classList.remove(\"lm_active\" /* Active */);\n        }\n    }\n    /**\n     * Destroys the tab\n     * @internal\n     */\n    destroy() {\n        var _a, _b;\n        this._closeEvent = undefined;\n        this._focusEvent = undefined;\n        this._dragStartEvent = undefined;\n        this._element.removeEventListener('click', this._tabClickListener);\n        this._element.removeEventListener('touchstart', this._tabTouchStartListener);\n        (_a = this._closeElement) === null || _a === void 0 ? void 0 : _a.removeEventListener('click', this._closeClickListener);\n        (_b = this._closeElement) === null || _b === void 0 ? void 0 : _b.removeEventListener('touchstart', this._closeTouchStartListener);\n        // this._closeElement?.removeEventListener('mousedown', this._closeMouseDownListener);\n        this._componentItem.off('titleChanged', this._tabTitleChangedListener);\n        if (this.reorderEnabled) {\n            this.disableReorder();\n        }\n        this._element.remove();\n    }\n    /** @internal */\n    setBlurred() {\n        this._element.classList.remove(\"lm_focused\" /* Focused */);\n        this._titleElement.classList.remove(\"lm_focused\" /* Focused */);\n    }\n    /** @internal */\n    setFocused() {\n        this._element.classList.add(\"lm_focused\" /* Focused */);\n        this._titleElement.classList.add(\"lm_focused\" /* Focused */);\n    }\n    /**\n     * Callback for the DragListener\n     * @param x - The tabs absolute x position\n     * @param y - The tabs absolute y position\n     * @internal\n     */\n    onDragStart(x, y) {\n        if (this._dragListener === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_0__.UnexpectedUndefinedError('TODSDLU10093');\n        }\n        else {\n            if (this._dragStartEvent === undefined) {\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_0__.UnexpectedUndefinedError('TODS23309');\n            }\n            else {\n                this._dragStartEvent(x, y, this._dragListener, this.componentItem);\n            }\n        }\n    }\n    /** @internal */\n    onContentItemDestroy() {\n        if (this._dragListener !== undefined) {\n            this._dragListener.destroy();\n            this._dragListener = undefined;\n        }\n    }\n    /**\n     * Callback when the tab is clicked\n     * @internal\n     */\n    onTabClickDown(event) {\n        const target = event.target;\n        if (target === this._element || target === this._titleElement) {\n            // left mouse button\n            if (event.button === 0) {\n                // event.stopPropagation();\n                this.notifyFocus();\n                // middle mouse button\n            }\n            else if (event.button === 1 && this._componentItem.isClosable) {\n                // event.stopPropagation();\n                this.notifyClose();\n            }\n        }\n    }\n    /** @internal */\n    onTabTouchStart(event) {\n        if (event.target === this._element) {\n            this.notifyFocus();\n        }\n    }\n    /**\n     * Callback when the tab's close button is clicked\n     * @internal\n     */\n    onCloseClick() {\n        this.notifyClose();\n    }\n    /** @internal */\n    onCloseTouchStart() {\n        this.notifyClose();\n    }\n    /**\n     * Callback to capture tab close button mousedown\n     * to prevent tab from activating.\n     * @internal\n     */\n    // private onCloseMousedown(): void {\n    //     // event.stopPropagation();\n    // }\n    /** @internal */\n    notifyClose() {\n        if (this._closeEvent === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_0__.UnexpectedUndefinedError('TNC15007');\n        }\n        else {\n            this._closeEvent(this._componentItem);\n        }\n    }\n    /** @internal */\n    notifyFocus() {\n        if (this._focusEvent === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_0__.UnexpectedUndefinedError('TNA15007');\n        }\n        else {\n            this._focusEvent(this._componentItem);\n        }\n    }\n    /** @internal */\n    enableReorder() {\n        this._dragListener = new _utils_drag_listener__WEBPACK_IMPORTED_MODULE_1__.DragListener(this._element, [this._titleElement]);\n        this._dragListener.on('dragStart', this._dragStartListener);\n        this._componentItem.on('destroy', this._contentItemDestroyListener);\n    }\n    /** @internal */\n    disableReorder() {\n        if (this._dragListener === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_0__.UnexpectedUndefinedError('TDR87745');\n        }\n        else {\n            this._componentItem.off('destroy', this._contentItemDestroyListener);\n            this._dragListener.off('dragStart', this._dragStartListener);\n            this._dragListener = undefined;\n        }\n    }\n}\n//# sourceMappingURL=tab.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/controls/tab.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/controls/tabs-container.js":
/*!***************************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/controls/tabs-container.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TabsContainer: () => (/* binding */ TabsContainer)\n/* harmony export */ });\n/* harmony import */ var _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/internal-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/golden-layout/dist/esm/ts/utils/utils.js\");\n/* harmony import */ var _tab__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tab */ \"./node_modules/golden-layout/dist/esm/ts/controls/tab.js\");\n\n\n\n/** @internal */\nclass TabsContainer {\n    constructor(_layoutManager, _componentRemoveEvent, _componentFocusEvent, _componentDragStartEvent, _dropdownActiveChangedEvent) {\n        this._layoutManager = _layoutManager;\n        this._componentRemoveEvent = _componentRemoveEvent;\n        this._componentFocusEvent = _componentFocusEvent;\n        this._componentDragStartEvent = _componentDragStartEvent;\n        this._dropdownActiveChangedEvent = _dropdownActiveChangedEvent;\n        // There is one tab per ComponentItem in stack.  However they may not be ordered the same\n        this._tabs = [];\n        this._lastVisibleTabIndex = -1;\n        this._dropdownActive = false;\n        this._element = document.createElement('section');\n        this._element.classList.add(\"lm_tabs\" /* Tabs */);\n        this._dropdownElement = document.createElement('section');\n        this._dropdownElement.classList.add(\"lm_tabdropdown_list\" /* TabDropdownList */);\n        this._dropdownElement.style.display = 'none';\n    }\n    get tabs() { return this._tabs; }\n    get tabCount() { return this._tabs.length; }\n    get lastVisibleTabIndex() { return this._lastVisibleTabIndex; }\n    get element() { return this._element; }\n    get dropdownElement() { return this._dropdownElement; }\n    get dropdownActive() { return this._dropdownActive; }\n    destroy() {\n        for (let i = 0; i < this._tabs.length; i++) {\n            this._tabs[i].destroy();\n        }\n    }\n    /**\n     * Creates a new tab and associates it with a contentItem\n     * @param index - The position of the tab\n     */\n    createTab(componentItem, index) {\n        //If there's already a tab relating to the\n        //content item, don't do anything\n        for (let i = 0; i < this._tabs.length; i++) {\n            if (this._tabs[i].componentItem === componentItem) {\n                return;\n            }\n        }\n        const tab = new _tab__WEBPACK_IMPORTED_MODULE_0__.Tab(this._layoutManager, componentItem, (item) => this.handleTabCloseEvent(item), (item) => this.handleTabFocusEvent(item), (x, y, dragListener, item) => this.handleTabDragStartEvent(x, y, dragListener, item));\n        if (index === undefined) {\n            index = this._tabs.length;\n        }\n        this._tabs.splice(index, 0, tab);\n        if (index < this._element.childNodes.length) {\n            this._element.insertBefore(tab.element, this._element.childNodes[index]);\n        }\n        else {\n            this._element.appendChild(tab.element);\n        }\n    }\n    removeTab(componentItem) {\n        // componentItem cannot be ActiveComponentItem\n        for (let i = 0; i < this._tabs.length; i++) {\n            if (this._tabs[i].componentItem === componentItem) {\n                const tab = this._tabs[i];\n                tab.destroy();\n                this._tabs.splice(i, 1);\n                return;\n            }\n        }\n        throw new Error('contentItem is not controlled by this header');\n    }\n    processActiveComponentChanged(newActiveComponentItem) {\n        let activeIndex = -1;\n        for (let i = 0; i < this._tabs.length; i++) {\n            const isActive = this._tabs[i].componentItem === newActiveComponentItem;\n            this._tabs[i].setActive(isActive);\n            if (isActive) {\n                activeIndex = i;\n            }\n        }\n        if (activeIndex < 0) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.AssertError('HSACI56632');\n        }\n        else {\n            if (this._layoutManager.layoutConfig.settings.reorderOnTabMenuClick) {\n                /**\n                 * If the tab selected was in the dropdown, move everything down one to make way for this one to be the first.\n                 * This will make sure the most used tabs stay visible.\n                 */\n                if (this._lastVisibleTabIndex !== -1 && activeIndex > this._lastVisibleTabIndex) {\n                    const activeTab = this._tabs[activeIndex];\n                    for (let j = activeIndex; j > 0; j--) {\n                        this._tabs[j] = this._tabs[j - 1];\n                    }\n                    this._tabs[0] = activeTab;\n                    // updateTabSizes will always be called after this and it will reposition tab elements\n                }\n            }\n        }\n    }\n    /**\n     * Pushes the tabs to the tab dropdown if the available space is not sufficient\n     */\n    updateTabSizes(availableWidth, activeComponentItem) {\n        let dropDownActive = false;\n        const success = this.tryUpdateTabSizes(dropDownActive, availableWidth, activeComponentItem);\n        if (!success) {\n            dropDownActive = true;\n            // this will always succeed\n            this.tryUpdateTabSizes(dropDownActive, availableWidth, activeComponentItem);\n        }\n        if (dropDownActive !== this._dropdownActive) {\n            this._dropdownActive = dropDownActive;\n            this._dropdownActiveChangedEvent();\n        }\n    }\n    tryUpdateTabSizes(dropdownActive, availableWidth, activeComponentItem) {\n        if (this._tabs.length > 0) {\n            if (activeComponentItem === undefined) {\n                throw new Error('non-empty tabs must have active component item');\n            }\n            let cumulativeTabWidth = 0;\n            let tabOverlapAllowanceExceeded = false;\n            const tabOverlapAllowance = this._layoutManager.layoutConfig.settings.tabOverlapAllowance;\n            const activeIndex = this._tabs.indexOf(activeComponentItem.tab);\n            const activeTab = this._tabs[activeIndex];\n            this._lastVisibleTabIndex = -1;\n            for (let i = 0; i < this._tabs.length; i++) {\n                const tabElement = this._tabs[i].element;\n                //Put the tab in the tabContainer so its true width can be checked\n                if (tabElement.parentElement !== this._element) {\n                    this._element.appendChild(tabElement);\n                }\n                const tabMarginRightPixels = getComputedStyle(activeTab.element).marginRight;\n                const tabMarginRight = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.pixelsToNumber)(tabMarginRightPixels);\n                const tabWidth = tabElement.offsetWidth + tabMarginRight;\n                cumulativeTabWidth += tabWidth;\n                //Include the active tab's width if it isn't already\n                //This is to ensure there is room to show the active tab\n                let visibleTabWidth = 0;\n                if (activeIndex <= i) {\n                    visibleTabWidth = cumulativeTabWidth;\n                }\n                else {\n                    const activeTabMarginRightPixels = getComputedStyle(activeTab.element).marginRight;\n                    const activeTabMarginRight = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.pixelsToNumber)(activeTabMarginRightPixels);\n                    visibleTabWidth = cumulativeTabWidth + activeTab.element.offsetWidth + activeTabMarginRight;\n                }\n                // If the tabs won't fit, check the overlap allowance.\n                if (visibleTabWidth > availableWidth) {\n                    //Once allowance is exceeded, all remaining tabs go to menu.\n                    if (!tabOverlapAllowanceExceeded) {\n                        //No overlap for first tab or active tab\n                        //Overlap spreads among non-active, non-first tabs\n                        let overlap;\n                        if (activeIndex > 0 && activeIndex <= i) {\n                            overlap = (visibleTabWidth - availableWidth) / (i - 1);\n                        }\n                        else {\n                            overlap = (visibleTabWidth - availableWidth) / i;\n                        }\n                        //Check overlap against allowance.\n                        if (overlap < tabOverlapAllowance) {\n                            for (let j = 0; j <= i; j++) {\n                                const marginLeft = (j !== activeIndex && j !== 0) ? '-' + (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.numberToPixels)(overlap) : '';\n                                this._tabs[j].element.style.zIndex = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.numberToPixels)(i - j);\n                                this._tabs[j].element.style.marginLeft = marginLeft;\n                            }\n                            this._lastVisibleTabIndex = i;\n                            if (tabElement.parentElement !== this._element) {\n                                this._element.appendChild(tabElement);\n                            }\n                        }\n                        else {\n                            tabOverlapAllowanceExceeded = true;\n                        }\n                    }\n                    else if (i === activeIndex) {\n                        //Active tab should show even if allowance exceeded. (We left room.)\n                        tabElement.style.zIndex = 'auto';\n                        tabElement.style.marginLeft = '';\n                        if (tabElement.parentElement !== this._element) {\n                            this._element.appendChild(tabElement);\n                        }\n                    }\n                    if (tabOverlapAllowanceExceeded && i !== activeIndex) {\n                        if (dropdownActive) {\n                            //Tab menu already shown, so we just add to it.\n                            tabElement.style.zIndex = 'auto';\n                            tabElement.style.marginLeft = '';\n                            if (tabElement.parentElement !== this._dropdownElement) {\n                                this._dropdownElement.appendChild(tabElement);\n                            }\n                        }\n                        else {\n                            //We now know the tab menu must be shown, so we have to recalculate everything.\n                            return false;\n                        }\n                    }\n                }\n                else {\n                    this._lastVisibleTabIndex = i;\n                    tabElement.style.zIndex = 'auto';\n                    tabElement.style.marginLeft = '';\n                    if (tabElement.parentElement !== this._element) {\n                        this._element.appendChild(tabElement);\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Shows drop down for additional tabs when there are too many to display.\n     */\n    showAdditionalTabsDropdown() {\n        this._dropdownElement.style.display = '';\n    }\n    /**\n     * Hides drop down for additional tabs when there are too many to display.\n     */\n    hideAdditionalTabsDropdown() {\n        this._dropdownElement.style.display = 'none';\n    }\n    handleTabCloseEvent(componentItem) {\n        this._componentRemoveEvent(componentItem);\n    }\n    handleTabFocusEvent(componentItem) {\n        this._componentFocusEvent(componentItem);\n    }\n    handleTabDragStartEvent(x, y, dragListener, componentItem) {\n        this._componentDragStartEvent(x, y, dragListener, componentItem);\n    }\n}\n//# sourceMappingURL=tabs-container.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/controls/tabs-container.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/controls/transition-indicator.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/controls/transition-indicator.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TransitionIndicator: () => (/* binding */ TransitionIndicator)\n/* harmony export */ });\n/** @internal @deprecated To be removed */\nclass TransitionIndicator {\n    constructor() {\n        this._element = document.createElement('div');\n        this._element.classList.add(\"lm_transition_indicator\" /* TransitionIndicator */);\n        document.body.appendChild(this._element);\n        this._toElement = null;\n        this._fromDimensions = null;\n        this._totalAnimationDuration = 200;\n        this._animationStartTime = null;\n    }\n    destroy() {\n        this._element.remove();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    transitionElements(fromElement, toElement) {\n        /**\n         * TODO - This is not quite as cool as expected. Review.\n         */\n        return;\n        // this._toElement = toElement;\n        // this._animationStartTime = now();\n        // this._fromDimensions = this._measure(fromElement);\n        // this._fromDimensions.opacity = 0.8;\n        // this._element.show().css(this._fromDimensions);\n        // animFrame(fnBind(this._nextAnimationFrame, this));\n    }\n    nextAnimationFrame() {\n        // if (this._toElement === null || this._fromDimensions === null || this._animationStartTime === null) {\n        //     throw new UnexpectedNullError('TINAFTD97115');\n        // } else {\n        //     const toDimensions = this.measure(this._toElement);\n        //     const animationProgress = (now() - this._animationStartTime) / this._totalAnimationDuration;\n        //     const currentFrameStyles = {};\n        //     const cssProperty;\n        //     if (animationProgress >= 1) {\n        //         this._element.style.display = 'none';\n        //         return;\n        //     }\n        //     toDimensions.opacity = 0;\n        //     for (const cssProperty in this._fromDimensions) {\n        //         currentFrameStyles[cssProperty] = this._fromDimensions[cssProperty] +\n        //             (toDimensions[cssProperty] - this._fromDimensions[cssProperty]) *\n        //             animationProgress;\n        //     }\n        //     this._element.css(currentFrameStyles);\n        //     animFrame(fnBind(this._nextAnimationFrame, this));\n        // }\n    }\n    measure(element) {\n        const rect = element.getBoundingClientRect();\n        return {\n            left: rect.left,\n            top: rect.top,\n            width: element.offsetWidth,\n            height: element.offsetHeight,\n        };\n    }\n}\n//# sourceMappingURL=transition-indicator.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/controls/transition-indicator.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/errors/external-error.js":
/*!*************************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/errors/external-error.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiError: () => (/* binding */ ApiError),\n/* harmony export */   BindError: () => (/* binding */ BindError),\n/* harmony export */   ConfigurationError: () => (/* binding */ ConfigurationError),\n/* harmony export */   ExternalError: () => (/* binding */ ExternalError),\n/* harmony export */   PopoutBlockedError: () => (/* binding */ PopoutBlockedError)\n/* harmony export */ });\n/** @public */\nclass ExternalError extends Error {\n    /** @internal */\n    constructor(type, message) {\n        super(message);\n        this.type = type;\n    }\n}\n/** @public */\nclass ConfigurationError extends ExternalError {\n    /** @internal */\n    constructor(message, node) {\n        super('Configuration', message);\n        this.node = node;\n    }\n}\n/** @public */\nclass PopoutBlockedError extends ExternalError {\n    /** @internal */\n    constructor(message) {\n        super('PopoutBlocked', message);\n    }\n}\n/** @public */\nclass ApiError extends ExternalError {\n    /** @internal */\n    constructor(message) {\n        super('API', message);\n    }\n}\n/** @public */\nclass BindError extends ExternalError {\n    /** @internal */\n    constructor(message) {\n        super('Bind', message);\n    }\n}\n//# sourceMappingURL=external-error.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/errors/external-error.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js":
/*!*************************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AssertError: () => (/* binding */ AssertError),\n/* harmony export */   UnexpectedNullError: () => (/* binding */ UnexpectedNullError),\n/* harmony export */   UnexpectedUndefinedError: () => (/* binding */ UnexpectedUndefinedError),\n/* harmony export */   UnreachableCaseError: () => (/* binding */ UnreachableCaseError)\n/* harmony export */ });\n/** @internal */\nclass InternalError extends Error {\n    constructor(type, code, message) {\n        super(`${type}: ${code}${message === undefined ? '' : ': ' + message}`);\n    }\n}\n/** @internal */\nclass AssertError extends InternalError {\n    constructor(code, message) {\n        super('Assert', code, message);\n    }\n}\n/** @internal */\nclass UnreachableCaseError extends InternalError {\n    constructor(code, variableValue, message) {\n        super('UnreachableCase', code, `${variableValue}${message === undefined ? '' : ': ' + message}`);\n    }\n}\n/** @internal */\nclass UnexpectedNullError extends InternalError {\n    constructor(code, message) {\n        super('UnexpectedNull', code, message);\n    }\n}\n/** @internal */\nclass UnexpectedUndefinedError extends InternalError {\n    constructor(code, message) {\n        super('UnexpectedUndefined', code, message);\n    }\n}\n//# sourceMappingURL=internal-error.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/golden-layout.js":
/*!*****************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/golden-layout.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GoldenLayout: () => (/* binding */ GoldenLayout)\n/* harmony export */ });\n/* harmony import */ var _config_resolved_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./config/resolved-config */ \"./node_modules/golden-layout/dist/esm/ts/config/resolved-config.js\");\n/* harmony import */ var _errors_external_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors/external-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/external-error.js\");\n/* harmony import */ var _errors_internal_error__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./errors/internal-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js\");\n/* harmony import */ var _utils_i18n_strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/i18n-strings */ \"./node_modules/golden-layout/dist/esm/ts/utils/i18n-strings.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/utils */ \"./node_modules/golden-layout/dist/esm/ts/utils/utils.js\");\n/* harmony import */ var _virtual_layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./virtual-layout */ \"./node_modules/golden-layout/dist/esm/ts/virtual-layout.js\");\n\n\n\n\n\n\n/** @public */\nclass GoldenLayout extends _virtual_layout__WEBPACK_IMPORTED_MODULE_0__.VirtualLayout {\n    /** @internal */\n    constructor(configOrOptionalContainer, containerOrBindComponentEventHandler, unbindComponentEventHandler) {\n        super(configOrOptionalContainer, containerOrBindComponentEventHandler, unbindComponentEventHandler, true);\n        /** @internal */\n        this._componentTypesMap = new Map();\n        /** @internal */\n        this._registeredComponentMap = new Map();\n        /** @internal */\n        this._virtuableComponentMap = new Map();\n        /** @internal */\n        this._containerVirtualRectingRequiredEventListener = (container, width, height) => this.handleContainerVirtualRectingRequiredEvent(container, width, height);\n        /** @internal */\n        this._containerVirtualVisibilityChangeRequiredEventListener = (container, visible) => this.handleContainerVirtualVisibilityChangeRequiredEvent(container, visible);\n        /** @internal */\n        this._containerVirtualZIndexChangeRequiredEventListener = (container, logicalZIndex, defaultZIndex) => this.handleContainerVirtualZIndexChangeRequiredEvent(container, logicalZIndex, defaultZIndex);\n        // we told VirtualLayout to not call init() (skipInit set to true) so that Golden Layout can initialise its properties before init is called\n        if (!this.deprecatedConstructor) {\n            this.init();\n        }\n    }\n    /**\n     * Register a new component type with the layout manager.\n     *\n     * @deprecated See {@link https://stackoverflow.com/questions/40922531/how-to-check-if-a-javascript-function-is-a-constructor}\n     * instead use {@link (GoldenLayout:class).registerComponentConstructor}\n     * or {@link (GoldenLayout:class).registerComponentFactoryFunction}\n     */\n    registerComponent(name, componentConstructorOrFactoryFtn, virtual = false) {\n        if (typeof componentConstructorOrFactoryFtn !== 'function') {\n            throw new _errors_external_error__WEBPACK_IMPORTED_MODULE_1__.ApiError('registerComponent() componentConstructorOrFactoryFtn parameter is not a function');\n        }\n        else {\n            if (componentConstructorOrFactoryFtn.hasOwnProperty('prototype')) {\n                const componentConstructor = componentConstructorOrFactoryFtn;\n                this.registerComponentConstructor(name, componentConstructor, virtual);\n            }\n            else {\n                const componentFactoryFtn = componentConstructorOrFactoryFtn;\n                this.registerComponentFactoryFunction(name, componentFactoryFtn, virtual);\n            }\n        }\n    }\n    /**\n     * Register a new component type with the layout manager.\n     */\n    registerComponentConstructor(typeName, componentConstructor, virtual = false) {\n        if (typeof componentConstructor !== 'function') {\n            throw new Error(_utils_i18n_strings__WEBPACK_IMPORTED_MODULE_2__.i18nStrings[1 /* PleaseRegisterAConstructorFunction */]);\n        }\n        const existingComponentType = this._componentTypesMap.get(typeName);\n        if (existingComponentType !== undefined) {\n            throw new _errors_external_error__WEBPACK_IMPORTED_MODULE_1__.BindError(`${_utils_i18n_strings__WEBPACK_IMPORTED_MODULE_2__.i18nStrings[3 /* ComponentIsAlreadyRegistered */]}: ${typeName}`);\n        }\n        this._componentTypesMap.set(typeName, {\n            constructor: componentConstructor,\n            factoryFunction: undefined,\n            virtual,\n        });\n    }\n    /**\n     * Register a new component with the layout manager.\n     */\n    registerComponentFactoryFunction(typeName, componentFactoryFunction, virtual = false) {\n        if (typeof componentFactoryFunction !== 'function') {\n            throw new _errors_external_error__WEBPACK_IMPORTED_MODULE_1__.BindError('Please register a constructor function');\n        }\n        const existingComponentType = this._componentTypesMap.get(typeName);\n        if (existingComponentType !== undefined) {\n            throw new _errors_external_error__WEBPACK_IMPORTED_MODULE_1__.BindError(`${_utils_i18n_strings__WEBPACK_IMPORTED_MODULE_2__.i18nStrings[3 /* ComponentIsAlreadyRegistered */]}: ${typeName}`);\n        }\n        this._componentTypesMap.set(typeName, {\n            constructor: undefined,\n            factoryFunction: componentFactoryFunction,\n            virtual,\n        });\n    }\n    /**\n     * Register a component function with the layout manager. This function should\n     * return a constructor for a component based on a config.\n     * This function will be called if a component type with the required name is not already registered.\n     * It is recommended that applications use the {@link (VirtualLayout:class).getComponentEvent} and\n     * {@link (VirtualLayout:class).releaseComponentEvent} instead of registering a constructor callback\n     * @deprecated use {@link (GoldenLayout:class).registerGetComponentConstructorCallback}\n     */\n    registerComponentFunction(callback) {\n        this.registerGetComponentConstructorCallback(callback);\n    }\n    /**\n     * Register a callback closure with the layout manager which supplies a Component Constructor.\n     * This callback should return a constructor for a component based on a config.\n     * This function will be called if a component type with the required name is not already registered.\n     * It is recommended that applications use the {@link (VirtualLayout:class).getComponentEvent} and\n     * {@link (VirtualLayout:class).releaseComponentEvent} instead of registering a constructor callback\n     */\n    registerGetComponentConstructorCallback(callback) {\n        if (typeof callback !== 'function') {\n            throw new Error('Please register a callback function');\n        }\n        if (this._getComponentConstructorFtn !== undefined) {\n            console.warn('Multiple component functions are being registered.  Only the final registered function will be used.');\n        }\n        this._getComponentConstructorFtn = callback;\n    }\n    getRegisteredComponentTypeNames() {\n        const typeNamesIterableIterator = this._componentTypesMap.keys();\n        return Array.from(typeNamesIterableIterator);\n    }\n    /**\n     * Returns a previously registered component instantiator.  Attempts to utilize registered\n     * component type by first, then falls back to the component constructor callback function (if registered).\n     * If neither gets an instantiator, then returns `undefined`.\n     * Note that `undefined` will return if config.componentType is not a string\n     *\n     * @param config - The item config\n     * @public\n     */\n    getComponentInstantiator(config) {\n        let instantiator;\n        const typeName = _config_resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedComponentItemConfig.resolveComponentTypeName(config);\n        if (typeName !== undefined) {\n            instantiator = this._componentTypesMap.get(typeName);\n        }\n        if (instantiator === undefined) {\n            if (this._getComponentConstructorFtn !== undefined) {\n                instantiator = {\n                    constructor: this._getComponentConstructorFtn(config),\n                    factoryFunction: undefined,\n                    virtual: false,\n                };\n            }\n        }\n        return instantiator;\n    }\n    /** @internal */\n    bindComponent(container, itemConfig) {\n        let instantiator;\n        const typeName = _config_resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedComponentItemConfig.resolveComponentTypeName(itemConfig);\n        if (typeName !== undefined) {\n            instantiator = this._componentTypesMap.get(typeName);\n        }\n        if (instantiator === undefined) {\n            if (this._getComponentConstructorFtn !== undefined) {\n                instantiator = {\n                    constructor: this._getComponentConstructorFtn(itemConfig),\n                    factoryFunction: undefined,\n                    virtual: false,\n                };\n            }\n        }\n        let result;\n        if (instantiator !== undefined) {\n            const virtual = instantiator.virtual;\n            // handle case where component is obtained by name or component constructor callback\n            let componentState;\n            if (itemConfig.componentState === undefined) {\n                componentState = undefined;\n            }\n            else {\n                // make copy\n                componentState = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.deepExtendValue)({}, itemConfig.componentState);\n            }\n            let component;\n            const componentConstructor = instantiator.constructor;\n            if (componentConstructor !== undefined) {\n                component = new componentConstructor(container, componentState, virtual);\n            }\n            else {\n                const factoryFunction = instantiator.factoryFunction;\n                if (factoryFunction !== undefined) {\n                    component = factoryFunction(container, componentState, virtual);\n                }\n                else {\n                    throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_5__.AssertError('LMBCFFU10008');\n                }\n            }\n            if (virtual) {\n                if (component === undefined) {\n                    throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_5__.UnexpectedUndefinedError('GLBCVCU988774');\n                }\n                else {\n                    const virtuableComponent = component;\n                    const componentRootElement = virtuableComponent.rootHtmlElement;\n                    if (componentRootElement === undefined) {\n                        throw new _errors_external_error__WEBPACK_IMPORTED_MODULE_1__.BindError(`${_utils_i18n_strings__WEBPACK_IMPORTED_MODULE_2__.i18nStrings[5 /* VirtualComponentDoesNotHaveRootHtmlElement */]}: ${typeName}`);\n                    }\n                    else {\n                        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.ensureElementPositionAbsolute)(componentRootElement);\n                        this.container.appendChild(componentRootElement);\n                        this._virtuableComponentMap.set(container, virtuableComponent);\n                        container.virtualRectingRequiredEvent = this._containerVirtualRectingRequiredEventListener;\n                        container.virtualVisibilityChangeRequiredEvent = this._containerVirtualVisibilityChangeRequiredEventListener;\n                        container.virtualZIndexChangeRequiredEvent = this._containerVirtualZIndexChangeRequiredEventListener;\n                    }\n                }\n            }\n            this._registeredComponentMap.set(container, component);\n            result = {\n                virtual: instantiator.virtual,\n                component,\n            };\n        }\n        else {\n            // Use getComponentEvent\n            result = super.bindComponent(container, itemConfig);\n        }\n        return result;\n    }\n    /** @internal */\n    unbindComponent(container, virtual, component) {\n        const registeredComponent = this._registeredComponentMap.get(container);\n        if (registeredComponent === undefined) {\n            super.unbindComponent(container, virtual, component); // was not created from registration so use virtual unbind events\n        }\n        else {\n            const virtuableComponent = this._virtuableComponentMap.get(container);\n            if (virtuableComponent !== undefined) {\n                const componentRootElement = virtuableComponent.rootHtmlElement;\n                if (componentRootElement === undefined) {\n                    throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_5__.AssertError('GLUC77743', container.title);\n                }\n                else {\n                    this.container.removeChild(componentRootElement);\n                    this._virtuableComponentMap.delete(container);\n                }\n            }\n        }\n    }\n    fireBeforeVirtualRectingEvent(count) {\n        this._goldenLayoutBoundingClientRect = this.container.getBoundingClientRect();\n        super.fireBeforeVirtualRectingEvent(count);\n    }\n    /** @internal */\n    handleContainerVirtualRectingRequiredEvent(container, width, height) {\n        const virtuableComponent = this._virtuableComponentMap.get(container);\n        if (virtuableComponent === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_5__.UnexpectedUndefinedError('GLHCSCE55933');\n        }\n        else {\n            const rootElement = virtuableComponent.rootHtmlElement;\n            if (rootElement === undefined) {\n                throw new _errors_external_error__WEBPACK_IMPORTED_MODULE_1__.BindError(_utils_i18n_strings__WEBPACK_IMPORTED_MODULE_2__.i18nStrings[4 /* ComponentIsNotVirtuable */] + ' ' + container.title);\n            }\n            else {\n                const containerBoundingClientRect = container.element.getBoundingClientRect();\n                const left = containerBoundingClientRect.left - this._goldenLayoutBoundingClientRect.left;\n                rootElement.style.left = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.numberToPixels)(left);\n                const top = containerBoundingClientRect.top - this._goldenLayoutBoundingClientRect.top;\n                rootElement.style.top = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.numberToPixels)(top);\n                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.setElementWidth)(rootElement, width);\n                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.setElementHeight)(rootElement, height);\n            }\n        }\n    }\n    /** @internal */\n    handleContainerVirtualVisibilityChangeRequiredEvent(container, visible) {\n        const virtuableComponent = this._virtuableComponentMap.get(container);\n        if (virtuableComponent === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_5__.UnexpectedUndefinedError('GLHCVVCRE55934');\n        }\n        else {\n            const rootElement = virtuableComponent.rootHtmlElement;\n            if (rootElement === undefined) {\n                throw new _errors_external_error__WEBPACK_IMPORTED_MODULE_1__.BindError(_utils_i18n_strings__WEBPACK_IMPORTED_MODULE_2__.i18nStrings[4 /* ComponentIsNotVirtuable */] + ' ' + container.title);\n            }\n            else {\n                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.setElementDisplayVisibility)(rootElement, visible);\n            }\n        }\n    }\n    /** @internal */\n    handleContainerVirtualZIndexChangeRequiredEvent(container, logicalZIndex, defaultZIndex) {\n        const virtuableComponent = this._virtuableComponentMap.get(container);\n        if (virtuableComponent === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_5__.UnexpectedUndefinedError('GLHCVZICRE55935');\n        }\n        else {\n            const rootElement = virtuableComponent.rootHtmlElement;\n            if (rootElement === undefined) {\n                throw new _errors_external_error__WEBPACK_IMPORTED_MODULE_1__.BindError(_utils_i18n_strings__WEBPACK_IMPORTED_MODULE_2__.i18nStrings[4 /* ComponentIsNotVirtuable */] + ' ' + container.title);\n            }\n            else {\n                rootElement.style.zIndex = defaultZIndex;\n            }\n        }\n    }\n}\n//# sourceMappingURL=golden-layout.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/golden-layout.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/items/component-item.js":
/*!************************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/items/component-item.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ComponentItem: () => (/* binding */ ComponentItem)\n/* harmony export */ });\n/* harmony import */ var _config_resolved_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config/resolved-config */ \"./node_modules/golden-layout/dist/esm/ts/config/resolved-config.js\");\n/* harmony import */ var _container_component_container__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../container/component-container */ \"./node_modules/golden-layout/dist/esm/ts/container/component-container.js\");\n/* harmony import */ var _errors_internal_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../errors/internal-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js\");\n/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/types */ \"./node_modules/golden-layout/dist/esm/ts/utils/types.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/golden-layout/dist/esm/ts/utils/utils.js\");\n/* harmony import */ var _content_item__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./content-item */ \"./node_modules/golden-layout/dist/esm/ts/items/content-item.js\");\n\n\n\n\n\n\n/** @public */\nclass ComponentItem extends _content_item__WEBPACK_IMPORTED_MODULE_0__.ContentItem {\n    /** @internal */\n    constructor(layoutManager, config, \n    /** @internal */\n    _parentItem) {\n        super(layoutManager, config, _parentItem, document.createElement('div'));\n        this._parentItem = _parentItem;\n        /** @internal */\n        this._focused = false;\n        this.isComponent = true;\n        this._reorderEnabled = config.reorderEnabled;\n        this.applyUpdatableConfig(config);\n        this._initialWantMaximise = config.maximised;\n        const containerElement = document.createElement('div');\n        containerElement.classList.add(\"lm_content\" /* Content */);\n        this.element.appendChild(containerElement);\n        this._container = new _container_component_container__WEBPACK_IMPORTED_MODULE_1__.ComponentContainer(config, this, layoutManager, containerElement, (itemConfig) => this.handleUpdateItemConfigEvent(itemConfig), () => this.show(), () => this.hide(), (suppressEvent) => this.focus(suppressEvent), (suppressEvent) => this.blur(suppressEvent));\n    }\n    /** @internal @deprecated use {@link (ComponentItem:class).componentType} */\n    get componentName() { return this._container.componentType; }\n    get componentType() { return this._container.componentType; }\n    get reorderEnabled() { return this._reorderEnabled; }\n    /** @internal */\n    get initialWantMaximise() { return this._initialWantMaximise; }\n    get component() { return this._container.component; }\n    get container() { return this._container; }\n    get parentItem() { return this._parentItem; }\n    get headerConfig() { return this._headerConfig; }\n    get title() { return this._title; }\n    get tab() { return this._tab; }\n    get focused() { return this._focused; }\n    /** @internal */\n    destroy() {\n        this._container.destroy();\n        super.destroy();\n    }\n    applyUpdatableConfig(config) {\n        this.setTitle(config.title);\n        this._headerConfig = config.header;\n    }\n    toConfig() {\n        const stateRequestEvent = this._container.stateRequestEvent;\n        const state = stateRequestEvent === undefined ? this._container.state : stateRequestEvent();\n        const result = {\n            type: _utils_types__WEBPACK_IMPORTED_MODULE_2__.ItemType.component,\n            content: [],\n            size: this.size,\n            sizeUnit: this.sizeUnit,\n            minSize: this.minSize,\n            minSizeUnit: this.minSizeUnit,\n            id: this.id,\n            maximised: false,\n            isClosable: this.isClosable,\n            reorderEnabled: this._reorderEnabled,\n            title: this._title,\n            header: _config_resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedHeaderedItemConfig.Header.createCopy(this._headerConfig),\n            componentType: _config_resolved_config__WEBPACK_IMPORTED_MODULE_3__.ResolvedComponentItemConfig.copyComponentType(this.componentType),\n            componentState: state,\n        };\n        return result;\n    }\n    close() {\n        if (this.parent === null) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_4__.UnexpectedNullError('CIC68883');\n        }\n        else {\n            this.parent.removeChild(this, false);\n        }\n    }\n    // Used by Drag Proxy\n    /** @internal */\n    enterDragMode(width, height) {\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_5__.setElementWidth)(this.element, width);\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_5__.setElementHeight)(this.element, height);\n        this._container.enterDragMode(width, height);\n    }\n    /** @internal */\n    exitDragMode() {\n        this._container.exitDragMode();\n    }\n    /** @internal */\n    enterStackMaximised() {\n        this._container.enterStackMaximised();\n    }\n    /** @internal */\n    exitStackMaximised() {\n        this._container.exitStackMaximised();\n    }\n    // Used by Drag Proxy\n    /** @internal */\n    drag() {\n        this._container.drag();\n    }\n    /** @internal */\n    updateSize(force) {\n        this.updateNodeSize(force);\n    }\n    /** @internal */\n    init() {\n        this.updateNodeSize(false);\n        super.init();\n        this._container.emit('open');\n        this.initContentItems();\n    }\n    /**\n     * Set this component's title\n     *\n     * @public\n     * @param title -\n     */\n    setTitle(title) {\n        this._title = title;\n        this.emit('titleChanged', title);\n        this.emit('stateChanged');\n    }\n    setTab(tab) {\n        this._tab = tab;\n        this.emit('tab', tab);\n        this._container.setTab(tab);\n    }\n    /** @internal */\n    hide() {\n        super.hide();\n        this._container.setVisibility(false);\n    }\n    /** @internal */\n    show() {\n        super.show();\n        this._container.setVisibility(true);\n    }\n    /**\n     * Focuses the item if it is not already focused\n     */\n    focus(suppressEvent = false) {\n        this.parentItem.setActiveComponentItem(this, true, suppressEvent);\n    }\n    /** @internal */\n    setFocused(suppressEvent) {\n        this._focused = true;\n        this.tab.setFocused();\n        if (!suppressEvent) {\n            this.emitBaseBubblingEvent('focus');\n        }\n    }\n    /**\n     * Blurs (defocuses) the item if it is focused\n     */\n    blur(suppressEvent = false) {\n        if (this._focused) {\n            this.layoutManager.setFocusedComponentItem(undefined, suppressEvent);\n        }\n    }\n    /** @internal */\n    setBlurred(suppressEvent) {\n        this._focused = false;\n        this.tab.setBlurred();\n        if (!suppressEvent) {\n            this.emitBaseBubblingEvent('blur');\n        }\n    }\n    /** @internal */\n    setParent(parent) {\n        this._parentItem = parent;\n        super.setParent(parent);\n    }\n    /** @internal */\n    handleUpdateItemConfigEvent(itemConfig) {\n        this.applyUpdatableConfig(itemConfig);\n    }\n    /** @internal */\n    updateNodeSize(force) {\n        if (this.element.style.display !== 'none') {\n            // Do not update size of hidden components to prevent unwanted reflows\n            const { width, height } = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_5__.getElementWidthAndHeight)(this.element);\n            this._container.setSizeToNodeSize(width, height, force);\n        }\n    }\n}\n//# sourceMappingURL=component-item.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/items/component-item.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/items/component-parentable-item.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/items/component-parentable-item.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ComponentParentableItem: () => (/* binding */ ComponentParentableItem)\n/* harmony export */ });\n/* harmony import */ var _content_item__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./content-item */ \"./node_modules/golden-layout/dist/esm/ts/items/content-item.js\");\n\nclass ComponentParentableItem extends _content_item__WEBPACK_IMPORTED_MODULE_0__.ContentItem {\n    constructor() {\n        super(...arguments);\n        /** @internal */\n        this._focused = false;\n    }\n    get focused() { return this._focused; }\n    /** @internal */\n    setFocusedValue(value) {\n        this._focused = value;\n    }\n}\n//# sourceMappingURL=component-parentable-item.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/items/component-parentable-item.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/items/content-item.js":
/*!**********************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/items/content-item.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentItem: () => (/* binding */ ContentItem)\n/* harmony export */ });\n/* harmony import */ var _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/internal-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js\");\n/* harmony import */ var _utils_event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/event-emitter */ \"./node_modules/golden-layout/dist/esm/ts/utils/event-emitter.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/golden-layout/dist/esm/ts/utils/utils.js\");\n\n\n\n/**\n * This is the baseclass that all content items inherit from.\n * Most methods provide a subset of what the sub-classes do.\n *\n * It also provides a number of functions for tree traversal\n * @public\n */\nclass ContentItem extends _utils_event_emitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    /** @internal */\n    constructor(layoutManager, config, \n    /** @internal */\n    _parent, \n    /** @internal */\n    _element) {\n        super();\n        this.layoutManager = layoutManager;\n        this._parent = _parent;\n        this._element = _element;\n        /** @internal */\n        this._popInParentIds = [];\n        this._type = config.type;\n        this._id = config.id;\n        this._isInitialised = false;\n        this.isGround = false;\n        this.isRow = false;\n        this.isColumn = false;\n        this.isStack = false;\n        this.isComponent = false;\n        this.size = config.size;\n        this.sizeUnit = config.sizeUnit;\n        this.minSize = config.minSize;\n        this.minSizeUnit = config.minSizeUnit;\n        this._isClosable = config.isClosable;\n        this._pendingEventPropagations = {};\n        this._throttledEvents = ['stateChanged'];\n        this._contentItems = this.createContentItems(config.content);\n    }\n    get type() { return this._type; }\n    get id() { return this._id; }\n    set id(value) { this._id = value; }\n    /** @internal */\n    get popInParentIds() { return this._popInParentIds; }\n    get parent() { return this._parent; }\n    get contentItems() { return this._contentItems; }\n    get isClosable() { return this._isClosable; }\n    get element() { return this._element; }\n    get isInitialised() { return this._isInitialised; }\n    static isStack(item) {\n        return item.isStack;\n    }\n    static isComponentItem(item) {\n        return item.isComponent;\n    }\n    static isComponentParentableItem(item) {\n        return item.isStack || item.isGround;\n    }\n    /**\n     * Removes a child node (and its children) from the tree\n     * @param contentItem - The child item to remove\n     * @param keepChild - Whether to destroy the removed item\n     */\n    removeChild(contentItem, keepChild = false) {\n        /*\n         * Get the position of the item that's to be removed within all content items this node contains\n         */\n        const index = this._contentItems.indexOf(contentItem);\n        /*\n         * Make sure the content item to be removed is actually a child of this item\n         */\n        if (index === -1) {\n            throw new Error('Can\\'t remove child item. Unknown content item');\n        }\n        /**\n         * Call destroy on the content item.\n         * All children are destroyed as well\n         */\n        if (!keepChild) {\n            this._contentItems[index].destroy();\n        }\n        /**\n         * Remove the content item from this nodes array of children\n         */\n        this._contentItems.splice(index, 1);\n        /**\n         * If this node still contains other content items, adjust their size\n         */\n        if (this._contentItems.length > 0) {\n            this.updateSize(false);\n        }\n        else {\n            /**\n             * If this was the last content item, remove this node as well\n             */\n            if (!this.isGround && this._isClosable === true) {\n                if (this._parent === null) {\n                    throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.UnexpectedNullError('CIUC00874');\n                }\n                else {\n                    this._parent.removeChild(this);\n                }\n            }\n        }\n    }\n    /**\n     * Sets up the tree structure for the newly added child\n     * The responsibility for the actual DOM manipulations lies\n     * with the concrete item\n     *\n     * @param contentItem -\n     * @param index - If omitted item will be appended\n     * @param suspendResize - Used by descendent implementations\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    addChild(contentItem, index, suspendResize) {\n        index !== null && index !== void 0 ? index : (index = this._contentItems.length);\n        this._contentItems.splice(index, 0, contentItem);\n        contentItem.setParent(this);\n        if (this._isInitialised === true && contentItem._isInitialised === false) {\n            contentItem.init();\n        }\n        return index;\n    }\n    /**\n     * Replaces oldChild with newChild\n     * @param oldChild -\n     * @param newChild -\n     * @internal\n     */\n    replaceChild(oldChild, newChild, destroyOldChild = false) {\n        // Do not try to replace ComponentItem - will not work\n        const index = this._contentItems.indexOf(oldChild);\n        const parentNode = oldChild._element.parentNode;\n        if (index === -1) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.AssertError('CIRCI23232', 'Can\\'t replace child. oldChild is not child of this');\n        }\n        if (parentNode === null) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.UnexpectedNullError('CIRCP23232');\n        }\n        else {\n            parentNode.replaceChild(newChild._element, oldChild._element);\n            /*\n            * Optionally destroy the old content item\n            */\n            if (destroyOldChild === true) {\n                oldChild._parent = null;\n                oldChild.destroy(); // will now also destroy all children of oldChild\n            }\n            /*\n            * Wire the new contentItem into the tree\n            */\n            this._contentItems[index] = newChild;\n            newChild.setParent(this);\n            // newChild inherits the sizes from the old child:\n            newChild.size = oldChild.size;\n            newChild.sizeUnit = oldChild.sizeUnit;\n            newChild.minSize = oldChild.minSize;\n            newChild.minSizeUnit = oldChild.minSizeUnit;\n            //TODO This doesn't update the config... refactor to leave item nodes untouched after creation\n            if (newChild._parent === null) {\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.UnexpectedNullError('CIRCNC45699');\n            }\n            else {\n                if (newChild._parent._isInitialised === true && newChild._isInitialised === false) {\n                    newChild.init();\n                }\n                this.updateSize(false);\n            }\n        }\n    }\n    /**\n     * Convenience method.\n     * Shorthand for this.parent.removeChild( this )\n     */\n    remove() {\n        if (this._parent === null) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.UnexpectedNullError('CIR11110');\n        }\n        else {\n            this._parent.removeChild(this);\n        }\n    }\n    /**\n     * Removes the component from the layout and creates a new\n     * browser window with the component and its children inside\n     */\n    popout() {\n        const parentId = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.getUniqueId)();\n        const browserPopout = this.layoutManager.createPopoutFromContentItem(this, undefined, parentId, undefined);\n        this.emitBaseBubblingEvent('stateChanged');\n        return browserPopout;\n    }\n    /** @internal */\n    calculateConfigContent() {\n        const contentItems = this._contentItems;\n        const count = contentItems.length;\n        const result = new Array(count);\n        for (let i = 0; i < count; i++) {\n            const item = contentItems[i];\n            result[i] = item.toConfig();\n        }\n        return result;\n    }\n    /** @internal */\n    highlightDropZone(x, y, area) {\n        const dropTargetIndicator = this.layoutManager.dropTargetIndicator;\n        if (dropTargetIndicator === null) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.UnexpectedNullError('ACIHDZ5593');\n        }\n        else {\n            dropTargetIndicator.highlightArea(area, 1);\n        }\n    }\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onDrop(contentItem, area) {\n        this.addChild(contentItem);\n    }\n    /** @internal */\n    show() {\n        this.layoutManager.beginSizeInvalidation();\n        try {\n            // Not sure why showAllActiveContentItems() was called. GoldenLayout seems to work fine without it.  Left commented code\n            // in source in case a reason for it becomes apparent.\n            // this.layoutManager.showAllActiveContentItems();\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.setElementDisplayVisibility)(this._element, true);\n            // this.layoutManager.updateSizeFromContainer();\n            for (let i = 0; i < this._contentItems.length; i++) {\n                this._contentItems[i].show();\n            }\n        }\n        finally {\n            this.layoutManager.endSizeInvalidation();\n        }\n    }\n    /**\n     * Destroys this item ands its children\n     * @internal\n     */\n    destroy() {\n        for (let i = 0; i < this._contentItems.length; i++) {\n            this._contentItems[i].destroy();\n        }\n        this._contentItems = [];\n        this.emitBaseBubblingEvent('beforeItemDestroyed');\n        this._element.remove();\n        this.emitBaseBubblingEvent('itemDestroyed');\n    }\n    /**\n     * Returns the area the component currently occupies\n     * @internal\n     */\n    getElementArea(element) {\n        element = element !== null && element !== void 0 ? element : this._element;\n        const rect = element.getBoundingClientRect();\n        const top = rect.top + document.body.scrollTop;\n        const left = rect.left + document.body.scrollLeft;\n        const width = rect.width;\n        const height = rect.height;\n        return {\n            x1: left,\n            y1: top,\n            x2: left + width,\n            y2: top + height,\n            surface: width * height,\n            contentItem: this\n        };\n    }\n    /**\n     * The tree of content items is created in two steps: First all content items are instantiated,\n     * then init is called recursively from top to bottem. This is the basic init function,\n     * it can be used, extended or overwritten by the content items\n     *\n     * Its behaviour depends on the content item\n     * @internal\n     */\n    init() {\n        this._isInitialised = true;\n        this.emitBaseBubblingEvent('itemCreated');\n        this.emitUnknownBubblingEvent(this.type + 'Created');\n    }\n    /** @internal */\n    setParent(parent) {\n        this._parent = parent;\n    }\n    /** @internal */\n    addPopInParentId(id) {\n        if (!this.popInParentIds.includes(id)) {\n            this.popInParentIds.push(id);\n        }\n    }\n    /** @internal */\n    initContentItems() {\n        for (let i = 0; i < this._contentItems.length; i++) {\n            this._contentItems[i].init();\n        }\n    }\n    /** @internal */\n    hide() {\n        this.layoutManager.beginSizeInvalidation();\n        try {\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.setElementDisplayVisibility)(this._element, false);\n            // this.layoutManager.updateSizeFromContainer();\n        }\n        finally {\n            this.layoutManager.endSizeInvalidation();\n        }\n    }\n    /** @internal */\n    updateContentItemsSize(force) {\n        for (let i = 0; i < this._contentItems.length; i++) {\n            this._contentItems[i].updateSize(force);\n        }\n    }\n    /**\n     * creates all content items for this node at initialisation time\n     * PLEASE NOTE, please see addChild for adding contentItems at runtime\n     * @internal\n     */\n    createContentItems(content) {\n        const count = content.length;\n        const result = new Array(count);\n        for (let i = 0; i < content.length; i++) {\n            result[i] = this.layoutManager.createContentItem(content[i], this);\n        }\n        return result;\n    }\n    /**\n     * Called for every event on the item tree. Decides whether the event is a bubbling\n     * event and propagates it to its parent\n     *\n     * @param name - The name of the event\n     * @param event -\n     * @internal\n     */\n    propagateEvent(name, args) {\n        if (args.length === 1) {\n            const event = args[0];\n            if (event instanceof _utils_event_emitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter.BubblingEvent &&\n                event.isPropagationStopped === false &&\n                this._isInitialised === true) {\n                /**\n                 * In some cases (e.g. if an element is created from a DragSource) it\n                 * doesn't have a parent and is not a child of GroundItem. If that's the case\n                 * propagate the bubbling event from the top level of the substree directly\n                 * to the layoutManager\n                 */\n                if (this.isGround === false && this._parent) {\n                    this._parent.emitUnknown(name, event);\n                }\n                else {\n                    this.scheduleEventPropagationToLayoutManager(name, event);\n                }\n            }\n        }\n    }\n    tryBubbleEvent(name, args) {\n        if (args.length === 1) {\n            const event = args[0];\n            if (event instanceof _utils_event_emitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter.BubblingEvent &&\n                event.isPropagationStopped === false &&\n                this._isInitialised === true) {\n                /**\n                 * In some cases (e.g. if an element is created from a DragSource) it\n                 * doesn't have a parent and is not a child of GroundItem. If that's the case\n                 * propagate the bubbling event from the top level of the substree directly\n                 * to the layoutManager\n                 */\n                if (this.isGround === false && this._parent) {\n                    this._parent.emitUnknown(name, event);\n                }\n                else {\n                    this.scheduleEventPropagationToLayoutManager(name, event);\n                }\n            }\n        }\n    }\n    /**\n     * All raw events bubble up to the Ground element. Some events that\n     * are propagated to - and emitted by - the layoutManager however are\n     * only string-based, batched and sanitized to make them more usable\n     *\n     * @param name - The name of the event\n     * @internal\n     */\n    scheduleEventPropagationToLayoutManager(name, event) {\n        if (this._throttledEvents.indexOf(name) === -1) {\n            this.layoutManager.emitUnknown(name, event);\n        }\n        else {\n            if (this._pendingEventPropagations[name] !== true) {\n                this._pendingEventPropagations[name] = true;\n                globalThis.requestAnimationFrame(() => this.propagateEventToLayoutManager(name, event));\n            }\n        }\n    }\n    /**\n     * Callback for events scheduled by _scheduleEventPropagationToLayoutManager\n     *\n     * @param name - The name of the event\n     * @internal\n     */\n    propagateEventToLayoutManager(name, event) {\n        this._pendingEventPropagations[name] = false;\n        this.layoutManager.emitUnknown(name, event);\n    }\n}\n//# sourceMappingURL=content-item.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/items/content-item.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/items/ground-item.js":
/*!*********************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/items/ground-item.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GroundItem: () => (/* binding */ GroundItem)\n/* harmony export */ });\n/* harmony import */ var _config_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config/config */ \"./node_modules/golden-layout/dist/esm/ts/config/config.js\");\n/* harmony import */ var _config_resolved_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config/resolved-config */ \"./node_modules/golden-layout/dist/esm/ts/config/resolved-config.js\");\n/* harmony import */ var _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors/internal-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js\");\n/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/types */ \"./node_modules/golden-layout/dist/esm/ts/utils/types.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/golden-layout/dist/esm/ts/utils/utils.js\");\n/* harmony import */ var _component_item__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./component-item */ \"./node_modules/golden-layout/dist/esm/ts/items/component-item.js\");\n/* harmony import */ var _component_parentable_item__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component-parentable-item */ \"./node_modules/golden-layout/dist/esm/ts/items/component-parentable-item.js\");\n/* harmony import */ var _content_item__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./content-item */ \"./node_modules/golden-layout/dist/esm/ts/items/content-item.js\");\n/* harmony import */ var _row_or_column__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./row-or-column */ \"./node_modules/golden-layout/dist/esm/ts/items/row-or-column.js\");\n\n\n\n\n\n\n\n\n\n/**\n * GroundItem is the ContentItem whose one child is the root ContentItem (Root is planted in Ground).\n * (Previously it was called root however this was incorrect as its child is the root item)\n * There is only one instance of GroundItem and it is automatically created by the Layout Manager\n * @internal\n */\nclass GroundItem extends _component_parentable_item__WEBPACK_IMPORTED_MODULE_0__.ComponentParentableItem {\n    constructor(layoutManager, rootItemConfig, containerElement) {\n        super(layoutManager, _config_resolved_config__WEBPACK_IMPORTED_MODULE_1__.ResolvedGroundItemConfig.create(rootItemConfig), null, GroundItem.createElement(document));\n        this.isGround = true;\n        this._childElementContainer = this.element;\n        this._containerElement = containerElement;\n        // insert before any pre-existing content elements\n        let before = null;\n        while (true) {\n            const prev = before ? before.previousSibling : this._containerElement.lastChild;\n            if (prev instanceof Element\n                && prev.classList.contains(\"lm_content\" /* Content */)) {\n                before = prev;\n            }\n            else {\n                break;\n            }\n        }\n        this._containerElement.insertBefore(this.element, before);\n    }\n    init() {\n        if (this.isInitialised === true)\n            return;\n        this.updateNodeSize();\n        for (let i = 0; i < this.contentItems.length; i++) {\n            this._childElementContainer.appendChild(this.contentItems[i].element);\n        }\n        super.init();\n        this.initContentItems();\n    }\n    /**\n     * Loads a new Layout\n     * Internal only.  To load a new layout with API, use {@link (LayoutManager:class).loadLayout}\n     */\n    loadRoot(rootItemConfig) {\n        // Remove existing root if it exists\n        this.clearRoot();\n        if (rootItemConfig !== undefined) {\n            const rootContentItem = this.layoutManager.createAndInitContentItem(rootItemConfig, this);\n            this.addChild(rootContentItem, 0);\n        }\n    }\n    clearRoot() {\n        // Remove existing root if it exists\n        const contentItems = this.contentItems;\n        switch (contentItems.length) {\n            case 0: {\n                return;\n            }\n            case 1: {\n                const existingRootContentItem = contentItems[0];\n                existingRootContentItem.remove();\n                return;\n            }\n            default: {\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__.AssertError('GILR07721');\n            }\n        }\n    }\n    /**\n     * Adds a ContentItem child to root ContentItem.\n     * Internal only.  To load a add with API, use {@link (LayoutManager:class).addItem}\n     * @returns -1 if added as root otherwise index in root ContentItem's content\n     */\n    addItem(itemConfig, index) {\n        this.layoutManager.checkMinimiseMaximisedStack();\n        const resolvedItemConfig = _config_config__WEBPACK_IMPORTED_MODULE_3__.ItemConfig.resolve(itemConfig, false);\n        let parent;\n        if (this.contentItems.length > 0) {\n            parent = this.contentItems[0];\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            parent = this;\n        }\n        if (parent.isComponent) {\n            throw new Error('Cannot add item as child to ComponentItem');\n        }\n        else {\n            const contentItem = this.layoutManager.createAndInitContentItem(resolvedItemConfig, parent);\n            index = parent.addChild(contentItem, index);\n            return (parent === this) ? -1 : index;\n        }\n    }\n    loadComponentAsRoot(itemConfig) {\n        // Remove existing root if it exists\n        this.clearRoot();\n        const resolvedItemConfig = _config_config__WEBPACK_IMPORTED_MODULE_3__.ItemConfig.resolve(itemConfig, false);\n        if (resolvedItemConfig.maximised) {\n            throw new Error('Root Component cannot be maximised');\n        }\n        else {\n            const rootContentItem = new _component_item__WEBPACK_IMPORTED_MODULE_4__.ComponentItem(this.layoutManager, resolvedItemConfig, this);\n            rootContentItem.init();\n            this.addChild(rootContentItem, 0);\n        }\n    }\n    /**\n     * Adds a Root ContentItem.\n     * Internal only.  To replace Root ContentItem with API, use {@link (LayoutManager:class).loadLayout}\n     */\n    addChild(contentItem, index) {\n        if (this.contentItems.length > 0) {\n            throw new Error('Ground node can only have a single child');\n        }\n        else {\n            // contentItem = this.layoutManager._$normalizeContentItem(contentItem, this);\n            this._childElementContainer.appendChild(contentItem.element);\n            index = super.addChild(contentItem, index);\n            this.updateSize(false);\n            this.emitBaseBubblingEvent('stateChanged');\n            return index;\n        }\n    }\n    /** @internal */\n    calculateConfigContent() {\n        const contentItems = this.contentItems;\n        const count = contentItems.length;\n        const result = new Array(count);\n        for (let i = 0; i < count; i++) {\n            const item = contentItems[i];\n            const itemConfig = item.toConfig();\n            if (_config_resolved_config__WEBPACK_IMPORTED_MODULE_1__.ResolvedRootItemConfig.isRootItemConfig(itemConfig)) {\n                result[i] = itemConfig;\n            }\n            else {\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__.AssertError('RCCC66832');\n            }\n        }\n        return result;\n    }\n    /** @internal */\n    setSize(width, height) {\n        if (width === undefined || height === undefined) {\n            this.updateSize(false); // For backwards compatibility with v1.x API\n        }\n        else {\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_5__.setElementWidth)(this.element, width);\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_5__.setElementHeight)(this.element, height);\n            // GroundItem can be empty\n            if (this.contentItems.length > 0) {\n                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_5__.setElementWidth)(this.contentItems[0].element, width);\n                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_5__.setElementHeight)(this.contentItems[0].element, height);\n            }\n            this.updateContentItemsSize(false);\n        }\n    }\n    /**\n     * Adds a Root ContentItem.\n     * Internal only.  To replace Root ContentItem with API, use {@link (LayoutManager:class).updateRootSize}\n     */\n    updateSize(force) {\n        this.layoutManager.beginVirtualSizedContainerAdding();\n        try {\n            this.updateNodeSize();\n            this.updateContentItemsSize(force);\n        }\n        finally {\n            this.layoutManager.endVirtualSizedContainerAdding();\n        }\n    }\n    createSideAreas() {\n        const areaSize = 50;\n        const oppositeSides = GroundItem.Area.oppositeSides;\n        const result = new Array(Object.keys(oppositeSides).length);\n        let idx = 0;\n        for (const key in oppositeSides) {\n            const side = key;\n            const area = this.getElementArea();\n            if (area === null) {\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__.UnexpectedNullError('RCSA77553');\n            }\n            else {\n                area.side = side;\n                if (oppositeSides[side][1] === '2')\n                    area[side] = area[oppositeSides[side]] - areaSize;\n                else\n                    area[side] = area[oppositeSides[side]] + areaSize;\n                area.surface = (area.x2 - area.x1) * (area.y2 - area.y1);\n                result[idx++] = area;\n            }\n        }\n        return result;\n    }\n    highlightDropZone(x, y, area) {\n        this.layoutManager.tabDropPlaceholder.remove();\n        super.highlightDropZone(x, y, area);\n    }\n    onDrop(contentItem, area) {\n        if (contentItem.isComponent) {\n            const itemConfig = _config_resolved_config__WEBPACK_IMPORTED_MODULE_1__.ResolvedStackItemConfig.createDefault();\n            // since ResolvedItemConfig.contentItems not set up, we need to add header from Component\n            const component = contentItem;\n            itemConfig.header = _config_resolved_config__WEBPACK_IMPORTED_MODULE_1__.ResolvedHeaderedItemConfig.Header.createCopy(component.headerConfig);\n            const stack = this.layoutManager.createAndInitContentItem(itemConfig, this);\n            stack.addChild(contentItem);\n            contentItem = stack;\n        }\n        if (this.contentItems.length === 0) {\n            this.addChild(contentItem);\n        }\n        else {\n            /*\n             * If the contentItem that's being dropped is not dropped on a Stack (cases which just passed above and\n             * which would wrap the contentItem in a Stack) we need to check whether contentItem is a RowOrColumn.\n             * If it is, we need to re-wrap it in a Stack like it was when it was dragged by its Tab (it was dragged!).\n             */\n            if (contentItem.type === _utils_types__WEBPACK_IMPORTED_MODULE_6__.ItemType.row || contentItem.type === _utils_types__WEBPACK_IMPORTED_MODULE_6__.ItemType.column) {\n                const itemConfig = _config_resolved_config__WEBPACK_IMPORTED_MODULE_1__.ResolvedStackItemConfig.createDefault();\n                const stack = this.layoutManager.createContentItem(itemConfig, this);\n                stack.addChild(contentItem);\n                contentItem = stack;\n            }\n            const type = area.side[0] == 'x' ? _utils_types__WEBPACK_IMPORTED_MODULE_6__.ItemType.row : _utils_types__WEBPACK_IMPORTED_MODULE_6__.ItemType.column;\n            const insertBefore = area.side[1] == '2';\n            const column = this.contentItems[0];\n            if (!(column instanceof _row_or_column__WEBPACK_IMPORTED_MODULE_7__.RowOrColumn) || column.type !== type) {\n                const itemConfig = _config_resolved_config__WEBPACK_IMPORTED_MODULE_1__.ResolvedItemConfig.createDefault(type);\n                const rowOrColumn = this.layoutManager.createContentItem(itemConfig, this);\n                this.replaceChild(column, rowOrColumn);\n                rowOrColumn.addChild(contentItem, insertBefore ? 0 : undefined, true);\n                rowOrColumn.addChild(column, insertBefore ? undefined : 0, true);\n                column.size = 50;\n                contentItem.size = 50;\n                contentItem.sizeUnit = _utils_types__WEBPACK_IMPORTED_MODULE_6__.SizeUnitEnum.Percent;\n                rowOrColumn.updateSize(false);\n            }\n            else {\n                const sibling = column.contentItems[insertBefore ? 0 : column.contentItems.length - 1];\n                column.addChild(contentItem, insertBefore ? 0 : undefined, true);\n                sibling.size *= 0.5;\n                contentItem.size = sibling.size;\n                contentItem.sizeUnit = _utils_types__WEBPACK_IMPORTED_MODULE_6__.SizeUnitEnum.Percent;\n                column.updateSize(false);\n            }\n        }\n    }\n    // No ContentItem can dock with groundItem.  However Stack can have a GroundItem parent and Stack requires that\n    // its parent implement dock() function.  Accordingly this function is implemented but throws an exception as it should\n    // never be called\n    dock() {\n        throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__.AssertError('GID87731');\n    }\n    // No ContentItem can dock with groundItem.  However Stack can have a GroundItem parent and Stack requires that\n    // its parent implement validateDocking() function.  Accordingly this function is implemented but throws an exception as it should\n    // never be called\n    validateDocking() {\n        throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__.AssertError('GIVD87732');\n    }\n    getAllContentItems() {\n        const result = [this];\n        this.deepGetAllContentItems(this.contentItems, result);\n        return result;\n    }\n    getConfigMaximisedItems() {\n        const result = [];\n        this.deepFilterContentItems(this.contentItems, result, (item) => {\n            if (_content_item__WEBPACK_IMPORTED_MODULE_8__.ContentItem.isStack(item) && item.initialWantMaximise) {\n                return true;\n            }\n            else {\n                if (_content_item__WEBPACK_IMPORTED_MODULE_8__.ContentItem.isComponentItem(item) && item.initialWantMaximise) {\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n        });\n        return result;\n    }\n    getItemsByPopInParentId(popInParentId) {\n        const result = [];\n        this.deepFilterContentItems(this.contentItems, result, (item) => item.popInParentIds.includes(popInParentId));\n        return result;\n    }\n    toConfig() {\n        throw new Error('Cannot generate GroundItem config');\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setActiveComponentItem(item, focus, suppressFocusEvent) {\n        // only applicable if ComponentItem is root and then it always has focus\n    }\n    updateNodeSize() {\n        const { width, height } = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_5__.getElementWidthAndHeight)(this._containerElement);\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_5__.setElementWidth)(this.element, width);\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_5__.setElementHeight)(this.element, height);\n        /*\n         * GroundItem can be empty\n         */\n        if (this.contentItems.length > 0) {\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_5__.setElementWidth)(this.contentItems[0].element, width);\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_5__.setElementHeight)(this.contentItems[0].element, height);\n        }\n    }\n    deepGetAllContentItems(content, result) {\n        for (let i = 0; i < content.length; i++) {\n            const contentItem = content[i];\n            result.push(contentItem);\n            this.deepGetAllContentItems(contentItem.contentItems, result);\n        }\n    }\n    deepFilterContentItems(content, result, checkAcceptFtn) {\n        for (let i = 0; i < content.length; i++) {\n            const contentItem = content[i];\n            if (checkAcceptFtn(contentItem)) {\n                result.push(contentItem);\n            }\n            this.deepFilterContentItems(contentItem.contentItems, result, checkAcceptFtn);\n        }\n    }\n}\n/** @internal */\n(function (GroundItem) {\n    let Area;\n    (function (Area) {\n        Area.oppositeSides = {\n            y2: 'y1',\n            x2: 'x1',\n            y1: 'y2',\n            x1: 'x2',\n        };\n    })(Area = GroundItem.Area || (GroundItem.Area = {}));\n    function createElement(document) {\n        const element = document.createElement('div');\n        element.classList.add(\"lm_goldenlayout\" /* GoldenLayout */);\n        element.classList.add(\"lm_item\" /* Item */);\n        element.classList.add(\"lm_root\" /* Root */);\n        return element;\n    }\n    GroundItem.createElement = createElement;\n})(GroundItem || (GroundItem = {}));\n//# sourceMappingURL=ground-item.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/items/ground-item.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/items/row-or-column.js":
/*!***********************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/items/row-or-column.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RowOrColumn: () => (/* binding */ RowOrColumn)\n/* harmony export */ });\n/* harmony import */ var _config_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config/config */ \"./node_modules/golden-layout/dist/esm/ts/config/config.js\");\n/* harmony import */ var _controls_splitter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../controls/splitter */ \"./node_modules/golden-layout/dist/esm/ts/controls/splitter.js\");\n/* harmony import */ var _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors/internal-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js\");\n/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/types */ \"./node_modules/golden-layout/dist/esm/ts/utils/types.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/golden-layout/dist/esm/ts/utils/utils.js\");\n/* harmony import */ var _content_item__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./content-item */ \"./node_modules/golden-layout/dist/esm/ts/items/content-item.js\");\n\n\n\n\n\n\n/** @public */\nclass RowOrColumn extends _content_item__WEBPACK_IMPORTED_MODULE_0__.ContentItem {\n    /** @internal */\n    constructor(isColumn, layoutManager, config, \n    /** @internal */\n    _rowOrColumnParent) {\n        super(layoutManager, config, _rowOrColumnParent, RowOrColumn.createElement(document, isColumn));\n        this._rowOrColumnParent = _rowOrColumnParent;\n        /** @internal */\n        this._splitter = [];\n        this.isRow = !isColumn;\n        this.isColumn = isColumn;\n        this._childElementContainer = this.element;\n        this._splitterSize = layoutManager.layoutConfig.dimensions.borderWidth;\n        this._splitterGrabSize = layoutManager.layoutConfig.dimensions.borderGrabWidth;\n        this._isColumn = isColumn;\n        this._dimension = isColumn ? 'height' : 'width';\n        this._splitterPosition = null;\n        this._splitterMinPosition = null;\n        this._splitterMaxPosition = null;\n        switch (config.type) {\n            case _utils_types__WEBPACK_IMPORTED_MODULE_1__.ItemType.row:\n            case _utils_types__WEBPACK_IMPORTED_MODULE_1__.ItemType.column:\n                this._configType = config.type;\n                break;\n            default:\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__.AssertError('ROCCCT00925');\n        }\n    }\n    newComponent(componentType, componentState, title, index) {\n        const itemConfig = {\n            type: 'component',\n            componentType,\n            componentState,\n            title,\n        };\n        return this.newItem(itemConfig, index);\n    }\n    addComponent(componentType, componentState, title, index) {\n        const itemConfig = {\n            type: 'component',\n            componentType,\n            componentState,\n            title,\n        };\n        return this.addItem(itemConfig, index);\n    }\n    newItem(itemConfig, index) {\n        index = this.addItem(itemConfig, index);\n        const createdItem = this.contentItems[index];\n        if (_content_item__WEBPACK_IMPORTED_MODULE_0__.ContentItem.isStack(createdItem) && (_config_config__WEBPACK_IMPORTED_MODULE_3__.ItemConfig.isComponent(itemConfig))) {\n            // createdItem is a Stack which was created to hold wanted component.  Return component\n            return createdItem.contentItems[0];\n        }\n        else {\n            return createdItem;\n        }\n    }\n    addItem(itemConfig, index) {\n        this.layoutManager.checkMinimiseMaximisedStack();\n        const resolvedItemConfig = _config_config__WEBPACK_IMPORTED_MODULE_3__.ItemConfig.resolve(itemConfig, false);\n        const contentItem = this.layoutManager.createAndInitContentItem(resolvedItemConfig, this);\n        return this.addChild(contentItem, index, false);\n    }\n    /**\n     * Add a new contentItem to the Row or Column\n     *\n     * @param contentItem -\n     * @param index - The position of the new item within the Row or Column.\n     *                If no index is provided the item will be added to the end\n     * @param suspendResize - If true the items won't be resized. This will leave the item in\n     *                        an inconsistent state and is only intended to be used if multiple\n     *                        children need to be added in one go and resize is called afterwards\n     *\n     * @returns\n     */\n    addChild(contentItem, index, suspendResize) {\n        // contentItem = this.layoutManager._$normalizeContentItem(contentItem, this);\n        if (index === undefined) {\n            index = this.contentItems.length;\n        }\n        if (this.contentItems.length > 0) {\n            const splitterElement = this.createSplitter(Math.max(0, index - 1)).element;\n            if (index > 0) {\n                this.contentItems[index - 1].element.insertAdjacentElement('afterend', splitterElement);\n                splitterElement.insertAdjacentElement('afterend', contentItem.element);\n            }\n            else {\n                this.contentItems[0].element.insertAdjacentElement('beforebegin', splitterElement);\n                splitterElement.insertAdjacentElement('beforebegin', contentItem.element);\n            }\n        }\n        else {\n            this._childElementContainer.appendChild(contentItem.element);\n        }\n        super.addChild(contentItem, index);\n        const newItemSize = (1 / this.contentItems.length) * 100;\n        if (suspendResize === true) {\n            this.emitBaseBubblingEvent('stateChanged');\n            return index;\n        }\n        for (let i = 0; i < this.contentItems.length; i++) {\n            const indexedContentItem = this.contentItems[i];\n            if (indexedContentItem === contentItem) {\n                contentItem.size = newItemSize;\n            }\n            else {\n                const itemSize = indexedContentItem.size *= (100 - newItemSize) / 100;\n                indexedContentItem.size = itemSize;\n            }\n        }\n        this.updateSize(false);\n        this.emitBaseBubblingEvent('stateChanged');\n        return index;\n    }\n    /**\n     * Removes a child of this element\n     *\n     * @param contentItem -\n     * @param keepChild - If true the child will be removed, but not destroyed\n     *\n     */\n    removeChild(contentItem, keepChild) {\n        const index = this.contentItems.indexOf(contentItem);\n        const splitterIndex = Math.max(index - 1, 0);\n        if (index === -1) {\n            throw new Error('Can\\'t remove child. ContentItem is not child of this Row or Column');\n        }\n        /**\n         * Remove the splitter before the item or after if the item happens\n         * to be the first in the row/column\n         */\n        if (this._splitter[splitterIndex]) {\n            this._splitter[splitterIndex].destroy();\n            this._splitter.splice(splitterIndex, 1);\n        }\n        super.removeChild(contentItem, keepChild);\n        if (this.contentItems.length === 1 && this.isClosable === true) {\n            const childItem = this.contentItems[0];\n            this.contentItems.length = 0;\n            this._rowOrColumnParent.replaceChild(this, childItem, true);\n        }\n        else {\n            this.updateSize(false);\n            this.emitBaseBubblingEvent('stateChanged');\n        }\n    }\n    /**\n     * Replaces a child of this Row or Column with another contentItem\n     */\n    replaceChild(oldChild, newChild) {\n        const size = oldChild.size;\n        super.replaceChild(oldChild, newChild);\n        newChild.size = size;\n        this.updateSize(false);\n        this.emitBaseBubblingEvent('stateChanged');\n    }\n    /**\n     * Called whenever the dimensions of this item or one of its parents change\n     */\n    updateSize(force) {\n        this.layoutManager.beginVirtualSizedContainerAdding();\n        try {\n            this.updateNodeSize();\n            this.updateContentItemsSize(force);\n        }\n        finally {\n            this.layoutManager.endVirtualSizedContainerAdding();\n        }\n    }\n    /**\n     * Invoked recursively by the layout manager. ContentItem.init appends\n     * the contentItem's DOM elements to the container, RowOrColumn init adds splitters\n     * in between them\n     * @internal\n     */\n    init() {\n        if (this.isInitialised === true)\n            return;\n        this.updateNodeSize();\n        for (let i = 0; i < this.contentItems.length; i++) {\n            this._childElementContainer.appendChild(this.contentItems[i].element);\n        }\n        super.init();\n        for (let i = 0; i < this.contentItems.length - 1; i++) {\n            this.contentItems[i].element.insertAdjacentElement('afterend', this.createSplitter(i).element);\n        }\n        this.initContentItems();\n    }\n    toConfig() {\n        const result = {\n            type: this.type,\n            content: this.calculateConfigContent(),\n            size: this.size,\n            sizeUnit: this.sizeUnit,\n            minSize: this.minSize,\n            minSizeUnit: this.minSizeUnit,\n            id: this.id,\n            isClosable: this.isClosable,\n        };\n        return result;\n    }\n    /** @internal */\n    setParent(parent) {\n        this._rowOrColumnParent = parent;\n        super.setParent(parent);\n    }\n    /** @internal */\n    updateNodeSize() {\n        if (this.contentItems.length > 0) {\n            this.calculateRelativeSizes();\n            this.setAbsoluteSizes();\n        }\n        this.emitBaseBubblingEvent('stateChanged');\n        this.emit('resize');\n    }\n    /**\n     * Turns the relative sizes calculated by calculateRelativeSizes into\n     * absolute pixel values and applies them to the children's DOM elements\n     *\n     * Assigns additional pixels to counteract Math.floor\n     * @internal\n     */\n    setAbsoluteSizes() {\n        const absoluteSizes = this.calculateAbsoluteSizes();\n        for (let i = 0; i < this.contentItems.length; i++) {\n            if (absoluteSizes.additionalPixel - i > 0) {\n                absoluteSizes.itemSizes[i]++;\n            }\n            if (this._isColumn) {\n                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.setElementWidth)(this.contentItems[i].element, absoluteSizes.crossAxisSize);\n                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.setElementHeight)(this.contentItems[i].element, absoluteSizes.itemSizes[i]);\n            }\n            else {\n                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.setElementWidth)(this.contentItems[i].element, absoluteSizes.itemSizes[i]);\n                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.setElementHeight)(this.contentItems[i].element, absoluteSizes.crossAxisSize);\n            }\n        }\n    }\n    /**\n     * Calculates the absolute sizes of all of the children of this Item.\n     * @returns Set with absolute sizes and additional pixels.\n     * @internal\n     */\n    calculateAbsoluteSizes() {\n        const totalSplitterSize = (this.contentItems.length - 1) * this._splitterSize;\n        const { width: elementWidth, height: elementHeight } = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.getElementWidthAndHeight)(this.element);\n        let totalSize;\n        let crossAxisSize;\n        if (this._isColumn) {\n            totalSize = elementHeight - totalSplitterSize;\n            crossAxisSize = elementWidth;\n        }\n        else {\n            totalSize = elementWidth - totalSplitterSize;\n            crossAxisSize = elementHeight;\n        }\n        let totalAssigned = 0;\n        const itemSizes = [];\n        for (let i = 0; i < this.contentItems.length; i++) {\n            const contentItem = this.contentItems[i];\n            let itemSize;\n            if (contentItem.sizeUnit === _utils_types__WEBPACK_IMPORTED_MODULE_1__.SizeUnitEnum.Percent) {\n                itemSize = Math.floor(totalSize * (contentItem.size / 100));\n            }\n            else {\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__.AssertError('ROCCAS6692');\n            }\n            totalAssigned += itemSize;\n            itemSizes.push(itemSize);\n        }\n        const additionalPixel = Math.floor(totalSize - totalAssigned);\n        return {\n            itemSizes,\n            additionalPixel,\n            totalSize,\n            crossAxisSize,\n        };\n    }\n    /**\n     * Calculates the relative sizes of all children of this Item. The logic\n     * is as follows:\n     *\n     * - Add up the total size of all items that have a configured size\n     *\n     * - If the total == 100 (check for floating point errors)\n     *        Excellent, job done\n     *\n     * - If the total is \\> 100,\n     *        set the size of items without set dimensions to 1/3 and add this to the total\n     *        set the size off all items so that the total is hundred relative to their original size\n     *\n     * - If the total is \\< 100\n     *        If there are items without set dimensions, distribute the remainder to 100 evenly between them\n     *        If there are no items without set dimensions, increase all items sizes relative to\n     *        their original size so that they add up to 100\n     *\n     * @internal\n     */\n    calculateRelativeSizes() {\n        let total = 0;\n        const itemsWithFractionalSize = [];\n        let totalFractionalSize = 0;\n        for (let i = 0; i < this.contentItems.length; i++) {\n            const contentItem = this.contentItems[i];\n            const sizeUnit = contentItem.sizeUnit;\n            switch (sizeUnit) {\n                case _utils_types__WEBPACK_IMPORTED_MODULE_1__.SizeUnitEnum.Percent: {\n                    total += contentItem.size;\n                    break;\n                }\n                case _utils_types__WEBPACK_IMPORTED_MODULE_1__.SizeUnitEnum.Fractional: {\n                    itemsWithFractionalSize.push(contentItem);\n                    totalFractionalSize += contentItem.size;\n                    break;\n                }\n                default:\n                    throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__.AssertError('ROCCRS49110', JSON.stringify(contentItem));\n            }\n        }\n        /**\n         * Everything adds up to hundred, all good :-)\n         */\n        if (Math.round(total) === 100) {\n            this.respectMinItemSize();\n            return;\n        }\n        else {\n            /**\n             * Allocate the remaining size to the items with a fractional size\n             */\n            if (Math.round(total) < 100 && itemsWithFractionalSize.length > 0) {\n                const fractionalAllocatedSize = 100 - total;\n                for (let i = 0; i < itemsWithFractionalSize.length; i++) {\n                    const contentItem = itemsWithFractionalSize[i];\n                    contentItem.size = fractionalAllocatedSize * (contentItem.size / totalFractionalSize);\n                    contentItem.sizeUnit = _utils_types__WEBPACK_IMPORTED_MODULE_1__.SizeUnitEnum.Percent;\n                }\n                this.respectMinItemSize();\n                return;\n            }\n            else {\n                /**\n                 * If the total is > 100, but there are also items with a fractional size, assign another 50%\n                 * to the fractional items\n                 *\n                 * This will be reset in the next step\n                 */\n                if (Math.round(total) > 100 && itemsWithFractionalSize.length > 0) {\n                    for (let i = 0; i < itemsWithFractionalSize.length; i++) {\n                        const contentItem = itemsWithFractionalSize[i];\n                        contentItem.size = 50 * (contentItem.size / totalFractionalSize);\n                        contentItem.sizeUnit = _utils_types__WEBPACK_IMPORTED_MODULE_1__.SizeUnitEnum.Percent;\n                    }\n                    total += 50;\n                }\n                /**\n                 * Set every items size relative to 100 relative to its size to total\n                 */\n                for (let i = 0; i < this.contentItems.length; i++) {\n                    const contentItem = this.contentItems[i];\n                    contentItem.size = (contentItem.size / total) * 100;\n                }\n                this.respectMinItemSize();\n            }\n        }\n    }\n    /**\n     * Adjusts the column widths to respect the dimensions minItemWidth if set.\n     * @internal\n     */\n    respectMinItemSize() {\n        const minItemSize = this.calculateContentItemMinSize(this);\n        if (minItemSize <= 0 || this.contentItems.length <= 1) {\n            return;\n        }\n        else {\n            let totalOverMin = 0;\n            let totalUnderMin = 0;\n            const entriesOverMin = [];\n            const allEntries = [];\n            const absoluteSizes = this.calculateAbsoluteSizes();\n            /**\n             * Figure out how much we are under the min item size total and how much room we have to use.\n             */\n            for (let i = 0; i < absoluteSizes.itemSizes.length; i++) {\n                const itemSize = absoluteSizes.itemSizes[i];\n                let entry;\n                if (itemSize < minItemSize) {\n                    totalUnderMin += minItemSize - itemSize;\n                    entry = {\n                        size: minItemSize\n                    };\n                }\n                else {\n                    totalOverMin += itemSize - minItemSize;\n                    entry = {\n                        size: itemSize\n                    };\n                    entriesOverMin.push(entry);\n                }\n                allEntries.push(entry);\n            }\n            /**\n             * If there is nothing under min, or there is not enough over to make up the difference, do nothing.\n             */\n            if (totalUnderMin === 0 || totalUnderMin > totalOverMin) {\n                return;\n            }\n            else {\n                /**\n                 * Evenly reduce all columns that are over the min item width to make up the difference.\n                 */\n                const reducePercent = totalUnderMin / totalOverMin;\n                let remainingSize = totalUnderMin;\n                for (let i = 0; i < entriesOverMin.length; i++) {\n                    const entry = entriesOverMin[i];\n                    const reducedSize = Math.round((entry.size - minItemSize) * reducePercent);\n                    remainingSize -= reducedSize;\n                    entry.size -= reducedSize;\n                }\n                /**\n                 * Take anything remaining from the last item.\n                 */\n                if (remainingSize !== 0) {\n                    allEntries[allEntries.length - 1].size -= remainingSize;\n                }\n                /**\n                 * Set every items size relative to 100 relative to its size to total\n                 */\n                for (let i = 0; i < this.contentItems.length; i++) {\n                    const contentItem = this.contentItems[i];\n                    contentItem.size = (allEntries[i].size / absoluteSizes.totalSize) * 100;\n                }\n            }\n        }\n    }\n    /**\n     * Instantiates a new Splitter, binds events to it and adds\n     * it to the array of splitters at the position specified as the index argument\n     *\n     * What it doesn't do though is append the splitter to the DOM\n     *\n     * @param index - The position of the splitter\n     *\n     * @returns\n     * @internal\n     */\n    createSplitter(index) {\n        const splitter = new _controls_splitter__WEBPACK_IMPORTED_MODULE_5__.Splitter(this._isColumn, this._splitterSize, this._splitterGrabSize);\n        splitter.on('drag', (offsetX, offsetY) => this.onSplitterDrag(splitter, offsetX, offsetY));\n        splitter.on('dragStop', () => this.onSplitterDragStop(splitter));\n        splitter.on('dragStart', () => this.onSplitterDragStart(splitter));\n        this._splitter.splice(index, 0, splitter);\n        return splitter;\n    }\n    /**\n     * Locates the instance of Splitter in the array of\n     * registered splitters and returns a map containing the contentItem\n     * before and after the splitters, both of which are affected if the\n     * splitter is moved\n     *\n     * @returns A map of contentItems that the splitter affects\n     * @internal\n     */\n    getSplitItems(splitter) {\n        const index = this._splitter.indexOf(splitter);\n        return {\n            before: this.contentItems[index],\n            after: this.contentItems[index + 1]\n        };\n    }\n    calculateContentItemMinSize(contentItem) {\n        const minSize = contentItem.minSize;\n        if (minSize !== undefined) {\n            if (contentItem.minSizeUnit === _utils_types__WEBPACK_IMPORTED_MODULE_1__.SizeUnitEnum.Pixel) {\n                return minSize;\n            }\n            else {\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__.AssertError('ROCGMD98831', JSON.stringify(contentItem));\n            }\n        }\n        else {\n            const dimensions = this.layoutManager.layoutConfig.dimensions;\n            return this._isColumn ? dimensions.defaultMinItemHeight : dimensions.defaultMinItemWidth;\n        }\n    }\n    /**\n     * Gets the minimum dimensions for the given item configuration array\n     * @internal\n     */\n    calculateContentItemsTotalMinSize(contentItems) {\n        let totalMinSize = 0;\n        for (const contentItem of contentItems) {\n            totalMinSize += this.calculateContentItemMinSize(contentItem);\n        }\n        return totalMinSize;\n    }\n    /**\n     * Invoked when a splitter's dragListener fires dragStart. Calculates the splitters\n     * movement area once (so that it doesn't need calculating on every mousemove event)\n     * @internal\n     */\n    onSplitterDragStart(splitter) {\n        const items = this.getSplitItems(splitter);\n        const beforeWidth = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.pixelsToNumber)(items.before.element.style[this._dimension]);\n        const afterSize = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.pixelsToNumber)(items.after.element.style[this._dimension]);\n        const beforeMinSize = this.calculateContentItemsTotalMinSize(items.before.contentItems);\n        const afterMinSize = this.calculateContentItemsTotalMinSize(items.after.contentItems);\n        this._splitterPosition = 0;\n        this._splitterMinPosition = -1 * (beforeWidth - beforeMinSize);\n        this._splitterMaxPosition = afterSize - afterMinSize;\n    }\n    /**\n     * Invoked when a splitter's DragListener fires drag. Updates the splitter's DOM position,\n     * but not the sizes of the elements the splitter controls in order to minimize resize events\n     *\n     * @param splitter -\n     * @param offsetX - Relative pixel values to the splitter's original position. Can be negative\n     * @param offsetY - Relative pixel values to the splitter's original position. Can be negative\n     * @internal\n     */\n    onSplitterDrag(splitter, offsetX, offsetY) {\n        let offset = this._isColumn ? offsetY : offsetX;\n        if (this._splitterMinPosition === null || this._splitterMaxPosition === null) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__.UnexpectedNullError('ROCOSD59226');\n        }\n        offset = Math.max(offset, this._splitterMinPosition);\n        offset = Math.min(offset, this._splitterMaxPosition);\n        this._splitterPosition = offset;\n        const offsetPixels = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.numberToPixels)(offset);\n        if (this._isColumn) {\n            splitter.element.style.top = offsetPixels;\n        }\n        else {\n            splitter.element.style.left = offsetPixels;\n        }\n    }\n    /**\n     * Invoked when a splitter's DragListener fires dragStop. Resets the splitters DOM position,\n     * and applies the new sizes to the elements before and after the splitter and their children\n     * on the next animation frame\n     * @internal\n     */\n    onSplitterDragStop(splitter) {\n        if (this._splitterPosition === null) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_2__.UnexpectedNullError('ROCOSDS66932');\n        }\n        else {\n            const items = this.getSplitItems(splitter);\n            const sizeBefore = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.pixelsToNumber)(items.before.element.style[this._dimension]);\n            const sizeAfter = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.pixelsToNumber)(items.after.element.style[this._dimension]);\n            const splitterPositionInRange = (this._splitterPosition + sizeBefore) / (sizeBefore + sizeAfter);\n            const totalRelativeSize = items.before.size + items.after.size;\n            items.before.size = splitterPositionInRange * totalRelativeSize;\n            items.after.size = (1 - splitterPositionInRange) * totalRelativeSize;\n            splitter.element.style.top = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.numberToPixels)(0);\n            splitter.element.style.left = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.numberToPixels)(0);\n            globalThis.requestAnimationFrame(() => this.updateSize(false));\n        }\n    }\n}\n/** @public */\n(function (RowOrColumn) {\n    /** @internal */\n    function getElementDimensionSize(element, dimension) {\n        if (dimension === 'width') {\n            return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.getElementWidth)(element);\n        }\n        else {\n            return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.getElementHeight)(element);\n        }\n    }\n    RowOrColumn.getElementDimensionSize = getElementDimensionSize;\n    /** @internal */\n    function setElementDimensionSize(element, dimension, value) {\n        if (dimension === 'width') {\n            return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.setElementWidth)(element, value);\n        }\n        else {\n            return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_4__.setElementHeight)(element, value);\n        }\n    }\n    RowOrColumn.setElementDimensionSize = setElementDimensionSize;\n    /** @internal */\n    function createElement(document, isColumn) {\n        const element = document.createElement('div');\n        element.classList.add(\"lm_item\" /* Item */);\n        if (isColumn) {\n            element.classList.add(\"lm_column\" /* Column */);\n        }\n        else {\n            element.classList.add(\"lm_row\" /* Row */);\n        }\n        return element;\n    }\n    RowOrColumn.createElement = createElement;\n})(RowOrColumn || (RowOrColumn = {}));\n//# sourceMappingURL=row-or-column.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/items/row-or-column.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/items/stack.js":
/*!***************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/items/stack.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Stack: () => (/* binding */ Stack)\n/* harmony export */ });\n/* harmony import */ var _config_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../config/config */ \"./node_modules/golden-layout/dist/esm/ts/config/config.js\");\n/* harmony import */ var _config_resolved_config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../config/resolved-config */ \"./node_modules/golden-layout/dist/esm/ts/config/resolved-config.js\");\n/* harmony import */ var _controls_header__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../controls/header */ \"./node_modules/golden-layout/dist/esm/ts/controls/header.js\");\n/* harmony import */ var _errors_internal_error__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../errors/internal-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js\");\n/* harmony import */ var _utils_event_emitter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/event-emitter */ \"./node_modules/golden-layout/dist/esm/ts/utils/event-emitter.js\");\n/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/types */ \"./node_modules/golden-layout/dist/esm/ts/utils/types.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/golden-layout/dist/esm/ts/utils/utils.js\");\n/* harmony import */ var _component_item__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./component-item */ \"./node_modules/golden-layout/dist/esm/ts/items/component-item.js\");\n/* harmony import */ var _component_parentable_item__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component-parentable-item */ \"./node_modules/golden-layout/dist/esm/ts/items/component-parentable-item.js\");\n/* harmony import */ var _content_item__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./content-item */ \"./node_modules/golden-layout/dist/esm/ts/items/content-item.js\");\n\n\n\n\n\n\n\n\n\n\n/** @public */\nclass Stack extends _component_parentable_item__WEBPACK_IMPORTED_MODULE_0__.ComponentParentableItem {\n    /** @internal */\n    constructor(layoutManager, config, parent) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;\n        super(layoutManager, config, parent, Stack.createElement(document));\n        /** @internal */\n        this._headerSideChanged = false;\n        /** @internal */\n        this._resizeListener = () => this.handleResize();\n        /** @internal */\n        this._maximisedListener = () => this.handleMaximised();\n        /** @internal */\n        this._minimisedListener = () => this.handleMinimised();\n        this._headerConfig = config.header;\n        const layoutHeaderConfig = layoutManager.layoutConfig.header;\n        const configContent = config.content;\n        // If stack has only one component, then we can also check this for header settings\n        let componentHeaderConfig;\n        if (configContent.length !== 1) {\n            componentHeaderConfig = undefined;\n        }\n        else {\n            const firstChildItemConfig = configContent[0];\n            componentHeaderConfig = firstChildItemConfig.header; // will be undefined if not component (and wont be stack)\n        }\n        this._initialWantMaximise = config.maximised;\n        this._initialActiveItemIndex = (_a = config.activeItemIndex) !== null && _a !== void 0 ? _a : 0; // make sure defined\n        // check for defined value for each item in order of Stack (this Item), Component (first child), Manager.\n        const show = (_d = (_c = (_b = this._headerConfig) === null || _b === void 0 ? void 0 : _b.show) !== null && _c !== void 0 ? _c : componentHeaderConfig === null || componentHeaderConfig === void 0 ? void 0 : componentHeaderConfig.show) !== null && _d !== void 0 ? _d : layoutHeaderConfig.show;\n        const popout = (_g = (_f = (_e = this._headerConfig) === null || _e === void 0 ? void 0 : _e.popout) !== null && _f !== void 0 ? _f : componentHeaderConfig === null || componentHeaderConfig === void 0 ? void 0 : componentHeaderConfig.popout) !== null && _g !== void 0 ? _g : layoutHeaderConfig.popout;\n        const maximise = (_k = (_j = (_h = this._headerConfig) === null || _h === void 0 ? void 0 : _h.maximise) !== null && _j !== void 0 ? _j : componentHeaderConfig === null || componentHeaderConfig === void 0 ? void 0 : componentHeaderConfig.maximise) !== null && _k !== void 0 ? _k : layoutHeaderConfig.maximise;\n        const close = (_o = (_m = (_l = this._headerConfig) === null || _l === void 0 ? void 0 : _l.close) !== null && _m !== void 0 ? _m : componentHeaderConfig === null || componentHeaderConfig === void 0 ? void 0 : componentHeaderConfig.close) !== null && _o !== void 0 ? _o : layoutHeaderConfig.close;\n        const minimise = (_r = (_q = (_p = this._headerConfig) === null || _p === void 0 ? void 0 : _p.minimise) !== null && _q !== void 0 ? _q : componentHeaderConfig === null || componentHeaderConfig === void 0 ? void 0 : componentHeaderConfig.minimise) !== null && _r !== void 0 ? _r : layoutHeaderConfig.minimise;\n        const tabDropdown = (_u = (_t = (_s = this._headerConfig) === null || _s === void 0 ? void 0 : _s.tabDropdown) !== null && _t !== void 0 ? _t : componentHeaderConfig === null || componentHeaderConfig === void 0 ? void 0 : componentHeaderConfig.tabDropdown) !== null && _u !== void 0 ? _u : layoutHeaderConfig.tabDropdown;\n        this._maximisedEnabled = maximise !== false;\n        const headerSettings = {\n            show: show !== false,\n            side: show === false ? _utils_types__WEBPACK_IMPORTED_MODULE_1__.Side.top : show,\n            popoutEnabled: popout !== false,\n            popoutLabel: popout === false ? '' : popout,\n            maximiseEnabled: this._maximisedEnabled,\n            maximiseLabel: maximise === false ? '' : maximise,\n            closeEnabled: close !== false,\n            closeLabel: close === false ? '' : close,\n            minimiseEnabled: true,\n            minimiseLabel: minimise,\n            tabDropdownEnabled: tabDropdown !== false,\n            tabDropdownLabel: tabDropdown === false ? '' : tabDropdown,\n        };\n        this._header = new _controls_header__WEBPACK_IMPORTED_MODULE_2__.Header(layoutManager, this, headerSettings, config.isClosable && close !== false, () => this.getActiveComponentItem(), () => this.remove(), () => this.handlePopoutEvent(), () => this.toggleMaximise(), (ev) => this.handleHeaderClickEvent(ev), (ev) => this.handleHeaderTouchStartEvent(ev), (item) => this.handleHeaderComponentRemoveEvent(item), (item) => this.handleHeaderComponentFocusEvent(item), (x, y, dragListener, item) => this.handleHeaderComponentStartDragEvent(x, y, dragListener, item));\n        // this._dropZones = {};\n        this.isStack = true;\n        this._childElementContainer = document.createElement('section');\n        this._childElementContainer.classList.add(\"lm_items\" /* Items */);\n        this.on('resize', this._resizeListener);\n        if (this._maximisedEnabled) {\n            this.on('maximised', this._maximisedListener);\n            this.on('minimised', this._minimisedListener);\n        }\n        this.element.appendChild(this._header.element);\n        this.element.appendChild(this._childElementContainer);\n        this.setupHeaderPosition();\n        this._header.updateClosability();\n    }\n    get childElementContainer() { return this._childElementContainer; }\n    get header() { return this._header; }\n    get headerShow() { return this._header.show; }\n    get headerSide() { return this._header.side; }\n    get headerLeftRightSided() { return this._header.leftRightSided; }\n    /** @internal */\n    get contentAreaDimensions() { return this._contentAreaDimensions; }\n    /** @internal */\n    get initialWantMaximise() { return this._initialWantMaximise; }\n    get isMaximised() { return this === this.layoutManager.maximisedStack; }\n    get stackParent() {\n        if (!this.parent) {\n            throw new Error('Stack should always have a parent');\n        }\n        return this.parent;\n    }\n    /** @internal */\n    updateSize(force) {\n        this.layoutManager.beginVirtualSizedContainerAdding();\n        try {\n            this.updateNodeSize();\n            this.updateContentItemsSize(force);\n        }\n        finally {\n            this.layoutManager.endVirtualSizedContainerAdding();\n        }\n    }\n    /** @internal */\n    init() {\n        if (this.isInitialised === true)\n            return;\n        this.updateNodeSize();\n        for (let i = 0; i < this.contentItems.length; i++) {\n            this._childElementContainer.appendChild(this.contentItems[i].element);\n        }\n        super.init();\n        const contentItems = this.contentItems;\n        const contentItemCount = contentItems.length;\n        if (contentItemCount > 0) { // contentItemCount will be 0 on drag drop\n            if (this._initialActiveItemIndex < 0 || this._initialActiveItemIndex >= contentItemCount) {\n                throw new Error(`ActiveItemIndex out of range: ${this._initialActiveItemIndex} id: ${this.id}`);\n            }\n            else {\n                for (let i = 0; i < contentItemCount; i++) {\n                    const contentItem = contentItems[i];\n                    if (!(contentItem instanceof _component_item__WEBPACK_IMPORTED_MODULE_3__.ComponentItem)) {\n                        throw new Error(`Stack Content Item is not of type ComponentItem: ${i} id: ${this.id}`);\n                    }\n                    else {\n                        this._header.createTab(contentItem, i);\n                        contentItem.hide();\n                        contentItem.container.setBaseLogicalZIndex();\n                    }\n                }\n                this.setActiveComponentItem(contentItems[this._initialActiveItemIndex], false);\n                this._header.updateTabSizes();\n            }\n        }\n        this._header.updateClosability();\n        this.initContentItems();\n    }\n    /** @deprecated Use {@link (Stack:class).setActiveComponentItem} */\n    setActiveContentItem(item) {\n        if (!_content_item__WEBPACK_IMPORTED_MODULE_4__.ContentItem.isComponentItem(item)) {\n            throw new Error('Stack.setActiveContentItem: item is not a ComponentItem');\n        }\n        else {\n            this.setActiveComponentItem(item, false);\n        }\n    }\n    setActiveComponentItem(componentItem, focus, suppressFocusEvent = false) {\n        if (this._activeComponentItem !== componentItem) {\n            if (this.contentItems.indexOf(componentItem) === -1) {\n                throw new Error('componentItem is not a child of this stack');\n            }\n            else {\n                this.layoutManager.beginSizeInvalidation();\n                try {\n                    if (this._activeComponentItem !== undefined) {\n                        this._activeComponentItem.hide();\n                    }\n                    this._activeComponentItem = componentItem;\n                    this._header.processActiveComponentChanged(componentItem);\n                    componentItem.show();\n                }\n                finally {\n                    this.layoutManager.endSizeInvalidation();\n                }\n                this.emit('activeContentItemChanged', componentItem);\n                this.layoutManager.emit('activeContentItemChanged', componentItem);\n                this.emitStateChangedEvent();\n            }\n        }\n        if (this.focused || focus) {\n            this.layoutManager.setFocusedComponentItem(componentItem, suppressFocusEvent);\n        }\n    }\n    /** @deprecated Use {@link (Stack:class).getActiveComponentItem} */\n    getActiveContentItem() {\n        var _a;\n        return (_a = this.getActiveComponentItem()) !== null && _a !== void 0 ? _a : null;\n    }\n    getActiveComponentItem() {\n        return this._activeComponentItem;\n    }\n    /** @internal */\n    focusActiveContentItem() {\n        var _a;\n        (_a = this._activeComponentItem) === null || _a === void 0 ? void 0 : _a.focus();\n    }\n    /** @internal */\n    setFocusedValue(value) {\n        this._header.applyFocusedValue(value);\n        super.setFocusedValue(value);\n    }\n    /** @internal */\n    setRowColumnClosable(value) {\n        this._header.setRowColumnClosable(value);\n    }\n    newComponent(componentType, componentState, title, index) {\n        const itemConfig = {\n            type: 'component',\n            componentType,\n            componentState,\n            title,\n        };\n        return this.newItem(itemConfig, index);\n    }\n    addComponent(componentType, componentState, title, index) {\n        const itemConfig = {\n            type: 'component',\n            componentType,\n            componentState,\n            title,\n        };\n        return this.addItem(itemConfig, index);\n    }\n    newItem(itemConfig, index) {\n        index = this.addItem(itemConfig, index);\n        return this.contentItems[index];\n    }\n    addItem(itemConfig, index) {\n        this.layoutManager.checkMinimiseMaximisedStack();\n        const resolvedItemConfig = _config_config__WEBPACK_IMPORTED_MODULE_5__.ItemConfig.resolve(itemConfig, false);\n        const contentItem = this.layoutManager.createAndInitContentItem(resolvedItemConfig, this);\n        return this.addChild(contentItem, index);\n    }\n    addChild(contentItem, index, focus = false) {\n        if (index !== undefined && index > this.contentItems.length) {\n            index -= 1;\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_6__.AssertError('SAC99728'); // undisplayChild() removed so this condition should no longer occur\n        }\n        if (!(contentItem instanceof _component_item__WEBPACK_IMPORTED_MODULE_3__.ComponentItem)) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_6__.AssertError('SACC88532'); // Stacks can only have Component children\n        }\n        else {\n            index = super.addChild(contentItem, index);\n            this._childElementContainer.appendChild(contentItem.element);\n            this._header.createTab(contentItem, index);\n            this.setActiveComponentItem(contentItem, focus);\n            this._header.updateTabSizes();\n            this.updateSize(false);\n            contentItem.container.setBaseLogicalZIndex();\n            this._header.updateClosability();\n            this.emitStateChangedEvent();\n            return index;\n        }\n    }\n    removeChild(contentItem, keepChild) {\n        const componentItem = contentItem;\n        const index = this.contentItems.indexOf(componentItem);\n        const stackWillBeDeleted = this.contentItems.length === 1;\n        if (this._activeComponentItem === componentItem) {\n            if (componentItem.focused) {\n                componentItem.blur();\n            }\n            if (!stackWillBeDeleted) {\n                // At this point we're already sure we have at least one content item left *after*\n                // removing contentItem, so we can safely assume index 1 is a valid one if\n                // the index of contentItem is 0, otherwise we just use the previous content item.\n                const newActiveComponentIdx = index === 0 ? 1 : index - 1;\n                this.setActiveComponentItem(this.contentItems[newActiveComponentIdx], false);\n            }\n        }\n        this._header.removeTab(componentItem);\n        super.removeChild(componentItem, keepChild);\n        if (!stackWillBeDeleted) {\n            this._header.updateClosability();\n        }\n        this.emitStateChangedEvent();\n    }\n    /**\n     * Maximises the Item or minimises it if it is already maximised\n     */\n    toggleMaximise() {\n        if (this.isMaximised) {\n            this.minimise();\n        }\n        else {\n            this.maximise();\n        }\n    }\n    maximise() {\n        if (!this.isMaximised) {\n            this.layoutManager.setMaximisedStack(this);\n            const contentItems = this.contentItems;\n            const contentItemCount = contentItems.length;\n            for (let i = 0; i < contentItemCount; i++) {\n                const contentItem = contentItems[i];\n                if (contentItem instanceof _component_item__WEBPACK_IMPORTED_MODULE_3__.ComponentItem) {\n                    contentItem.enterStackMaximised();\n                }\n                else {\n                    throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_6__.AssertError('SMAXI87773');\n                }\n            }\n            this.emitStateChangedEvent();\n        }\n    }\n    minimise() {\n        if (this.isMaximised) {\n            this.layoutManager.setMaximisedStack(undefined);\n            const contentItems = this.contentItems;\n            const contentItemCount = contentItems.length;\n            for (let i = 0; i < contentItemCount; i++) {\n                const contentItem = contentItems[i];\n                if (contentItem instanceof _component_item__WEBPACK_IMPORTED_MODULE_3__.ComponentItem) {\n                    contentItem.exitStackMaximised();\n                }\n                else {\n                    throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_6__.AssertError('SMINI87773');\n                }\n            }\n            this.emitStateChangedEvent();\n        }\n    }\n    /** @internal */\n    destroy() {\n        var _a;\n        if ((_a = this._activeComponentItem) === null || _a === void 0 ? void 0 : _a.focused) {\n            this._activeComponentItem.blur();\n        }\n        super.destroy();\n        this.off('resize', this._resizeListener);\n        if (this._maximisedEnabled) {\n            this.off('maximised', this._maximisedListener);\n            this.off('minimised', this._minimisedListener);\n        }\n        this._header.destroy();\n    }\n    toConfig() {\n        let activeItemIndex;\n        if (this._activeComponentItem) {\n            activeItemIndex = this.contentItems.indexOf(this._activeComponentItem);\n            if (activeItemIndex < 0) {\n                throw new Error('active component item not found in stack');\n            }\n        }\n        if (this.contentItems.length > 0 && activeItemIndex === undefined) {\n            throw new Error('expected non-empty stack to have an active component item');\n        }\n        else {\n            const result = {\n                type: 'stack',\n                content: this.calculateConfigContent(),\n                size: this.size,\n                sizeUnit: this.sizeUnit,\n                minSize: this.minSize,\n                minSizeUnit: this.minSizeUnit,\n                id: this.id,\n                isClosable: this.isClosable,\n                maximised: this.isMaximised,\n                header: this.createHeaderConfig(),\n                activeItemIndex,\n            };\n            return result;\n        }\n    }\n    /**\n     * Ok, this one is going to be the tricky one: The user has dropped a {@link (ContentItem:class)} onto this stack.\n     *\n     * It was dropped on either the stacks header or the top, right, bottom or left bit of the content area\n     * (which one of those is stored in this._dropSegment). Now, if the user has dropped on the header the case\n     * is relatively clear: We add the item to the existing stack... job done (might be good to have\n     * tab reordering at some point, but lets not sweat it right now)\n     *\n     * If the item was dropped on the content part things are a bit more complicated. If it was dropped on either the\n     * top or bottom region we need to create a new column and place the items accordingly.\n     * Unless, of course if the stack is already within a column... in which case we want\n     * to add the newly created item to the existing column...\n     * either prepend or append it, depending on wether its top or bottom.\n     *\n     * Same thing for rows and left / right drop segments... so in total there are 9 things that can potentially happen\n     * (left, top, right, bottom) * is child of the right parent (row, column) + header drop\n     *\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onDrop(contentItem, area) {\n        /*\n         * The item was dropped on the header area. Just add it as a child of this stack and\n         * get the hell out of this logic\n         */\n        if (this._dropSegment === \"header\" /* Header */) {\n            this.resetHeaderDropZone();\n            if (this._dropIndex === undefined) {\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_6__.UnexpectedUndefinedError('SODDI68990');\n            }\n            else {\n                this.addChild(contentItem, this._dropIndex);\n                return;\n            }\n        }\n        /*\n         * The stack is empty. Let's just add the element.\n         */\n        if (this._dropSegment === \"body\" /* Body */) {\n            this.addChild(contentItem, 0, true);\n            return;\n        }\n        /*\n         * The item was dropped on the top-, left-, bottom- or right- part of the content. Let's\n         * aggregate some conditions to make the if statements later on more readable\n         */\n        const isVertical = this._dropSegment === \"top\" /* Top */ || this._dropSegment === \"bottom\" /* Bottom */;\n        const isHorizontal = this._dropSegment === \"left\" /* Left */ || this._dropSegment === \"right\" /* Right */;\n        const insertBefore = this._dropSegment === \"top\" /* Top */ || this._dropSegment === \"left\" /* Left */;\n        const hasCorrectParent = (isVertical && this.stackParent.isColumn) || (isHorizontal && this.stackParent.isRow);\n        /*\n         * The content item can be either a component or a stack. If it is a component, wrap it into a stack\n         */\n        if (contentItem.isComponent) {\n            const itemConfig = _config_resolved_config__WEBPACK_IMPORTED_MODULE_7__.ResolvedStackItemConfig.createDefault();\n            itemConfig.header = this.createHeaderConfig();\n            const stack = this.layoutManager.createAndInitContentItem(itemConfig, this);\n            stack.addChild(contentItem);\n            contentItem = stack;\n        }\n        /*\n         * If the contentItem that's being dropped is not dropped on a Stack (cases which just passed above and\n         * which would wrap the contentItem in a Stack) we need to check whether contentItem is a RowOrColumn.\n         * If it is, we need to re-wrap it in a Stack like it was when it was dragged by its Tab (it was dragged!).\n         */\n        if (contentItem.type === _utils_types__WEBPACK_IMPORTED_MODULE_1__.ItemType.row || contentItem.type === _utils_types__WEBPACK_IMPORTED_MODULE_1__.ItemType.column) {\n            const itemConfig = _config_resolved_config__WEBPACK_IMPORTED_MODULE_7__.ResolvedStackItemConfig.createDefault();\n            itemConfig.header = this.createHeaderConfig();\n            const stack = this.layoutManager.createContentItem(itemConfig, this);\n            stack.addChild(contentItem);\n            contentItem = stack;\n        }\n        /*\n         * If the item is dropped on top or bottom of a column or left and right of a row, it's already\n         * layd out in the correct way. Just add it as a child\n         */\n        if (hasCorrectParent) {\n            const index = this.stackParent.contentItems.indexOf(this);\n            this.stackParent.addChild(contentItem, insertBefore ? index : index + 1, true);\n            this.size *= 0.5;\n            contentItem.size = this.size;\n            contentItem.sizeUnit = this.sizeUnit;\n            this.stackParent.updateSize(false);\n            /*\n             * This handles items that are dropped on top or bottom of a row or left / right of a column. We need\n             * to create the appropriate contentItem for them to live in\n             */\n        }\n        else {\n            const type = isVertical ? _utils_types__WEBPACK_IMPORTED_MODULE_1__.ItemType.column : _utils_types__WEBPACK_IMPORTED_MODULE_1__.ItemType.row;\n            const itemConfig = _config_resolved_config__WEBPACK_IMPORTED_MODULE_7__.ResolvedItemConfig.createDefault(type);\n            const rowOrColumn = this.layoutManager.createContentItem(itemConfig, this);\n            this.stackParent.replaceChild(this, rowOrColumn);\n            rowOrColumn.addChild(contentItem, insertBefore ? 0 : undefined, true);\n            rowOrColumn.addChild(this, insertBefore ? undefined : 0, true);\n            this.size = 50;\n            contentItem.size = 50;\n            contentItem.sizeUnit = _utils_types__WEBPACK_IMPORTED_MODULE_1__.SizeUnitEnum.Percent;\n            rowOrColumn.updateSize(false);\n        }\n    }\n    /**\n     * If the user hovers above the header part of the stack, indicate drop positions for tabs.\n     * otherwise indicate which segment of the body the dragged item would be dropped on\n     *\n     * @param x - Absolute Screen X\n     * @param y - Absolute Screen Y\n     * @internal\n     */\n    highlightDropZone(x, y) {\n        for (const key in this._contentAreaDimensions) {\n            const segment = key;\n            const area = this._contentAreaDimensions[segment].hoverArea;\n            if (area.x1 < x && area.x2 > x && area.y1 < y && area.y2 > y) {\n                if (segment === \"header\" /* Header */) {\n                    this._dropSegment = \"header\" /* Header */;\n                    this.highlightHeaderDropZone(this._header.leftRightSided ? y : x);\n                }\n                else {\n                    this.resetHeaderDropZone();\n                    this.highlightBodyDropZone(segment);\n                }\n                return;\n            }\n        }\n    }\n    /** @internal */\n    getArea() {\n        if (this.element.style.display === 'none') {\n            return null;\n        }\n        const headerArea = super.getElementArea(this._header.element);\n        const contentArea = super.getElementArea(this._childElementContainer);\n        if (headerArea === null || contentArea === null) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_6__.UnexpectedNullError('SGAHC13086');\n        }\n        const contentWidth = contentArea.x2 - contentArea.x1;\n        const contentHeight = contentArea.y2 - contentArea.y1;\n        this._contentAreaDimensions = {\n            header: {\n                hoverArea: {\n                    x1: headerArea.x1,\n                    y1: headerArea.y1,\n                    x2: headerArea.x2,\n                    y2: headerArea.y2\n                },\n                highlightArea: {\n                    x1: headerArea.x1,\n                    y1: headerArea.y1,\n                    x2: headerArea.x2,\n                    y2: headerArea.y2\n                }\n            }\n        };\n        /**\n         * Highlight the entire body if the stack is empty\n         */\n        if (this.contentItems.length === 0) {\n            this._contentAreaDimensions.body = {\n                hoverArea: {\n                    x1: contentArea.x1,\n                    y1: contentArea.y1,\n                    x2: contentArea.x2,\n                    y2: contentArea.y2\n                },\n                highlightArea: {\n                    x1: contentArea.x1,\n                    y1: contentArea.y1,\n                    x2: contentArea.x2,\n                    y2: contentArea.y2\n                }\n            };\n            return super.getElementArea(this.element);\n        }\n        else {\n            this._contentAreaDimensions.left = {\n                hoverArea: {\n                    x1: contentArea.x1,\n                    y1: contentArea.y1,\n                    x2: contentArea.x1 + contentWidth * 0.25,\n                    y2: contentArea.y2\n                },\n                highlightArea: {\n                    x1: contentArea.x1,\n                    y1: contentArea.y1,\n                    x2: contentArea.x1 + contentWidth * 0.5,\n                    y2: contentArea.y2\n                }\n            };\n            this._contentAreaDimensions.top = {\n                hoverArea: {\n                    x1: contentArea.x1 + contentWidth * 0.25,\n                    y1: contentArea.y1,\n                    x2: contentArea.x1 + contentWidth * 0.75,\n                    y2: contentArea.y1 + contentHeight * 0.5\n                },\n                highlightArea: {\n                    x1: contentArea.x1,\n                    y1: contentArea.y1,\n                    x2: contentArea.x2,\n                    y2: contentArea.y1 + contentHeight * 0.5\n                }\n            };\n            this._contentAreaDimensions.right = {\n                hoverArea: {\n                    x1: contentArea.x1 + contentWidth * 0.75,\n                    y1: contentArea.y1,\n                    x2: contentArea.x2,\n                    y2: contentArea.y2\n                },\n                highlightArea: {\n                    x1: contentArea.x1 + contentWidth * 0.5,\n                    y1: contentArea.y1,\n                    x2: contentArea.x2,\n                    y2: contentArea.y2\n                }\n            };\n            this._contentAreaDimensions.bottom = {\n                hoverArea: {\n                    x1: contentArea.x1 + contentWidth * 0.25,\n                    y1: contentArea.y1 + contentHeight * 0.5,\n                    x2: contentArea.x1 + contentWidth * 0.75,\n                    y2: contentArea.y2\n                },\n                highlightArea: {\n                    x1: contentArea.x1,\n                    y1: contentArea.y1 + contentHeight * 0.5,\n                    x2: contentArea.x2,\n                    y2: contentArea.y2\n                }\n            };\n            return super.getElementArea(this.element);\n        }\n    }\n    /**\n     * Programmatically operate with header position.\n     *\n     * @param position -\n     *\n     * @returns previous header position\n     * @internal\n     */\n    positionHeader(position) {\n        if (this._header.side !== position) {\n            this._header.setSide(position);\n            this._headerSideChanged = true;\n            this.setupHeaderPosition();\n        }\n    }\n    /** @internal */\n    updateNodeSize() {\n        if (this.element.style.display !== 'none') {\n            const content = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_8__.getElementWidthAndHeight)(this.element);\n            if (this._header.show) {\n                const dimension = this._header.leftRightSided ? _utils_types__WEBPACK_IMPORTED_MODULE_1__.WidthOrHeightPropertyName.width : _utils_types__WEBPACK_IMPORTED_MODULE_1__.WidthOrHeightPropertyName.height;\n                content[dimension] -= this.layoutManager.layoutConfig.dimensions.headerHeight;\n            }\n            this._childElementContainer.style.width = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_8__.numberToPixels)(content.width);\n            this._childElementContainer.style.height = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_8__.numberToPixels)(content.height);\n            for (let i = 0; i < this.contentItems.length; i++) {\n                this.contentItems[i].element.style.width = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_8__.numberToPixels)(content.width);\n                this.contentItems[i].element.style.height = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_8__.numberToPixels)(content.height);\n            }\n            this.emit('resize');\n            this.emitStateChangedEvent();\n        }\n    }\n    /** @internal */\n    highlightHeaderDropZone(x) {\n        const visibleTabsLength = this._header.lastVisibleTabIndex + 1;\n        const tabsContainerElement = this._header.tabsContainerElement;\n        const tabsContainerElementChildNodes = tabsContainerElement.childNodes;\n        // Create shallow copy of childNodes list, excluding DropPlaceHolder, as we will be modifying the childNodes list\n        const visibleTabElements = new Array(visibleTabsLength);\n        let tabIndex = 0;\n        let tabCount = 0;\n        while (tabCount < visibleTabsLength) {\n            const visibleTabElement = tabsContainerElementChildNodes[tabIndex++];\n            if (visibleTabElement !== this.layoutManager.tabDropPlaceholder) {\n                visibleTabElements[tabCount++] = visibleTabElement;\n            }\n        }\n        const dropTargetIndicator = this.layoutManager.dropTargetIndicator;\n        if (dropTargetIndicator === null) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_6__.UnexpectedNullError('SHHDZDTI97110');\n        }\n        let area;\n        // Empty stack\n        if (visibleTabsLength === 0) {\n            const headerRect = this._header.element.getBoundingClientRect();\n            const headerTop = headerRect.top + document.body.scrollTop;\n            const headerLeft = headerRect.left + document.body.scrollLeft;\n            area = {\n                x1: headerLeft,\n                x2: headerLeft + 100,\n                y1: headerTop + headerRect.height - 20,\n                y2: headerTop + headerRect.height,\n            };\n            this._dropIndex = 0;\n        }\n        else {\n            let tabIndex = 0;\n            // This indicates whether our cursor is exactly over a tab\n            let isAboveTab = false;\n            let tabTop;\n            let tabLeft;\n            let tabWidth;\n            let tabElement;\n            do {\n                tabElement = visibleTabElements[tabIndex];\n                const tabRect = tabElement.getBoundingClientRect();\n                const tabRectTop = tabRect.top + document.body.scrollTop;\n                const tabRectLeft = tabRect.left + document.body.scrollLeft;\n                if (this._header.leftRightSided) {\n                    tabLeft = tabRectTop;\n                    tabTop = tabRectLeft;\n                    tabWidth = tabRect.height;\n                }\n                else {\n                    tabLeft = tabRectLeft;\n                    tabTop = tabRectTop;\n                    tabWidth = tabRect.width;\n                }\n                if (x >= tabLeft && x < tabLeft + tabWidth) {\n                    isAboveTab = true;\n                }\n                else {\n                    tabIndex++;\n                }\n            } while (tabIndex < visibleTabsLength && !isAboveTab);\n            // If we're not above any tabs, or to the right of any tab, we are out of the area, so give up\n            if (isAboveTab === false && x < tabLeft) {\n                return;\n            }\n            const halfX = tabLeft + tabWidth / 2;\n            if (x < halfX) {\n                this._dropIndex = tabIndex;\n                tabElement.insertAdjacentElement('beforebegin', this.layoutManager.tabDropPlaceholder);\n            }\n            else {\n                this._dropIndex = Math.min(tabIndex + 1, visibleTabsLength);\n                tabElement.insertAdjacentElement('afterend', this.layoutManager.tabDropPlaceholder);\n            }\n            const tabDropPlaceholderRect = this.layoutManager.tabDropPlaceholder.getBoundingClientRect();\n            const tabDropPlaceholderRectTop = tabDropPlaceholderRect.top + document.body.scrollTop;\n            const tabDropPlaceholderRectLeft = tabDropPlaceholderRect.left + document.body.scrollLeft;\n            const tabDropPlaceholderRectWidth = tabDropPlaceholderRect.width;\n            if (this._header.leftRightSided) {\n                const placeHolderTop = tabDropPlaceholderRectTop;\n                area = {\n                    x1: tabTop,\n                    x2: tabTop + tabElement.clientHeight,\n                    y1: placeHolderTop,\n                    y2: placeHolderTop + tabDropPlaceholderRectWidth,\n                };\n            }\n            else {\n                const placeHolderLeft = tabDropPlaceholderRectLeft;\n                area = {\n                    x1: placeHolderLeft,\n                    x2: placeHolderLeft + tabDropPlaceholderRectWidth,\n                    y1: tabTop,\n                    y2: tabTop + tabElement.clientHeight,\n                };\n            }\n        }\n        dropTargetIndicator.highlightArea(area, 0);\n        return;\n    }\n    /** @internal */\n    resetHeaderDropZone() {\n        this.layoutManager.tabDropPlaceholder.remove();\n    }\n    /** @internal */\n    setupHeaderPosition() {\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_8__.setElementDisplayVisibility)(this._header.element, this._header.show);\n        this.element.classList.remove(\"lm_left\" /* Left */, \"lm_right\" /* Right */, \"lm_bottom\" /* Bottom */);\n        if (this._header.leftRightSided) {\n            this.element.classList.add('lm_' + this._header.side);\n        }\n        //if ([Side.right, Side.bottom].includes(this._header.side)) {\n        //    // move the header behind the content.\n        //    this.element.appendChild(this._header.element);\n        //}\n        this.updateSize(false);\n    }\n    /** @internal */\n    highlightBodyDropZone(segment) {\n        if (this._contentAreaDimensions === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_6__.UnexpectedUndefinedError('SHBDZC82265');\n        }\n        else {\n            const highlightArea = this._contentAreaDimensions[segment].highlightArea;\n            const dropTargetIndicator = this.layoutManager.dropTargetIndicator;\n            if (dropTargetIndicator === null) {\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_6__.UnexpectedNullError('SHBDZD96110');\n            }\n            else {\n                dropTargetIndicator.highlightArea(highlightArea, 1);\n                this._dropSegment = segment;\n            }\n        }\n    }\n    /** @internal */\n    handleResize() {\n        this._header.updateTabSizes();\n    }\n    /** @internal */\n    handleMaximised() {\n        this._header.processMaximised();\n    }\n    /** @internal */\n    handleMinimised() {\n        this._header.processMinimised();\n    }\n    /** @internal */\n    handlePopoutEvent() {\n        this.popout();\n    }\n    /** @internal */\n    handleHeaderClickEvent(ev) {\n        const eventName = _utils_event_emitter__WEBPACK_IMPORTED_MODULE_9__.EventEmitter.headerClickEventName;\n        const bubblingEvent = new _utils_event_emitter__WEBPACK_IMPORTED_MODULE_9__.EventEmitter.ClickBubblingEvent(eventName, this, ev);\n        this.emit(eventName, bubblingEvent);\n    }\n    /** @internal */\n    handleHeaderTouchStartEvent(ev) {\n        const eventName = _utils_event_emitter__WEBPACK_IMPORTED_MODULE_9__.EventEmitter.headerTouchStartEventName;\n        const bubblingEvent = new _utils_event_emitter__WEBPACK_IMPORTED_MODULE_9__.EventEmitter.TouchStartBubblingEvent(eventName, this, ev);\n        this.emit(eventName, bubblingEvent);\n    }\n    /** @internal */\n    handleHeaderComponentRemoveEvent(item) {\n        this.removeChild(item, false);\n    }\n    /** @internal */\n    handleHeaderComponentFocusEvent(item) {\n        this.setActiveComponentItem(item, true);\n    }\n    /** @internal */\n    handleHeaderComponentStartDragEvent(x, y, dragListener, componentItem) {\n        if (this.isMaximised === true) {\n            this.toggleMaximise();\n        }\n        this.layoutManager.startComponentDrag(x, y, dragListener, componentItem, this);\n    }\n    /** @internal */\n    createHeaderConfig() {\n        if (!this._headerSideChanged) {\n            return _config_resolved_config__WEBPACK_IMPORTED_MODULE_7__.ResolvedHeaderedItemConfig.Header.createCopy(this._headerConfig);\n        }\n        else {\n            const show = this._header.show ? this._header.side : false;\n            let result = _config_resolved_config__WEBPACK_IMPORTED_MODULE_7__.ResolvedHeaderedItemConfig.Header.createCopy(this._headerConfig, show);\n            if (result === undefined) {\n                result = {\n                    show,\n                    popout: undefined,\n                    maximise: undefined,\n                    close: undefined,\n                    minimise: undefined,\n                    tabDropdown: undefined,\n                };\n            }\n            return result;\n        }\n    }\n    /** @internal */\n    emitStateChangedEvent() {\n        this.emitBaseBubblingEvent('stateChanged');\n    }\n}\n/** @public */\n(function (Stack) {\n    /** @internal */\n    function createElement(document) {\n        const element = document.createElement('div');\n        element.classList.add(\"lm_item\" /* Item */);\n        element.classList.add(\"lm_stack\" /* Stack */);\n        return element;\n    }\n    Stack.createElement = createElement;\n})(Stack || (Stack = {}));\n//# sourceMappingURL=stack.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/items/stack.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/layout-manager.js":
/*!******************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/layout-manager.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LayoutManager: () => (/* binding */ LayoutManager)\n/* harmony export */ });\n/* harmony import */ var _config_config__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./config/config */ \"./node_modules/golden-layout/dist/esm/ts/config/config.js\");\n/* harmony import */ var _config_resolved_config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./config/resolved-config */ \"./node_modules/golden-layout/dist/esm/ts/config/resolved-config.js\");\n/* harmony import */ var _controls_browser_popout__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./controls/browser-popout */ \"./node_modules/golden-layout/dist/esm/ts/controls/browser-popout.js\");\n/* harmony import */ var _controls_drag_proxy__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./controls/drag-proxy */ \"./node_modules/golden-layout/dist/esm/ts/controls/drag-proxy.js\");\n/* harmony import */ var _controls_drag_source__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./controls/drag-source */ \"./node_modules/golden-layout/dist/esm/ts/controls/drag-source.js\");\n/* harmony import */ var _controls_drop_target_indicator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./controls/drop-target-indicator */ \"./node_modules/golden-layout/dist/esm/ts/controls/drop-target-indicator.js\");\n/* harmony import */ var _controls_transition_indicator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./controls/transition-indicator */ \"./node_modules/golden-layout/dist/esm/ts/controls/transition-indicator.js\");\n/* harmony import */ var _errors_external_error__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./errors/external-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/external-error.js\");\n/* harmony import */ var _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./errors/internal-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js\");\n/* harmony import */ var _items_component_item__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./items/component-item */ \"./node_modules/golden-layout/dist/esm/ts/items/component-item.js\");\n/* harmony import */ var _items_content_item__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./items/content-item */ \"./node_modules/golden-layout/dist/esm/ts/items/content-item.js\");\n/* harmony import */ var _items_ground_item__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./items/ground-item */ \"./node_modules/golden-layout/dist/esm/ts/items/ground-item.js\");\n/* harmony import */ var _items_row_or_column__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./items/row-or-column */ \"./node_modules/golden-layout/dist/esm/ts/items/row-or-column.js\");\n/* harmony import */ var _items_stack__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./items/stack */ \"./node_modules/golden-layout/dist/esm/ts/items/stack.js\");\n/* harmony import */ var _utils_config_minifier__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/config-minifier */ \"./node_modules/golden-layout/dist/esm/ts/utils/config-minifier.js\");\n/* harmony import */ var _utils_event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/event-emitter */ \"./node_modules/golden-layout/dist/esm/ts/utils/event-emitter.js\");\n/* harmony import */ var _utils_event_hub__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/event-hub */ \"./node_modules/golden-layout/dist/esm/ts/utils/event-hub.js\");\n/* harmony import */ var _utils_i18n_strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/i18n-strings */ \"./node_modules/golden-layout/dist/esm/ts/utils/i18n-strings.js\");\n/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/types */ \"./node_modules/golden-layout/dist/esm/ts/utils/types.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/utils */ \"./node_modules/golden-layout/dist/esm/ts/utils/utils.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * The main class that will be exposed as GoldenLayout.\n */\n/** @public */\nclass LayoutManager extends _utils_event_emitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    /**\n    * @param container - A Dom HTML element. Defaults to body\n    * @internal\n    */\n    constructor(parameters) {\n        super();\n        /** Whether the layout will be automatically be resized to container whenever the container's size is changed\n         * Default is true if <body> is the container otherwise false\n         * Default will be changed to true for any container in the future\n         */\n        this.resizeWithContainerAutomatically = false;\n        /** The debounce interval (in milliseconds) used whenever a layout is automatically resized.  0 means next tick */\n        this.resizeDebounceInterval = 100;\n        /** Extend the current debounce delay time period if it is triggered during the delay.\n         * If this is true, the layout will only resize when its container has stopped being resized.\n         * If it is false, the layout will resize at intervals while its container is being resized.\n         */\n        this.resizeDebounceExtendedWhenPossible = true;\n        /** @internal */\n        this._isInitialised = false;\n        /** @internal */\n        this._groundItem = undefined;\n        /** @internal */\n        this._openPopouts = [];\n        /** @internal */\n        this._dropTargetIndicator = null;\n        /** @internal */\n        this._transitionIndicator = null;\n        /** @internal */\n        this._itemAreas = [];\n        /** @internal */\n        this._maximisePlaceholder = LayoutManager.createMaximisePlaceElement(document);\n        /** @internal */\n        this._tabDropPlaceholder = LayoutManager.createTabDropPlaceholderElement(document);\n        /** @internal */\n        this._dragSources = [];\n        /** @internal */\n        this._updatingColumnsResponsive = false;\n        /** @internal */\n        this._firstLoad = true;\n        /** @internal */\n        this._eventHub = new _utils_event_hub__WEBPACK_IMPORTED_MODULE_1__.EventHub(this);\n        /** @internal */\n        this._width = null;\n        /** @internal */\n        this._height = null;\n        /** @internal */\n        this._virtualSizedContainers = [];\n        /** @internal */\n        this._virtualSizedContainerAddingBeginCount = 0;\n        /** @internal */\n        this._sizeInvalidationBeginCount = 0;\n        /** @internal */\n        this._resizeObserver = new ResizeObserver(() => this.handleContainerResize());\n        /** @internal @deprecated to be removed in version 3 */\n        this._windowBeforeUnloadListener = () => this.onBeforeUnload();\n        /** @internal @deprecated to be removed in version 3 */\n        this._windowBeforeUnloadListening = false;\n        /** @internal */\n        this._maximisedStackBeforeDestroyedListener = (ev) => this.cleanupBeforeMaximisedStackDestroyed(ev);\n        this.isSubWindow = parameters.isSubWindow;\n        this._constructorOrSubWindowLayoutConfig = parameters.constructorOrSubWindowLayoutConfig;\n        _utils_i18n_strings__WEBPACK_IMPORTED_MODULE_2__.I18nStrings.checkInitialise();\n        _utils_config_minifier__WEBPACK_IMPORTED_MODULE_3__.ConfigMinifier.checkInitialise();\n        if (parameters.containerElement !== undefined) {\n            this._containerElement = parameters.containerElement;\n        }\n    }\n    get container() { return this._containerElement; }\n    get isInitialised() { return this._isInitialised; }\n    /** @internal */\n    get groundItem() { return this._groundItem; }\n    /** @internal @deprecated use {@link (LayoutManager:class).groundItem} instead */\n    get root() { return this._groundItem; }\n    get openPopouts() { return this._openPopouts; }\n    /** @internal */\n    get dropTargetIndicator() { return this._dropTargetIndicator; }\n    /** @internal @deprecated To be removed */\n    get transitionIndicator() { return this._transitionIndicator; }\n    get width() { return this._width; }\n    get height() { return this._height; }\n    /**\n     * Retrieves the {@link (EventHub:class)} instance associated with this layout manager.\n     * This can be used to propagate events between the windows\n     * @public\n     */\n    get eventHub() { return this._eventHub; }\n    get rootItem() {\n        if (this._groundItem === undefined) {\n            throw new Error('Cannot access rootItem before init');\n        }\n        else {\n            const groundContentItems = this._groundItem.contentItems;\n            if (groundContentItems.length === 0) {\n                return undefined;\n            }\n            else {\n                return this._groundItem.contentItems[0];\n            }\n        }\n    }\n    get focusedComponentItem() { return this._focusedComponentItem; }\n    /** @internal */\n    get tabDropPlaceholder() { return this._tabDropPlaceholder; }\n    get maximisedStack() { return this._maximisedStack; }\n    /** @deprecated indicates deprecated constructor use */\n    get deprecatedConstructor() { return !this.isSubWindow && this._constructorOrSubWindowLayoutConfig !== undefined; }\n    /**\n     * Destroys the LayoutManager instance itself as well as every ContentItem\n     * within it. After this is called nothing should be left of the LayoutManager.\n     *\n     * This function only needs to be called if an application wishes to destroy the Golden Layout object while\n     * a page remains loaded. When a page is unloaded, all resources claimed by Golden Layout will automatically\n     * be released.\n     */\n    destroy() {\n        if (this._isInitialised) {\n            if (this._windowBeforeUnloadListening) {\n                globalThis.removeEventListener('beforeunload', this._windowBeforeUnloadListener);\n                this._windowBeforeUnloadListening = false;\n            }\n            if (this.layoutConfig.settings.closePopoutsOnUnload === true) {\n                this.closeAllOpenPopouts();\n            }\n            this._resizeObserver.disconnect();\n            this.checkClearResizeTimeout();\n            if (this._groundItem !== undefined) {\n                this._groundItem.destroy();\n            }\n            this._tabDropPlaceholder.remove();\n            if (this._dropTargetIndicator !== null) {\n                this._dropTargetIndicator.destroy();\n            }\n            if (this._transitionIndicator !== null) {\n                this._transitionIndicator.destroy();\n            }\n            this._eventHub.destroy();\n            for (const dragSource of this._dragSources) {\n                dragSource.destroy();\n            }\n            this._dragSources = [];\n            this._isInitialised = false;\n        }\n    }\n    /**\n     * Takes a GoldenLayout configuration object and\n     * replaces its keys and values recursively with\n     * one letter codes\n     * @deprecated use {@link (ResolvedLayoutConfig:namespace).minifyConfig} instead\n     */\n    minifyConfig(config) {\n        return _config_resolved_config__WEBPACK_IMPORTED_MODULE_4__.ResolvedLayoutConfig.minifyConfig(config);\n    }\n    /**\n     * Takes a configuration Object that was previously minified\n     * using minifyConfig and returns its original version\n     * @deprecated use {@link (ResolvedLayoutConfig:namespace).unminifyConfig} instead\n     */\n    unminifyConfig(config) {\n        return _config_resolved_config__WEBPACK_IMPORTED_MODULE_4__.ResolvedLayoutConfig.unminifyConfig(config);\n    }\n    /**\n     * Called from GoldenLayout class. Finishes of init\n     * @internal\n     */\n    init() {\n        this.setContainer();\n        this._dropTargetIndicator = new _controls_drop_target_indicator__WEBPACK_IMPORTED_MODULE_5__.DropTargetIndicator( /*this.container*/);\n        this._transitionIndicator = new _controls_transition_indicator__WEBPACK_IMPORTED_MODULE_6__.TransitionIndicator();\n        this.updateSizeFromContainer();\n        let subWindowRootConfig;\n        if (this.isSubWindow) {\n            if (this._constructorOrSubWindowLayoutConfig === undefined) {\n                // SubWindow LayoutConfig should have been generated by constructor\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnexpectedUndefinedError('LMIU07155');\n            }\n            else {\n                const root = this._constructorOrSubWindowLayoutConfig.root;\n                if (root === undefined) {\n                    // SubWindow LayoutConfig must not be empty\n                    throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.AssertError('LMIC07156');\n                }\n                else {\n                    if (_config_config__WEBPACK_IMPORTED_MODULE_8__.ItemConfig.isComponent(root)) {\n                        subWindowRootConfig = root;\n                    }\n                    else {\n                        // SubWindow LayoutConfig must have Component as Root\n                        throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.AssertError('LMIC07157');\n                    }\n                }\n                const resolvedLayoutConfig = _config_config__WEBPACK_IMPORTED_MODULE_8__.LayoutConfig.resolve(this._constructorOrSubWindowLayoutConfig);\n                // remove root from layoutConfig\n                this.layoutConfig = Object.assign(Object.assign({}, resolvedLayoutConfig), { root: undefined });\n            }\n        }\n        else {\n            if (this._constructorOrSubWindowLayoutConfig === undefined) {\n                this.layoutConfig = _config_resolved_config__WEBPACK_IMPORTED_MODULE_4__.ResolvedLayoutConfig.createDefault(); // will overwritten be loaded via loadLayout\n            }\n            else {\n                // backwards compatibility\n                this.layoutConfig = _config_config__WEBPACK_IMPORTED_MODULE_8__.LayoutConfig.resolve(this._constructorOrSubWindowLayoutConfig);\n            }\n        }\n        const layoutConfig = this.layoutConfig;\n        this._groundItem = new _items_ground_item__WEBPACK_IMPORTED_MODULE_9__.GroundItem(this, layoutConfig.root, this._containerElement);\n        this._groundItem.init();\n        this.checkLoadedLayoutMaximiseItem();\n        this._resizeObserver.observe(this._containerElement);\n        this._isInitialised = true;\n        this.adjustColumnsResponsive();\n        this.emit('initialised');\n        if (subWindowRootConfig !== undefined) {\n            // must be SubWindow\n            this.loadComponentAsRoot(subWindowRootConfig);\n        }\n    }\n    /**\n     * Loads a new layout\n     * @param layoutConfig - New layout to be loaded\n     */\n    loadLayout(layoutConfig) {\n        if (!this.isInitialised) {\n            // In case application not correctly using legacy constructor\n            throw new Error('GoldenLayout: Need to call init() if LayoutConfig with defined root passed to constructor');\n        }\n        else {\n            if (this._groundItem === undefined) {\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnexpectedUndefinedError('LMLL11119');\n            }\n            else {\n                this.createSubWindows(); // still needs to be tested\n                this.layoutConfig = _config_config__WEBPACK_IMPORTED_MODULE_8__.LayoutConfig.resolve(layoutConfig);\n                this._groundItem.loadRoot(this.layoutConfig.root);\n                this.checkLoadedLayoutMaximiseItem();\n                this.adjustColumnsResponsive();\n            }\n        }\n    }\n    /**\n     * Creates a layout configuration object based on the the current state\n     *\n     * @public\n     * @returns GoldenLayout configuration\n     */\n    saveLayout() {\n        if (this._isInitialised === false) {\n            throw new Error('Can\\'t create config, layout not yet initialised');\n        }\n        else {\n            // if (root !== undefined && !(root instanceof ContentItem)) {\n            //     throw new Error('Root must be a ContentItem');\n            // }\n            /*\n            * Content\n            */\n            if (this._groundItem === undefined) {\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnexpectedUndefinedError('LMTC18244');\n            }\n            else {\n                const groundContent = this._groundItem.calculateConfigContent();\n                let rootItemConfig;\n                if (groundContent.length !== 1) {\n                    rootItemConfig = undefined;\n                }\n                else {\n                    rootItemConfig = groundContent[0];\n                }\n                /*\n                * Retrieve config for subwindows\n                */\n                this.reconcilePopoutWindows();\n                const openPopouts = [];\n                for (let i = 0; i < this._openPopouts.length; i++) {\n                    openPopouts.push(this._openPopouts[i].toConfig());\n                }\n                const config = {\n                    root: rootItemConfig,\n                    openPopouts,\n                    settings: _config_resolved_config__WEBPACK_IMPORTED_MODULE_4__.ResolvedLayoutConfig.Settings.createCopy(this.layoutConfig.settings),\n                    dimensions: _config_resolved_config__WEBPACK_IMPORTED_MODULE_4__.ResolvedLayoutConfig.Dimensions.createCopy(this.layoutConfig.dimensions),\n                    header: _config_resolved_config__WEBPACK_IMPORTED_MODULE_4__.ResolvedLayoutConfig.Header.createCopy(this.layoutConfig.header),\n                    resolved: true,\n                };\n                return config;\n            }\n        }\n    }\n    /**\n     * Removes any existing layout. Effectively, an empty layout will be loaded.\n     */\n    clear() {\n        if (this._groundItem === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnexpectedUndefinedError('LMCL11129');\n        }\n        else {\n            this._groundItem.clearRoot();\n        }\n    }\n    /**\n     * @deprecated Use {@link (LayoutManager:class).saveLayout}\n     */\n    toConfig() {\n        return this.saveLayout();\n    }\n    /**\n     * Adds a new ComponentItem.  Will use default location selectors to ensure a location is found and\n     * component is successfully added\n     * @param componentTypeName - Name of component type to be created.\n     * @param state - Optional initial state to be assigned to component\n     * @returns New ComponentItem created.\n     */\n    newComponent(componentType, componentState, title) {\n        const componentItem = this.newComponentAtLocation(componentType, componentState, title);\n        if (componentItem === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.AssertError('LMNC65588');\n        }\n        else {\n            return componentItem;\n        }\n    }\n    /**\n     * Adds a ComponentItem at the first valid selector location.\n     * @param componentTypeName - Name of component type to be created.\n     * @param state - Optional initial state to be assigned to component\n     * @param locationSelectors - Array of location selectors used to find location in layout where component\n     * will be added. First location in array which is valid will be used. If locationSelectors is undefined,\n     * {@link (LayoutManager:namespace).defaultLocationSelectors} will be used\n     * @returns New ComponentItem created or undefined if no valid location selector was in array.\n     */\n    newComponentAtLocation(componentType, componentState, title, locationSelectors) {\n        if (this._groundItem === undefined) {\n            throw new Error('Cannot add component before init');\n        }\n        else {\n            const location = this.addComponentAtLocation(componentType, componentState, title, locationSelectors);\n            if (location === undefined) {\n                return undefined;\n            }\n            else {\n                const createdItem = location.parentItem.contentItems[location.index];\n                if (!_items_content_item__WEBPACK_IMPORTED_MODULE_10__.ContentItem.isComponentItem(createdItem)) {\n                    throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.AssertError('LMNC992877533');\n                }\n                else {\n                    return createdItem;\n                }\n            }\n        }\n    }\n    /**\n     * Adds a new ComponentItem.  Will use default location selectors to ensure a location is found and\n     * component is successfully added\n     * @param componentType - Type of component to be created.\n     * @param state - Optional initial state to be assigned to component\n     * @returns Location of new ComponentItem created.\n     */\n    addComponent(componentType, componentState, title) {\n        const location = this.addComponentAtLocation(componentType, componentState, title);\n        if (location === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.AssertError('LMAC99943');\n        }\n        else {\n            return location;\n        }\n    }\n    /**\n     * Adds a ComponentItem at the first valid selector location.\n     * @param componentType - Type of component to be created.\n     * @param state - Optional initial state to be assigned to component\n     * @param locationSelectors - Array of location selectors used to find determine location in layout where component\n     * will be added. First location in array which is valid will be used. If undefined,\n     * {@link (LayoutManager:namespace).defaultLocationSelectors} will be used.\n     * @returns Location of new ComponentItem created or undefined if no valid location selector was in array.\n     */\n    addComponentAtLocation(componentType, componentState, title, locationSelectors) {\n        const itemConfig = {\n            type: 'component',\n            componentType,\n            componentState,\n            title,\n        };\n        return this.addItemAtLocation(itemConfig, locationSelectors);\n    }\n    /**\n     * Adds a new ContentItem.  Will use default location selectors to ensure a location is found and\n     * component is successfully added\n     * @param itemConfig - ResolvedItemConfig of child to be added.\n     * @returns New ContentItem created.\n    */\n    newItem(itemConfig) {\n        const contentItem = this.newItemAtLocation(itemConfig);\n        if (contentItem === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.AssertError('LMNC65588');\n        }\n        else {\n            return contentItem;\n        }\n    }\n    /**\n     * Adds a new child ContentItem under the root ContentItem.  If a root does not exist, then create root ContentItem instead\n     * @param itemConfig - ResolvedItemConfig of child to be added.\n     * @param locationSelectors - Array of location selectors used to find determine location in layout where ContentItem\n     * will be added. First location in array which is valid will be used. If undefined,\n     * {@link (LayoutManager:namespace).defaultLocationSelectors} will be used.\n     * @returns New ContentItem created or undefined if no valid location selector was in array. */\n    newItemAtLocation(itemConfig, locationSelectors) {\n        if (this._groundItem === undefined) {\n            throw new Error('Cannot add component before init');\n        }\n        else {\n            const location = this.addItemAtLocation(itemConfig, locationSelectors);\n            if (location === undefined) {\n                return undefined;\n            }\n            else {\n                const createdItem = location.parentItem.contentItems[location.index];\n                return createdItem;\n            }\n        }\n    }\n    /**\n     * Adds a new ContentItem.  Will use default location selectors to ensure a location is found and\n     * component is successfully added.\n     * @param itemConfig - ResolvedItemConfig of child to be added.\n     * @returns Location of new ContentItem created. */\n    addItem(itemConfig) {\n        const location = this.addItemAtLocation(itemConfig);\n        if (location === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.AssertError('LMAI99943');\n        }\n        else {\n            return location;\n        }\n    }\n    /**\n     * Adds a ContentItem at the first valid selector location.\n     * @param itemConfig - ResolvedItemConfig of child to be added.\n     * @param locationSelectors - Array of location selectors used to find determine location in layout where ContentItem\n     * will be added. First location in array which is valid will be used. If undefined,\n     * {@link (LayoutManager:namespace).defaultLocationSelectors} will be used.\n     * @returns Location of new ContentItem created or undefined if no valid location selector was in array. */\n    addItemAtLocation(itemConfig, locationSelectors) {\n        if (this._groundItem === undefined) {\n            throw new Error('Cannot add component before init');\n        }\n        else {\n            if (locationSelectors === undefined) {\n                // defaultLocationSelectors should always find a location\n                locationSelectors = LayoutManager.defaultLocationSelectors;\n            }\n            const location = this.findFirstLocation(locationSelectors);\n            if (location === undefined) {\n                return undefined;\n            }\n            else {\n                let parentItem = location.parentItem;\n                let addIdx;\n                switch (parentItem.type) {\n                    case _utils_types__WEBPACK_IMPORTED_MODULE_11__.ItemType.ground: {\n                        const groundItem = parentItem;\n                        addIdx = groundItem.addItem(itemConfig, location.index);\n                        if (addIdx >= 0) {\n                            parentItem = this._groundItem.contentItems[0]; // was added to rootItem\n                        }\n                        else {\n                            addIdx = 0; // was added as rootItem (which is the first and only ContentItem in GroundItem)\n                        }\n                        break;\n                    }\n                    case _utils_types__WEBPACK_IMPORTED_MODULE_11__.ItemType.row:\n                    case _utils_types__WEBPACK_IMPORTED_MODULE_11__.ItemType.column: {\n                        const rowOrColumn = parentItem;\n                        addIdx = rowOrColumn.addItem(itemConfig, location.index);\n                        break;\n                    }\n                    case _utils_types__WEBPACK_IMPORTED_MODULE_11__.ItemType.stack: {\n                        if (!_config_config__WEBPACK_IMPORTED_MODULE_8__.ItemConfig.isComponent(itemConfig)) {\n                            throw Error(_utils_i18n_strings__WEBPACK_IMPORTED_MODULE_2__.i18nStrings[6 /* ItemConfigIsNotTypeComponent */]);\n                        }\n                        else {\n                            const stack = parentItem;\n                            addIdx = stack.addItem(itemConfig, location.index);\n                            break;\n                        }\n                    }\n                    case _utils_types__WEBPACK_IMPORTED_MODULE_11__.ItemType.component: {\n                        throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.AssertError('LMAIALC87444602');\n                    }\n                    default:\n                        throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnreachableCaseError('LMAIALU98881733', parentItem.type);\n                }\n                if (_config_config__WEBPACK_IMPORTED_MODULE_8__.ItemConfig.isComponent(itemConfig)) {\n                    // see if stack was inserted\n                    const item = parentItem.contentItems[addIdx];\n                    if (_items_content_item__WEBPACK_IMPORTED_MODULE_10__.ContentItem.isStack(item)) {\n                        parentItem = item;\n                        addIdx = 0;\n                    }\n                }\n                location.parentItem = parentItem;\n                location.index = addIdx;\n                return location;\n            }\n        }\n    }\n    /** Loads the specified component ResolvedItemConfig as root.\n     * This can be used to display a Component all by itself.  The layout cannot be changed other than having another new layout loaded.\n     * Note that, if this layout is saved and reloaded, it will reload with the Component as a child of a Stack.\n    */\n    loadComponentAsRoot(itemConfig) {\n        if (this._groundItem === undefined) {\n            throw new Error('Cannot add item before init');\n        }\n        else {\n            this._groundItem.loadComponentAsRoot(itemConfig);\n        }\n    }\n    /** @deprecated Use {@link (LayoutManager:class).setSize} */\n    updateSize(width, height) {\n        this.setSize(width, height);\n    }\n    /**\n     * Updates the layout managers size\n     *\n     * @param width - Width in pixels\n     * @param height - Height in pixels\n     */\n    setSize(width, height) {\n        this._width = width;\n        this._height = height;\n        if (this._isInitialised === true) {\n            if (this._groundItem === undefined) {\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnexpectedUndefinedError('LMUS18881');\n            }\n            else {\n                this._groundItem.setSize(this._width, this._height);\n                if (this._maximisedStack) {\n                    const { width, height } = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_12__.getElementWidthAndHeight)(this._containerElement);\n                    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_12__.setElementWidth)(this._maximisedStack.element, width);\n                    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_12__.setElementHeight)(this._maximisedStack.element, height);\n                    this._maximisedStack.updateSize(false);\n                }\n                this.adjustColumnsResponsive();\n            }\n        }\n    }\n    /** @internal */\n    beginSizeInvalidation() {\n        this._sizeInvalidationBeginCount++;\n    }\n    /** @internal */\n    endSizeInvalidation() {\n        if (--this._sizeInvalidationBeginCount === 0) {\n            this.updateSizeFromContainer();\n        }\n    }\n    /** @internal */\n    updateSizeFromContainer() {\n        const { width, height } = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_12__.getElementWidthAndHeight)(this._containerElement);\n        this.setSize(width, height);\n    }\n    /**\n     * Update the size of the root ContentItem.  This will update the size of all contentItems in the tree\n     * @param force - In some cases the size is not updated if it has not changed. In this case, events\n     * (such as ComponentContainer.virtualRectingRequiredEvent) are not fired. Setting force to true, ensures the size is updated regardless, and\n     * the respective events are fired. This is sometimes necessary when a component's size has not changed but it has become visible, and the\n     * relevant events need to be fired.\n     */\n    updateRootSize(force = false) {\n        if (this._groundItem === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnexpectedUndefinedError('LMURS28881');\n        }\n        else {\n            this._groundItem.updateSize(force);\n        }\n    }\n    /** @public */\n    createAndInitContentItem(config, parent) {\n        const newItem = this.createContentItem(config, parent);\n        newItem.init();\n        return newItem;\n    }\n    /**\n     * Recursively creates new item tree structures based on a provided\n     * ItemConfiguration object\n     *\n     * @param config - ResolvedItemConfig\n     * @param parent - The item the newly created item should be a child of\n     * @internal\n     */\n    createContentItem(config, parent) {\n        if (typeof config.type !== 'string') {\n            throw new _errors_external_error__WEBPACK_IMPORTED_MODULE_13__.ConfigurationError('Missing parameter \\'type\\'', JSON.stringify(config));\n        }\n        /**\n         * We add an additional stack around every component that's not within a stack anyways.\n         */\n        if (\n        // If this is a component\n        _config_resolved_config__WEBPACK_IMPORTED_MODULE_4__.ResolvedItemConfig.isComponentItem(config) &&\n            // and it's not already within a stack\n            !(parent instanceof _items_stack__WEBPACK_IMPORTED_MODULE_14__.Stack) &&\n            // and we have a parent\n            !!parent &&\n            // and it's not the topmost item in a new window\n            !(this.isSubWindow === true && parent instanceof _items_ground_item__WEBPACK_IMPORTED_MODULE_9__.GroundItem)) {\n            const stackConfig = {\n                type: _utils_types__WEBPACK_IMPORTED_MODULE_11__.ItemType.stack,\n                content: [config],\n                size: config.size,\n                sizeUnit: config.sizeUnit,\n                minSize: config.minSize,\n                minSizeUnit: config.minSizeUnit,\n                id: config.id,\n                maximised: config.maximised,\n                isClosable: config.isClosable,\n                activeItemIndex: 0,\n                header: undefined,\n            };\n            config = stackConfig;\n        }\n        const contentItem = this.createContentItemFromConfig(config, parent);\n        return contentItem;\n    }\n    findFirstComponentItemById(id) {\n        if (this._groundItem === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnexpectedUndefinedError('LMFFCIBI82446');\n        }\n        else {\n            return this.findFirstContentItemTypeByIdRecursive(_utils_types__WEBPACK_IMPORTED_MODULE_11__.ItemType.component, id, this._groundItem);\n        }\n    }\n    /**\n     * Creates a popout window with the specified content at the specified position\n     *\n     * @param itemConfigOrContentItem - The content of the popout window's layout manager derived from either\n     * a {@link (ContentItem:class)} or {@link (ItemConfig:interface)} or ResolvedItemConfig content (array of {@link (ItemConfig:interface)})\n     * @param positionAndSize - The width, height, left and top of Popout window\n     * @param parentId -The id of the element this item will be appended to when popIn is called\n     * @param indexInParent - The position of this item within its parent element\n     */\n    createPopout(itemConfigOrContentItem, positionAndSize, parentId, indexInParent) {\n        if (itemConfigOrContentItem instanceof _items_content_item__WEBPACK_IMPORTED_MODULE_10__.ContentItem) {\n            return this.createPopoutFromContentItem(itemConfigOrContentItem, positionAndSize, parentId, indexInParent);\n        }\n        else {\n            return this.createPopoutFromItemConfig(itemConfigOrContentItem, positionAndSize, parentId, indexInParent);\n        }\n    }\n    /** @internal */\n    createPopoutFromContentItem(item, window, parentId, indexInParent) {\n        /**\n         * If the item is the only component within a stack or for some\n         * other reason the only child of its parent the parent will be destroyed\n         * when the child is removed.\n         *\n         * In order to support this we move up the tree until we find something\n         * that will remain after the item is being popped out\n         */\n        let parent = item.parent;\n        let child = item;\n        while (parent !== null && parent.contentItems.length === 1 && !parent.isGround) {\n            child = parent;\n            parent = parent.parent;\n        }\n        if (parent === null) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnexpectedNullError('LMCPFCI00834');\n        }\n        else {\n            if (indexInParent === undefined) {\n                indexInParent = parent.contentItems.indexOf(child);\n            }\n            if (parentId !== null) {\n                parent.addPopInParentId(parentId);\n            }\n            if (window === undefined) {\n                const windowLeft = globalThis.screenX || globalThis.screenLeft;\n                const windowTop = globalThis.screenY || globalThis.screenTop;\n                const offsetLeft = item.element.offsetLeft;\n                const offsetTop = item.element.offsetTop;\n                // const { left: offsetLeft, top: offsetTop } = getJQueryLeftAndTop(item.element);\n                const { width, height } = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_12__.getElementWidthAndHeight)(item.element);\n                window = {\n                    left: windowLeft + offsetLeft,\n                    top: windowTop + offsetTop,\n                    width,\n                    height,\n                };\n            }\n            const itemConfig = item.toConfig();\n            item.remove();\n            if (!_config_resolved_config__WEBPACK_IMPORTED_MODULE_4__.ResolvedRootItemConfig.isRootItemConfig(itemConfig)) {\n                throw new Error(`${_utils_i18n_strings__WEBPACK_IMPORTED_MODULE_2__.i18nStrings[0 /* PopoutCannotBeCreatedWithGroundItemConfig */]}`);\n            }\n            else {\n                return this.createPopoutFromItemConfig(itemConfig, window, parentId, indexInParent);\n            }\n        }\n    }\n    /** @internal */\n    beginVirtualSizedContainerAdding() {\n        if (++this._virtualSizedContainerAddingBeginCount === 0) {\n            this._virtualSizedContainers.length = 0;\n        }\n    }\n    /** @internal */\n    addVirtualSizedContainer(container) {\n        this._virtualSizedContainers.push(container);\n    }\n    /** @internal */\n    endVirtualSizedContainerAdding() {\n        if (--this._virtualSizedContainerAddingBeginCount === 0) {\n            const count = this._virtualSizedContainers.length;\n            if (count > 0) {\n                this.fireBeforeVirtualRectingEvent(count);\n                for (let i = 0; i < count; i++) {\n                    const container = this._virtualSizedContainers[i];\n                    container.notifyVirtualRectingRequired();\n                }\n                this.fireAfterVirtualRectingEvent();\n                this._virtualSizedContainers.length = 0;\n            }\n        }\n    }\n    /** @internal */\n    fireBeforeVirtualRectingEvent(count) {\n        if (this.beforeVirtualRectingEvent !== undefined) {\n            this.beforeVirtualRectingEvent(count);\n        }\n    }\n    /** @internal */\n    fireAfterVirtualRectingEvent() {\n        if (this.afterVirtualRectingEvent !== undefined) {\n            this.afterVirtualRectingEvent();\n        }\n    }\n    /** @internal */\n    createPopoutFromItemConfig(rootItemConfig, window, parentId, indexInParent) {\n        const layoutConfig = this.toConfig();\n        const popoutLayoutConfig = {\n            root: rootItemConfig,\n            openPopouts: [],\n            settings: layoutConfig.settings,\n            dimensions: layoutConfig.dimensions,\n            header: layoutConfig.header,\n            window,\n            parentId,\n            indexInParent,\n            resolved: true,\n        };\n        return this.createPopoutFromPopoutLayoutConfig(popoutLayoutConfig);\n    }\n    /** @internal */\n    createPopoutFromPopoutLayoutConfig(config) {\n        var _a, _b, _c, _d;\n        const configWindow = config.window;\n        const initialWindow = {\n            left: (_a = configWindow.left) !== null && _a !== void 0 ? _a : (globalThis.screenX || globalThis.screenLeft + 20),\n            top: (_b = configWindow.top) !== null && _b !== void 0 ? _b : (globalThis.screenY || globalThis.screenTop + 20),\n            width: (_c = configWindow.width) !== null && _c !== void 0 ? _c : 500,\n            height: (_d = configWindow.height) !== null && _d !== void 0 ? _d : 309,\n        };\n        const browserPopout = new _controls_browser_popout__WEBPACK_IMPORTED_MODULE_15__.BrowserPopout(config, initialWindow, this);\n        browserPopout.on('initialised', () => this.emit('windowOpened', browserPopout));\n        browserPopout.on('closed', () => this.reconcilePopoutWindows());\n        this._openPopouts.push(browserPopout);\n        if (this.layoutConfig.settings.closePopoutsOnUnload && !this._windowBeforeUnloadListening) {\n            globalThis.addEventListener('beforeunload', this._windowBeforeUnloadListener, { passive: true });\n            this._windowBeforeUnloadListening = true;\n        }\n        return browserPopout;\n    }\n    /**\n     * Closes all Open Popouts\n     * Applications can call this method when a page is unloaded to remove its open popouts\n     */\n    closeAllOpenPopouts() {\n        for (let i = 0; i < this._openPopouts.length; i++) {\n            this._openPopouts[i].close();\n        }\n        this._openPopouts.length = 0;\n        if (this._windowBeforeUnloadListening) {\n            globalThis.removeEventListener('beforeunload', this._windowBeforeUnloadListener);\n            this._windowBeforeUnloadListening = false;\n        }\n    }\n    newDragSource(element, componentTypeOrItemConfigCallback, componentState, title, id) {\n        const dragSource = new _controls_drag_source__WEBPACK_IMPORTED_MODULE_16__.DragSource(this, element, [], componentTypeOrItemConfigCallback, componentState, title, id);\n        this._dragSources.push(dragSource);\n        return dragSource;\n    }\n    /**\n     * Removes a DragListener added by createDragSource() so the corresponding\n     * DOM element is not a drag source any more.\n     */\n    removeDragSource(dragSource) {\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_12__.removeFromArray)(dragSource, this._dragSources);\n        dragSource.destroy();\n    }\n    /** @internal */\n    startComponentDrag(x, y, dragListener, componentItem, stack) {\n        new _controls_drag_proxy__WEBPACK_IMPORTED_MODULE_17__.DragProxy(x, y, dragListener, this, componentItem, stack);\n    }\n    /**\n     * Programmatically focuses an item. This focuses the specified component item\n     * and the item emits a focus event\n     *\n     * @param item - The component item to be focused\n     * @param suppressEvent - Whether to emit focus event\n     */\n    focusComponent(item, suppressEvent = false) {\n        item.focus(suppressEvent);\n    }\n    /**\n     * Programmatically blurs (defocuses) the currently focused component.\n     * If a component item is focused, then it is blurred and and the item emits a blur event\n     *\n     * @param item - The component item to be blurred\n     * @param suppressEvent - Whether to emit blur event\n     */\n    clearComponentFocus(suppressEvent = false) {\n        this.setFocusedComponentItem(undefined, suppressEvent);\n    }\n    /**\n     * Programmatically focuses a component item or removes focus (blurs) from an existing focused component item.\n     *\n     * @param item - If defined, specifies the component item to be given focus.  If undefined, clear component focus.\n     * @param suppressEvents - Whether to emit focus and blur events\n     * @internal\n     */\n    setFocusedComponentItem(item, suppressEvents = false) {\n        if (item !== this._focusedComponentItem) {\n            let newFocusedParentItem;\n            if (item === undefined) {\n                newFocusedParentItem === undefined;\n            }\n            else {\n                newFocusedParentItem = item.parentItem;\n            }\n            if (this._focusedComponentItem !== undefined) {\n                const oldFocusedItem = this._focusedComponentItem;\n                this._focusedComponentItem = undefined;\n                oldFocusedItem.setBlurred(suppressEvents);\n                const oldFocusedParentItem = oldFocusedItem.parentItem;\n                if (newFocusedParentItem === oldFocusedParentItem) {\n                    newFocusedParentItem = undefined;\n                }\n                else {\n                    oldFocusedParentItem.setFocusedValue(false);\n                }\n            }\n            if (item !== undefined) {\n                this._focusedComponentItem = item;\n                item.setFocused(suppressEvents);\n                if (newFocusedParentItem !== undefined) {\n                    newFocusedParentItem.setFocusedValue(true);\n                }\n            }\n        }\n    }\n    /** @internal */\n    createContentItemFromConfig(config, parent) {\n        switch (config.type) {\n            case _utils_types__WEBPACK_IMPORTED_MODULE_11__.ItemType.ground: throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.AssertError('LMCCIFC68871');\n            case _utils_types__WEBPACK_IMPORTED_MODULE_11__.ItemType.row: return new _items_row_or_column__WEBPACK_IMPORTED_MODULE_18__.RowOrColumn(false, this, config, parent);\n            case _utils_types__WEBPACK_IMPORTED_MODULE_11__.ItemType.column: return new _items_row_or_column__WEBPACK_IMPORTED_MODULE_18__.RowOrColumn(true, this, config, parent);\n            case _utils_types__WEBPACK_IMPORTED_MODULE_11__.ItemType.stack: return new _items_stack__WEBPACK_IMPORTED_MODULE_14__.Stack(this, config, parent);\n            case _utils_types__WEBPACK_IMPORTED_MODULE_11__.ItemType.component:\n                return new _items_component_item__WEBPACK_IMPORTED_MODULE_19__.ComponentItem(this, config, parent);\n            default:\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnreachableCaseError('CCC913564', config.type, 'Invalid Config Item type specified');\n        }\n    }\n    /**\n     * This should only be called from stack component.\n     * Stack will look after docking processing associated with maximise/minimise\n     * @internal\n     **/\n    setMaximisedStack(stack) {\n        if (stack === undefined) {\n            if (this._maximisedStack !== undefined) {\n                this.processMinimiseMaximisedStack();\n            }\n        }\n        else {\n            if (stack !== this._maximisedStack) {\n                if (this._maximisedStack !== undefined) {\n                    this.processMinimiseMaximisedStack();\n                }\n                this.processMaximiseStack(stack);\n            }\n        }\n    }\n    checkMinimiseMaximisedStack() {\n        if (this._maximisedStack !== undefined) {\n            this._maximisedStack.minimise();\n        }\n    }\n    // showAllActiveContentItems() was called from ContentItem.show().  Not sure what its purpose was so have commented out\n    // Everything seems to work ok without this.  Have left commented code just in case there was a reason for it becomes\n    // apparent\n    // /** @internal */\n    // showAllActiveContentItems(): void {\n    //     const allStacks = this.getAllStacks();\n    //     for (let i = 0; i < allStacks.length; i++) {\n    //         const stack = allStacks[i];\n    //         const activeContentItem = stack.getActiveComponentItem();\n    //         if (activeContentItem !== undefined) {\n    //             if (!(activeContentItem instanceof ComponentItem)) {\n    //                 throw new AssertError('LMSAACIS22298');\n    //             } else {\n    //                 activeContentItem.container.show();\n    //             }\n    //         }\n    //     }\n    // }\n    // hideAllActiveContentItems() was called from ContentItem.hide().  Not sure what its purpose was so have commented out\n    // Everything seems to work ok without this.  Have left commented code just in case there was a reason for it becomes\n    // apparent\n    // /** @internal */\n    // hideAllActiveContentItems(): void {\n    //     const allStacks = this.getAllStacks();\n    //     for (let i = 0; i < allStacks.length; i++) {\n    //         const stack = allStacks[i];\n    //         const activeContentItem = stack.getActiveComponentItem();\n    //         if (activeContentItem !== undefined) {\n    //             if (!(activeContentItem instanceof ComponentItem)) {\n    //                 throw new AssertError('LMSAACIH22298');\n    //             } else {\n    //                 activeContentItem.container.hide();\n    //             }\n    //         }\n    //     }\n    // }\n    /** @internal */\n    cleanupBeforeMaximisedStackDestroyed(event) {\n        if (this._maximisedStack !== null && this._maximisedStack === event.target) {\n            this._maximisedStack.off('beforeItemDestroyed', this._maximisedStackBeforeDestroyedListener);\n            this._maximisedStack = undefined;\n        }\n    }\n    /**\n     * This method is used to get around sandboxed iframe restrictions.\n     * If 'allow-top-navigation' is not specified in the iframe's 'sandbox' attribute\n     * (as is the case with codepens) the parent window is forbidden from calling certain\n     * methods on the child, such as window.close() or setting document.location.href.\n     *\n     * This prevented GoldenLayout popouts from popping in in codepens. The fix is to call\n     * _$closeWindow on the child window's gl instance which (after a timeout to disconnect\n     * the invoking method from the close call) closes itself.\n     *\n     * @internal\n     */\n    closeWindow() {\n        globalThis.setTimeout(() => globalThis.close(), 1);\n    }\n    /** @internal */\n    getArea(x, y) {\n        let matchingArea = null;\n        let smallestSurface = Infinity;\n        for (let i = 0; i < this._itemAreas.length; i++) {\n            const area = this._itemAreas[i];\n            if (x >= area.x1 &&\n                x < area.x2 && // x2 is not included in area\n                y >= area.y1 &&\n                y < area.y2 && // y2 is not included in area\n                smallestSurface > area.surface) {\n                smallestSurface = area.surface;\n                matchingArea = area;\n            }\n        }\n        return matchingArea;\n    }\n    /** @internal */\n    calculateItemAreas() {\n        const allContentItems = this.getAllContentItems();\n        /**\n         * If the last item is dragged out, highlight the entire container size to\n         * allow to re-drop it. this.ground.contentiItems.length === 0 at this point\n         *\n         * Don't include ground into the possible drop areas though otherwise since it\n         * will used for every gap in the layout, e.g. splitters\n         */\n        const groundItem = this._groundItem;\n        if (groundItem === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnexpectedUndefinedError('LMCIAR44365');\n        }\n        else {\n            if (allContentItems.length === 1) {\n                // No root ContentItem (just Ground ContentItem)\n                const groundArea = groundItem.getElementArea();\n                if (groundArea === null) {\n                    throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnexpectedNullError('LMCIARA44365');\n                }\n                else {\n                    this._itemAreas = [groundArea];\n                }\n                return;\n            }\n            else {\n                if (groundItem.contentItems[0].isStack) {\n                    // if root is Stack, then split stack and sides of Layout are same, so skip sides\n                    this._itemAreas = [];\n                }\n                else {\n                    // sides of layout\n                    this._itemAreas = groundItem.createSideAreas();\n                }\n                for (let i = 0; i < allContentItems.length; i++) {\n                    const stack = allContentItems[i];\n                    if (_items_content_item__WEBPACK_IMPORTED_MODULE_10__.ContentItem.isStack(stack)) {\n                        const area = stack.getArea();\n                        if (area === null) {\n                            continue;\n                        }\n                        else {\n                            this._itemAreas.push(area);\n                            const stackContentAreaDimensions = stack.contentAreaDimensions;\n                            if (stackContentAreaDimensions === undefined) {\n                                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnexpectedUndefinedError('LMCIASC45599');\n                            }\n                            else {\n                                const highlightArea = stackContentAreaDimensions.header.highlightArea;\n                                const surface = (highlightArea.x2 - highlightArea.x1) * (highlightArea.y2 - highlightArea.y1);\n                                const header = {\n                                    x1: highlightArea.x1,\n                                    x2: highlightArea.x2,\n                                    y1: highlightArea.y1,\n                                    y2: highlightArea.y2,\n                                    contentItem: stack,\n                                    surface,\n                                };\n                                this._itemAreas.push(header);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Called as part of loading a new layout (including initial init()).\n     * Checks to see layout has a maximised item. If so, it maximises that item.\n     * @internal\n     */\n    checkLoadedLayoutMaximiseItem() {\n        if (this._groundItem === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnexpectedUndefinedError('LMCLLMI43432');\n        }\n        else {\n            const configMaximisedItems = this._groundItem.getConfigMaximisedItems();\n            if (configMaximisedItems.length > 0) {\n                let item = configMaximisedItems[0];\n                if (_items_content_item__WEBPACK_IMPORTED_MODULE_10__.ContentItem.isComponentItem(item)) {\n                    const stack = item.parent;\n                    if (stack === null) {\n                        throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnexpectedNullError('LMXLLMI69999');\n                    }\n                    else {\n                        item = stack;\n                    }\n                }\n                if (!_items_content_item__WEBPACK_IMPORTED_MODULE_10__.ContentItem.isStack(item)) {\n                    throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.AssertError('LMCLLMI19993');\n                }\n                else {\n                    item.maximise();\n                }\n            }\n        }\n    }\n    /** @internal */\n    processMaximiseStack(stack) {\n        this._maximisedStack = stack;\n        stack.on('beforeItemDestroyed', this._maximisedStackBeforeDestroyedListener);\n        stack.element.classList.add(\"lm_maximised\" /* Maximised */);\n        stack.element.insertAdjacentElement('afterend', this._maximisePlaceholder);\n        if (this._groundItem === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnexpectedUndefinedError('LMMXI19993');\n        }\n        else {\n            this._groundItem.element.prepend(stack.element);\n            const { width, height } = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_12__.getElementWidthAndHeight)(this._containerElement);\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_12__.setElementWidth)(stack.element, width);\n            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_12__.setElementHeight)(stack.element, height);\n            stack.updateSize(true);\n            stack.focusActiveContentItem();\n            this._maximisedStack.emit('maximised');\n            this.emit('stateChanged');\n        }\n    }\n    /** @internal */\n    processMinimiseMaximisedStack() {\n        if (this._maximisedStack === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.AssertError('LMMMS74422');\n        }\n        else {\n            const stack = this._maximisedStack;\n            if (stack.parent === null) {\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnexpectedNullError('LMMI13668');\n            }\n            else {\n                stack.element.classList.remove(\"lm_maximised\" /* Maximised */);\n                this._maximisePlaceholder.insertAdjacentElement('afterend', stack.element);\n                this._maximisePlaceholder.remove();\n                this.updateRootSize(true);\n                this._maximisedStack = undefined;\n                stack.off('beforeItemDestroyed', this._maximisedStackBeforeDestroyedListener);\n                stack.emit('minimised');\n                this.emit('stateChanged');\n            }\n        }\n    }\n    /**\n     * Iterates through the array of open popout windows and removes the ones\n     * that are effectively closed. This is necessary due to the lack of reliably\n     * listening for window.close / unload events in a cross browser compatible fashion.\n     * @internal\n     */\n    reconcilePopoutWindows() {\n        const openPopouts = [];\n        for (let i = 0; i < this._openPopouts.length; i++) {\n            if (this._openPopouts[i].getWindow().closed === false) {\n                openPopouts.push(this._openPopouts[i]);\n            }\n            else {\n                this.emit('windowClosed', this._openPopouts[i]);\n            }\n        }\n        if (this._openPopouts.length !== openPopouts.length) {\n            this._openPopouts = openPopouts;\n            this.emit('stateChanged');\n        }\n    }\n    /**\n     * Returns a flattened array of all content items,\n     * regardles of level or type\n     * @internal\n     */\n    getAllContentItems() {\n        if (this._groundItem === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnexpectedUndefinedError('LMGACI13130');\n        }\n        else {\n            return this._groundItem.getAllContentItems();\n        }\n    }\n    /**\n     * Creates Subwindows (if there are any). Throws an error\n     * if popouts are blocked.\n     * @internal\n     */\n    createSubWindows() {\n        for (let i = 0; i < this.layoutConfig.openPopouts.length; i++) {\n            const popoutConfig = this.layoutConfig.openPopouts[i];\n            this.createPopoutFromPopoutLayoutConfig(popoutConfig);\n        }\n    }\n    /**\n     * Debounces resize events\n     * @internal\n     */\n    handleContainerResize() {\n        if (this.resizeWithContainerAutomatically) {\n            this.processResizeWithDebounce();\n        }\n    }\n    /**\n     * Debounces resize events\n     * @internal\n     */\n    processResizeWithDebounce() {\n        if (this.resizeDebounceExtendedWhenPossible) {\n            this.checkClearResizeTimeout();\n        }\n        if (this._resizeTimeoutId === undefined) {\n            this._resizeTimeoutId = setTimeout(() => {\n                this._resizeTimeoutId = undefined;\n                this.beginSizeInvalidation();\n                this.endSizeInvalidation();\n            }, this.resizeDebounceInterval);\n        }\n    }\n    checkClearResizeTimeout() {\n        if (this._resizeTimeoutId !== undefined) {\n            clearTimeout(this._resizeTimeoutId);\n            this._resizeTimeoutId = undefined;\n        }\n    }\n    /**\n     * Determines what element the layout will be created in\n     * @internal\n     */\n    setContainer() {\n        var _a;\n        const bodyElement = document.body;\n        const containerElement = (_a = this._containerElement) !== null && _a !== void 0 ? _a : bodyElement;\n        if (containerElement === bodyElement) {\n            this.resizeWithContainerAutomatically = true;\n            const documentElement = document.documentElement;\n            documentElement.style.height = '100%';\n            documentElement.style.margin = '0';\n            documentElement.style.padding = '0';\n            documentElement.style.overflow = 'clip';\n            bodyElement.style.height = '100%';\n            bodyElement.style.margin = '0';\n            bodyElement.style.padding = '0';\n            bodyElement.style.overflow = 'clip';\n        }\n        this._containerElement = containerElement;\n    }\n    /**\n     * Called when the window is closed or the user navigates away\n     * from the page\n     * @internal\n     * @deprecated to be removed in version 3\n     */\n    onBeforeUnload() {\n        this.destroy();\n    }\n    /**\n     * Adjusts the number of columns to be lower to fit the screen and still maintain minItemWidth.\n     * @internal\n     */\n    adjustColumnsResponsive() {\n        if (this._groundItem === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnexpectedUndefinedError('LMACR20883');\n        }\n        else {\n            this._firstLoad = false;\n            // If there is no min width set, or not content items, do nothing.\n            if (this.useResponsiveLayout() &&\n                !this._updatingColumnsResponsive &&\n                this._groundItem.contentItems.length > 0 &&\n                this._groundItem.contentItems[0].isRow) {\n                if (this._groundItem === undefined || this._width === null) {\n                    throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnexpectedUndefinedError('LMACR77412');\n                }\n                else {\n                    // If there is only one column, do nothing.\n                    const columnCount = this._groundItem.contentItems[0].contentItems.length;\n                    if (columnCount <= 1) {\n                        return;\n                    }\n                    else {\n                        // If they all still fit, do nothing.\n                        const minItemWidth = this.layoutConfig.dimensions.defaultMinItemWidth;\n                        const totalMinWidth = columnCount * minItemWidth;\n                        if (totalMinWidth <= this._width) {\n                            return;\n                        }\n                        else {\n                            // Prevent updates while it is already happening.\n                            this._updatingColumnsResponsive = true;\n                            // Figure out how many columns to stack, and put them all in the first stack container.\n                            const finalColumnCount = Math.max(Math.floor(this._width / minItemWidth), 1);\n                            const stackColumnCount = columnCount - finalColumnCount;\n                            const rootContentItem = this._groundItem.contentItems[0];\n                            const allStacks = this.getAllStacks();\n                            if (allStacks.length === 0) {\n                                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.AssertError('LMACRS77413');\n                            }\n                            else {\n                                const firstStackContainer = allStacks[0];\n                                for (let i = 0; i < stackColumnCount; i++) {\n                                    // Stack from right.\n                                    const column = rootContentItem.contentItems[rootContentItem.contentItems.length - 1];\n                                    this.addChildContentItemsToContainer(firstStackContainer, column);\n                                }\n                                this._updatingColumnsResponsive = false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Determines if responsive layout should be used.\n     *\n     * @returns True if responsive layout should be used; otherwise false.\n     * @internal\n     */\n    useResponsiveLayout() {\n        const settings = this.layoutConfig.settings;\n        const alwaysResponsiveMode = settings.responsiveMode === _utils_types__WEBPACK_IMPORTED_MODULE_11__.ResponsiveMode.always;\n        const onLoadResponsiveModeAndFirst = settings.responsiveMode === _utils_types__WEBPACK_IMPORTED_MODULE_11__.ResponsiveMode.onload && this._firstLoad;\n        return alwaysResponsiveMode || onLoadResponsiveModeAndFirst;\n    }\n    /**\n     * Adds all children of a node to another container recursively.\n     * @param container - Container to add child content items to.\n     * @param node - Node to search for content items.\n     * @internal\n     */\n    addChildContentItemsToContainer(container, node) {\n        const contentItems = node.contentItems;\n        if (node instanceof _items_stack__WEBPACK_IMPORTED_MODULE_14__.Stack) {\n            for (let i = 0; i < contentItems.length; i++) {\n                const item = contentItems[i];\n                node.removeChild(item, true);\n                container.addChild(item);\n            }\n        }\n        else {\n            for (let i = 0; i < contentItems.length; i++) {\n                const item = contentItems[i];\n                this.addChildContentItemsToContainer(container, item);\n            }\n        }\n    }\n    /**\n     * Finds all the stacks.\n     * @returns The found stack containers.\n     * @internal\n     */\n    getAllStacks() {\n        if (this._groundItem === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnexpectedUndefinedError('LMFASC52778');\n        }\n        else {\n            const stacks = [];\n            this.findAllStacksRecursive(stacks, this._groundItem);\n            return stacks;\n        }\n    }\n    /** @internal */\n    findFirstContentItemType(type) {\n        if (this._groundItem === undefined) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnexpectedUndefinedError('LMFFCIT82446');\n        }\n        else {\n            return this.findFirstContentItemTypeRecursive(type, this._groundItem);\n        }\n    }\n    /** @internal */\n    findFirstContentItemTypeRecursive(type, node) {\n        const contentItems = node.contentItems;\n        const contentItemCount = contentItems.length;\n        if (contentItemCount === 0) {\n            return undefined;\n        }\n        else {\n            for (let i = 0; i < contentItemCount; i++) {\n                const contentItem = contentItems[i];\n                if (contentItem.type === type) {\n                    return contentItem;\n                }\n            }\n            for (let i = 0; i < contentItemCount; i++) {\n                const contentItem = contentItems[i];\n                const foundContentItem = this.findFirstContentItemTypeRecursive(type, contentItem);\n                if (foundContentItem !== undefined) {\n                    return foundContentItem;\n                }\n            }\n            return undefined;\n        }\n    }\n    /** @internal */\n    findFirstContentItemTypeByIdRecursive(type, id, node) {\n        const contentItems = node.contentItems;\n        const contentItemCount = contentItems.length;\n        if (contentItemCount === 0) {\n            return undefined;\n        }\n        else {\n            for (let i = 0; i < contentItemCount; i++) {\n                const contentItem = contentItems[i];\n                if (contentItem.type === type && contentItem.id === id) {\n                    return contentItem;\n                }\n            }\n            for (let i = 0; i < contentItemCount; i++) {\n                const contentItem = contentItems[i];\n                const foundContentItem = this.findFirstContentItemTypeByIdRecursive(type, id, contentItem);\n                if (foundContentItem !== undefined) {\n                    return foundContentItem;\n                }\n            }\n            return undefined;\n        }\n    }\n    /**\n     * Finds all the stack containers.\n     *\n     * @param stacks - Set of containers to populate.\n     * @param node - Current node to process.\n     * @internal\n     */\n    findAllStacksRecursive(stacks, node) {\n        const contentItems = node.contentItems;\n        for (let i = 0; i < contentItems.length; i++) {\n            const item = contentItems[i];\n            if (item instanceof _items_stack__WEBPACK_IMPORTED_MODULE_14__.Stack) {\n                stacks.push(item);\n            }\n            else {\n                if (!item.isComponent) {\n                    this.findAllStacksRecursive(stacks, item);\n                }\n            }\n        }\n    }\n    /** @internal */\n    findFirstLocation(selectors) {\n        const count = selectors.length;\n        for (let i = 0; i < count; i++) {\n            const selector = selectors[i];\n            const location = this.findLocation(selector);\n            if (location !== undefined) {\n                return location;\n            }\n        }\n        return undefined;\n    }\n    /** @internal */\n    findLocation(selector) {\n        const selectorIndex = selector.index;\n        switch (selector.typeId) {\n            case 0 /* FocusedItem */: {\n                if (this._focusedComponentItem === undefined) {\n                    return undefined;\n                }\n                else {\n                    const parentItem = this._focusedComponentItem.parentItem;\n                    const parentContentItems = parentItem.contentItems;\n                    const parentContentItemCount = parentContentItems.length;\n                    if (selectorIndex === undefined) {\n                        return { parentItem, index: parentContentItemCount };\n                    }\n                    else {\n                        const focusedIndex = parentContentItems.indexOf(this._focusedComponentItem);\n                        const index = focusedIndex + selectorIndex;\n                        if (index < 0 || index > parentContentItemCount) {\n                            return undefined;\n                        }\n                        else {\n                            return { parentItem, index };\n                        }\n                    }\n                }\n            }\n            case 1 /* FocusedStack */: {\n                if (this._focusedComponentItem === undefined) {\n                    return undefined;\n                }\n                else {\n                    const parentItem = this._focusedComponentItem.parentItem;\n                    return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                }\n            }\n            case 2 /* FirstStack */: {\n                const parentItem = this.findFirstContentItemType(_utils_types__WEBPACK_IMPORTED_MODULE_11__.ItemType.stack);\n                if (parentItem === undefined) {\n                    return undefined;\n                }\n                else {\n                    return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                }\n            }\n            case 3 /* FirstRowOrColumn */: {\n                let parentItem = this.findFirstContentItemType(_utils_types__WEBPACK_IMPORTED_MODULE_11__.ItemType.row);\n                if (parentItem !== undefined) {\n                    return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                }\n                else {\n                    parentItem = this.findFirstContentItemType(_utils_types__WEBPACK_IMPORTED_MODULE_11__.ItemType.column);\n                    if (parentItem !== undefined) {\n                        return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                    }\n                    else {\n                        return undefined;\n                    }\n                }\n            }\n            case 4 /* FirstRow */: {\n                const parentItem = this.findFirstContentItemType(_utils_types__WEBPACK_IMPORTED_MODULE_11__.ItemType.row);\n                if (parentItem === undefined) {\n                    return undefined;\n                }\n                else {\n                    return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                }\n            }\n            case 5 /* FirstColumn */: {\n                const parentItem = this.findFirstContentItemType(_utils_types__WEBPACK_IMPORTED_MODULE_11__.ItemType.column);\n                if (parentItem === undefined) {\n                    return undefined;\n                }\n                else {\n                    return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                }\n            }\n            case 6 /* Empty */: {\n                if (this._groundItem === undefined) {\n                    throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnexpectedUndefinedError('LMFLRIF18244');\n                }\n                else {\n                    if (this.rootItem !== undefined) {\n                        return undefined;\n                    }\n                    else {\n                        if (selectorIndex === undefined || selectorIndex === 0)\n                            return { parentItem: this._groundItem, index: 0 };\n                        else {\n                            return undefined;\n                        }\n                    }\n                }\n            }\n            case 7 /* Root */: {\n                if (this._groundItem === undefined) {\n                    throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_7__.UnexpectedUndefinedError('LMFLF18244');\n                }\n                else {\n                    const groundContentItems = this._groundItem.contentItems;\n                    if (groundContentItems.length === 0) {\n                        if (selectorIndex === undefined || selectorIndex === 0)\n                            return { parentItem: this._groundItem, index: 0 };\n                        else {\n                            return undefined;\n                        }\n                    }\n                    else {\n                        const parentItem = groundContentItems[0];\n                        return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                    }\n                }\n            }\n        }\n    }\n    /** @internal */\n    tryCreateLocationFromParentItem(parentItem, selectorIndex) {\n        const parentContentItems = parentItem.contentItems;\n        const parentContentItemCount = parentContentItems.length;\n        if (selectorIndex === undefined) {\n            return { parentItem, index: parentContentItemCount };\n        }\n        else {\n            if (selectorIndex < 0 || selectorIndex > parentContentItemCount) {\n                return undefined;\n            }\n            else {\n                return { parentItem, index: selectorIndex };\n            }\n        }\n    }\n}\n/** @public */\n(function (LayoutManager) {\n    /** @internal */\n    function createMaximisePlaceElement(document) {\n        const element = document.createElement('div');\n        element.classList.add(\"lm_maximise_place\" /* MaximisePlace */);\n        return element;\n    }\n    LayoutManager.createMaximisePlaceElement = createMaximisePlaceElement;\n    /** @internal */\n    function createTabDropPlaceholderElement(document) {\n        const element = document.createElement('div');\n        element.classList.add(\"lm_drop_tab_placeholder\" /* DropTabPlaceholder */);\n        return element;\n    }\n    LayoutManager.createTabDropPlaceholderElement = createTabDropPlaceholderElement;\n    /**\n     * Default LocationSelectors array used if none is specified.  Will always find a location.\n     * @public\n     */\n    LayoutManager.defaultLocationSelectors = [\n        { typeId: 1 /* FocusedStack */, index: undefined },\n        { typeId: 2 /* FirstStack */, index: undefined },\n        { typeId: 3 /* FirstRowOrColumn */, index: undefined },\n        { typeId: 7 /* Root */, index: undefined },\n    ];\n    /**\n     * LocationSelectors to try to get location next to existing focused item\n     * @public\n     */\n    LayoutManager.afterFocusedItemIfPossibleLocationSelectors = [\n        { typeId: 0 /* FocusedItem */, index: 1 },\n        { typeId: 2 /* FirstStack */, index: undefined },\n        { typeId: 3 /* FirstRowOrColumn */, index: undefined },\n        { typeId: 7 /* Root */, index: undefined },\n    ];\n})(LayoutManager || (LayoutManager = {}));\n//# sourceMappingURL=layout-manager.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/layout-manager.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/utils/config-minifier.js":
/*!*************************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/utils/config-minifier.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConfigMinifier: () => (/* binding */ ConfigMinifier)\n/* harmony export */ });\n/**\n * Minifies and unminifies configs by replacing frequent keys\n * and values with one letter substitutes. Config options must\n * retain array position/index, add new options at the end.\n * @internal\n*/\nvar ConfigMinifier;\n(function (ConfigMinifier) {\n    const keys = [\n        'settings',\n        'hasHeaders',\n        'constrainDragToContainer',\n        'selectionEnabled',\n        'dimensions',\n        'borderWidth',\n        'minItemHeight',\n        'minItemWidth',\n        'headerHeight',\n        'dragProxyWidth',\n        'dragProxyHeight',\n        'labels',\n        'close',\n        'maximise',\n        'minimise',\n        'popout',\n        'content',\n        'componentType',\n        'componentState',\n        'id',\n        'width',\n        'type',\n        'height',\n        'isClosable',\n        'title',\n        'popoutWholeStack',\n        'openPopouts',\n        'parentId',\n        'activeItemIndex',\n        'reorderEnabled',\n        'borderGrabWidth',\n        //Maximum 36 entries, do not cross this line!\n    ];\n    const values = [\n        true,\n        false,\n        'row',\n        'column',\n        'stack',\n        'component',\n        'close',\n        'maximise',\n        'minimise',\n        'open in new window'\n    ];\n    function checkInitialise() {\n        if (keys.length > 36) {\n            throw new Error('Too many keys in config minifier map');\n        }\n    }\n    ConfigMinifier.checkInitialise = checkInitialise;\n    function translateObject(from, minify) {\n        const to = {};\n        for (const key in from) {\n            if (from.hasOwnProperty(key)) { // In case something has extended Object prototypes\n                let translatedKey;\n                if (minify) {\n                    translatedKey = minifyKey(key);\n                }\n                else {\n                    translatedKey = unminifyKey(key);\n                }\n                const fromValue = from[key];\n                to[translatedKey] = translateValue(fromValue, minify);\n            }\n        }\n        return to;\n    }\n    ConfigMinifier.translateObject = translateObject;\n    function translateArray(from, minify) {\n        const length = from.length;\n        const to = new Array(length);\n        for (let i = 0; i < length; i++) {\n            // In original code, array indices were numbers and not translated\n            const fromValue = from[i];\n            to[i] = translateValue(fromValue, minify);\n        }\n        return to;\n    }\n    function translateValue(from, minify) {\n        if (typeof from === 'object') {\n            if (from === null) {\n                return null;\n            }\n            else {\n                if (Array.isArray(from)) {\n                    return translateArray(from, minify);\n                }\n                else {\n                    return translateObject(from, minify);\n                }\n            }\n        }\n        else {\n            if (minify) {\n                return minifyValue(from);\n            }\n            else {\n                return unminifyValue(from);\n            }\n        }\n    }\n    function minifyKey(value) {\n        /**\n         * If a value actually is a single character, prefix it\n         * with ___ to avoid mistaking it for a minification code\n         */\n        if (typeof value === 'string' && value.length === 1) {\n            return '___' + value;\n        }\n        const index = indexOfKey(value);\n        /**\n         * value not found in the dictionary, return it unmodified\n         */\n        if (index === -1) {\n            return value;\n            /**\n             * value found in dictionary, return its base36 counterpart\n             */\n        }\n        else {\n            return index.toString(36);\n        }\n    }\n    function unminifyKey(key) {\n        /**\n         * value is a single character. Assume that it's a translation\n         * and return the original value from the dictionary\n         */\n        if (key.length === 1) {\n            return keys[parseInt(key, 36)];\n        }\n        /**\n         * value originally was a single character and was prefixed with ___\n         * to avoid mistaking it for a translation. Remove the prefix\n         * and return the original character\n         */\n        if (key.substr(0, 3) === '___') {\n            return key[3];\n        }\n        /**\n         * value was not minified\n         */\n        return key;\n    }\n    function minifyValue(value) {\n        /**\n         * If a value actually is a single character, prefix it\n         * with ___ to avoid mistaking it for a minification code\n         */\n        if (typeof value === 'string' && value.length === 1) {\n            return '___' + value;\n        }\n        const index = indexOfValue(value);\n        /**\n         * value not found in the dictionary, return it unmodified\n         */\n        if (index === -1) {\n            return value;\n            /**\n             * value found in dictionary, return its base36 counterpart\n             */\n        }\n        else {\n            return index.toString(36);\n        }\n    }\n    function unminifyValue(value) {\n        /**\n         * value is a single character. Assume that it's a translation\n         * and return the original value from the dictionary\n         */\n        if (typeof value === 'string' && value.length === 1) {\n            return values[parseInt(value, 36)];\n        }\n        /**\n         * value originally was a single character and was prefixed with ___\n         * to avoid mistaking it for a translation. Remove the prefix\n         * and return the original character\n         */\n        if (typeof value === 'string' && value.substr(0, 3) === '___') {\n            return value[3];\n        }\n        /**\n         * value was not minified\n         */\n        return value;\n    }\n    function indexOfKey(key) {\n        for (let i = 0; i < keys.length; i++) {\n            if (keys[i] === key) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    function indexOfValue(value) {\n        for (let i = 0; i < values.length; i++) {\n            if (values[i] === value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n})(ConfigMinifier || (ConfigMinifier = {}));\n//# sourceMappingURL=config-minifier.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/utils/config-minifier.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/utils/drag-listener.js":
/*!***********************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/utils/drag-listener.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DragListener: () => (/* binding */ DragListener)\n/* harmony export */ });\n/* harmony import */ var _event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event-emitter */ \"./node_modules/golden-layout/dist/esm/ts/utils/event-emitter.js\");\n\n/** @internal */\nclass DragListener extends _event_emitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor(_eElement, extraAllowableChildTargets) {\n        super();\n        this._eElement = _eElement;\n        this._pointerTracking = false;\n        this._pointerDownEventListener = (ev) => this.onPointerDown(ev);\n        this._pointerMoveEventListener = (ev) => this.onPointerMove(ev);\n        this._pointerUpEventListener = (ev) => this.onPointerUp(ev);\n        this._timeout = undefined;\n        this._allowableTargets = [_eElement, ...extraAllowableChildTargets];\n        this._oDocument = document;\n        this._eBody = document.body;\n        /**\n         * The delay after which to start the drag in milliseconds\n         * Do NOT make too short (previous value of 200 was not long enough for my touchpad)\n         * Should generally rely on the mouse move to start drag.  Not this delay.\n         */\n        this._nDelay = 1800;\n        /**\n         * The distance the mouse needs to be moved to qualify as a drag\n         * Previous comment: works better with delay only\n         * ???\n         * Probably somehow needs tuning for different devices\n         */\n        this._nDistance = 10;\n        this._nX = 0;\n        this._nY = 0;\n        this._nOriginalX = 0;\n        this._nOriginalY = 0;\n        this._dragging = false;\n        this._eElement.addEventListener('pointerdown', this._pointerDownEventListener, { passive: true });\n    }\n    destroy() {\n        this.checkRemovePointerTrackingEventListeners();\n        this._eElement.removeEventListener('pointerdown', this._pointerDownEventListener);\n    }\n    cancelDrag() {\n        this.processDragStop(undefined);\n    }\n    onPointerDown(oEvent) {\n        if (this._allowableTargets.includes(oEvent.target) && oEvent.isPrimary) {\n            const coordinates = this.getPointerCoordinates(oEvent);\n            this.processPointerDown(coordinates);\n        }\n    }\n    processPointerDown(coordinates) {\n        this._nOriginalX = coordinates.x;\n        this._nOriginalY = coordinates.y;\n        this._oDocument.addEventListener('pointermove', this._pointerMoveEventListener);\n        this._oDocument.addEventListener('pointerup', this._pointerUpEventListener, { passive: true });\n        this._pointerTracking = true;\n        this._timeout = setTimeout(() => {\n            try {\n                this.startDrag();\n            }\n            catch (err) {\n                console.error(err);\n                throw err;\n            }\n        }, this._nDelay);\n    }\n    onPointerMove(oEvent) {\n        if (this._pointerTracking) {\n            this.processDragMove(oEvent);\n            oEvent.preventDefault();\n        }\n    }\n    processDragMove(dragEvent) {\n        this._nX = dragEvent.pageX - this._nOriginalX;\n        this._nY = dragEvent.pageY - this._nOriginalY;\n        if (this._dragging === false) {\n            if (Math.abs(this._nX) > this._nDistance ||\n                Math.abs(this._nY) > this._nDistance) {\n                this.startDrag();\n            }\n        }\n        if (this._dragging) {\n            this.emit('drag', this._nX, this._nY, dragEvent);\n        }\n    }\n    onPointerUp(oEvent) {\n        this.processDragStop(oEvent);\n    }\n    processDragStop(dragEvent) {\n        var _a;\n        if (this._timeout !== undefined) {\n            clearTimeout(this._timeout);\n            this._timeout = undefined;\n        }\n        this.checkRemovePointerTrackingEventListeners();\n        if (this._dragging === true) {\n            this._eBody.classList.remove(\"lm_dragging\" /* Dragging */);\n            this._eElement.classList.remove(\"lm_dragging\" /* Dragging */);\n            (_a = this._oDocument.querySelector('iframe')) === null || _a === void 0 ? void 0 : _a.style.setProperty('pointer-events', '');\n            this._dragging = false;\n            this.emit('dragStop', dragEvent);\n        }\n    }\n    checkRemovePointerTrackingEventListeners() {\n        if (this._pointerTracking) {\n            this._oDocument.removeEventListener('pointermove', this._pointerMoveEventListener);\n            this._oDocument.removeEventListener('pointerup', this._pointerUpEventListener);\n            this._pointerTracking = false;\n        }\n    }\n    startDrag() {\n        var _a;\n        if (this._timeout !== undefined) {\n            clearTimeout(this._timeout);\n            this._timeout = undefined;\n        }\n        this._dragging = true;\n        this._eBody.classList.add(\"lm_dragging\" /* Dragging */);\n        this._eElement.classList.add(\"lm_dragging\" /* Dragging */);\n        (_a = this._oDocument.querySelector('iframe')) === null || _a === void 0 ? void 0 : _a.style.setProperty('pointer-events', 'none');\n        this.emit('dragStart', this._nOriginalX, this._nOriginalY);\n    }\n    getPointerCoordinates(event) {\n        const result = {\n            x: event.pageX,\n            y: event.pageY\n        };\n        return result;\n    }\n}\n//# sourceMappingURL=drag-listener.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/utils/drag-listener.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/utils/event-emitter.js":
/*!***********************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/utils/event-emitter.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventEmitter: () => (/* binding */ EventEmitter)\n/* harmony export */ });\n/**\n * A generic and very fast EventEmitter implementation. On top of emitting the actual event it emits an\n * {@link (EventEmitter:namespace).ALL_EVENT} event for every event triggered. This allows to hook into it and proxy events forwards\n * @public\n */\nclass EventEmitter {\n    constructor() {\n        /** @internal */\n        this._allEventSubscriptions = [];\n        /** @internal */\n        this._subscriptionsMap = new Map();\n        /**\n         * Alias for off\n         */\n        this.unbind = this.removeEventListener;\n        /**\n         * Alias for emit\n         */\n        this.trigger = this.emit;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    tryBubbleEvent(name, args) {\n        // overridden by ContentItem\n    }\n    /**\n     * Emit an event and notify listeners\n     *\n     * @param eventName - The name of the event\n     * @param args - Additional arguments that will be passed to the listener\n     */\n    emit(eventName, ...args) {\n        let subcriptions = this._subscriptionsMap.get(eventName);\n        if (subcriptions !== undefined) {\n            subcriptions = subcriptions.slice();\n            for (let i = 0; i < subcriptions.length; i++) {\n                const subscription = subcriptions[i];\n                subscription(...args);\n            }\n        }\n        this.emitAllEvent(eventName, args);\n        this.tryBubbleEvent(eventName, args);\n    }\n    /** @internal */\n    emitUnknown(eventName, ...args) {\n        let subs = this._subscriptionsMap.get(eventName);\n        if (subs !== undefined) {\n            subs = subs.slice();\n            for (let i = 0; i < subs.length; i++) {\n                subs[i](...args);\n            }\n        }\n        this.emitAllEvent(eventName, args);\n        this.tryBubbleEvent(eventName, args);\n    }\n    /* @internal **/\n    emitBaseBubblingEvent(eventName) {\n        const event = new EventEmitter.BubblingEvent(eventName, this);\n        this.emitUnknown(eventName, event);\n    }\n    /** @internal */\n    emitUnknownBubblingEvent(eventName) {\n        const event = new EventEmitter.BubblingEvent(eventName, this);\n        this.emitUnknown(eventName, event);\n    }\n    /**\n     * Removes a listener for an event.\n     * @param eventName - The name of the event\n     * @param callback - The previously registered callback method (optional)\n     */\n    removeEventListener(eventName, callback) {\n        const unknownCallback = callback;\n        this.removeUnknownEventListener(eventName, unknownCallback);\n    }\n    off(eventName, callback) {\n        this.removeEventListener(eventName, callback);\n    }\n    /**\n     * Listen for events\n     *\n     * @param eventName - The name of the event to listen to\n     * @param callback - The callback to execute when the event occurs\n     */\n    addEventListener(eventName, callback) {\n        const unknownCallback = callback;\n        this.addUnknownEventListener(eventName, unknownCallback);\n    }\n    on(eventName, callback) {\n        this.addEventListener(eventName, callback);\n    }\n    /** @internal */\n    addUnknownEventListener(eventName, callback) {\n        if (eventName === EventEmitter.ALL_EVENT) {\n            this._allEventSubscriptions.push(callback);\n        }\n        else {\n            let subscriptions = this._subscriptionsMap.get(eventName);\n            if (subscriptions !== undefined) {\n                subscriptions.push(callback);\n            }\n            else {\n                subscriptions = [callback];\n                this._subscriptionsMap.set(eventName, subscriptions);\n            }\n        }\n    }\n    /** @internal */\n    removeUnknownEventListener(eventName, callback) {\n        if (eventName === EventEmitter.ALL_EVENT) {\n            this.removeSubscription(eventName, this._allEventSubscriptions, callback);\n        }\n        else {\n            const subscriptions = this._subscriptionsMap.get(eventName);\n            if (subscriptions === undefined) {\n                throw new Error('No subscribtions to unsubscribe for event ' + eventName);\n            }\n            else {\n                this.removeSubscription(eventName, subscriptions, callback);\n            }\n        }\n    }\n    /** @internal */\n    removeSubscription(eventName, subscriptions, callback) {\n        const idx = subscriptions.indexOf(callback);\n        if (idx < 0) {\n            throw new Error('Nothing to unbind for ' + eventName);\n        }\n        else {\n            subscriptions.splice(idx, 1);\n        }\n    }\n    /** @internal */\n    emitAllEvent(eventName, args) {\n        const allEventSubscriptionsCount = this._allEventSubscriptions.length;\n        if (allEventSubscriptionsCount > 0) {\n            const unknownArgs = args.slice();\n            unknownArgs.unshift(eventName);\n            const allEventSubcriptions = this._allEventSubscriptions.slice();\n            for (let i = 0; i < allEventSubscriptionsCount; i++) {\n                allEventSubcriptions[i](...unknownArgs);\n            }\n        }\n    }\n}\n/** @public */\n(function (EventEmitter) {\n    /**\n     * The name of the event that's triggered for every event\n     */\n    EventEmitter.ALL_EVENT = '__all';\n    EventEmitter.headerClickEventName = 'stackHeaderClick';\n    EventEmitter.headerTouchStartEventName = 'stackHeaderTouchStart';\n    class BubblingEvent {\n        /** @internal */\n        constructor(\n        /** @internal */\n        _name, \n        /** @internal */\n        _target) {\n            this._name = _name;\n            this._target = _target;\n            /** @internal */\n            this._isPropagationStopped = false;\n        }\n        get name() { return this._name; }\n        get target() { return this._target; }\n        /** @deprecated Use {@link (EventEmitter:namespace).(BubblingEvent:class).target} instead */\n        get origin() { return this._target; }\n        get isPropagationStopped() { return this._isPropagationStopped; }\n        stopPropagation() {\n            this._isPropagationStopped = true;\n        }\n    }\n    EventEmitter.BubblingEvent = BubblingEvent;\n    class ClickBubblingEvent extends BubblingEvent {\n        /** @internal */\n        constructor(name, target, \n        /** @internal */\n        _mouseEvent) {\n            super(name, target);\n            this._mouseEvent = _mouseEvent;\n        }\n        get mouseEvent() { return this._mouseEvent; }\n    }\n    EventEmitter.ClickBubblingEvent = ClickBubblingEvent;\n    class TouchStartBubblingEvent extends BubblingEvent {\n        /** @internal */\n        constructor(name, target, \n        /** @internal */\n        _touchEvent) {\n            super(name, target);\n            this._touchEvent = _touchEvent;\n        }\n        get touchEvent() { return this._touchEvent; }\n    }\n    EventEmitter.TouchStartBubblingEvent = TouchStartBubblingEvent;\n})(EventEmitter || (EventEmitter = {}));\n//# sourceMappingURL=event-emitter.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/utils/event-emitter.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/utils/event-hub.js":
/*!*******************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/utils/event-hub.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventHub: () => (/* binding */ EventHub)\n/* harmony export */ });\n/* harmony import */ var _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/internal-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js\");\n/* harmony import */ var _event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event-emitter */ \"./node_modules/golden-layout/dist/esm/ts/utils/event-emitter.js\");\n\n\n/**\n * An EventEmitter singleton that propagates events\n * across multiple windows. This is a little bit trickier since\n * windows are allowed to open childWindows in their own right.\n *\n * This means that we deal with a tree of windows. Therefore, we do the event propagation in two phases:\n *\n * - Propagate events from this layout to the parent layout\n *   - Repeat until the event arrived at the root layout\n * - Propagate events to this layout and to all children\n *   - Repeat until all layouts got the event\n *\n * **WARNING**: Only userBroadcast events are propagated between windows.\n * This means the you have to take care of propagating state changes between windows yourself.\n *\n * @public\n */\nclass EventHub extends _event_emitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    /**\n     * Creates a new EventHub instance\n     * @param _layoutManager - the layout manager to synchronize between the windows\n     * @internal\n     */\n    constructor(\n    /** @internal */\n    _layoutManager) {\n        super();\n        this._layoutManager = _layoutManager;\n        /** @internal */\n        this._childEventListener = (childEvent) => this.onEventFromChild(childEvent);\n        globalThis.addEventListener(EventHub.ChildEventName, this._childEventListener, { passive: true });\n    }\n    /**\n     * Emit an event and notify listeners\n     *\n     * @param eventName - The name of the event\n     * @param args - Additional arguments that will be passed to the listener\n     * @public\n     */\n    emit(eventName, ...args) {\n        if (eventName === 'userBroadcast') {\n            // Explicitly redirect the user broadcast to our overridden method.\n            this.emitUserBroadcast(...args);\n        }\n        else {\n            super.emit(eventName, ...args);\n        }\n    }\n    /**\n     * Broadcasts a message to all other currently opened windows.\n     * @public\n     */\n    emitUserBroadcast(...args) {\n        // Step 1: Bubble up the event\n        this.handleUserBroadcastEvent('userBroadcast', args);\n    }\n    /**\n     * Destroys the EventHub\n     * @internal\n     */\n    destroy() {\n        globalThis.removeEventListener(EventHub.ChildEventName, this._childEventListener);\n    }\n    /**\n     * Internal processor to process local events.\n     * @internal\n     */\n    handleUserBroadcastEvent(eventName, args) {\n        if (this._layoutManager.isSubWindow) {\n            // We are a sub window and received an event from one of our children.\n            // So propagate it to the Root.\n            this.propagateToParent(eventName, args);\n        }\n        else {\n            // We are the root window, propagate it to the subtree below us.\n            this.propagateToThisAndSubtree(eventName, args);\n        }\n    }\n    /**\n     * Callback for child events raised on the window\n     * @internal\n     */\n    onEventFromChild(event) {\n        const detail = event.detail;\n        this.handleUserBroadcastEvent(detail.eventName, detail.args);\n    }\n    /**\n     * Propagates the event to the parent by emitting\n     * it on the parent's DOM window\n     * @internal\n     */\n    propagateToParent(eventName, args) {\n        const detail = {\n            layoutManager: this._layoutManager,\n            eventName,\n            args: args,\n        };\n        const eventInit = {\n            bubbles: true,\n            cancelable: true,\n            detail,\n        };\n        const event = new CustomEvent(EventHub.ChildEventName, eventInit);\n        const opener = globalThis.opener;\n        if (opener === null) {\n            throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.UnexpectedNullError('EHPTP15778');\n        }\n        opener.dispatchEvent(event);\n    }\n    /**\n     * Propagate events to the whole subtree under this event hub.\n     * @internal\n     */\n    propagateToThisAndSubtree(eventName, args) {\n        this.emitUnknown(eventName, ...args);\n        for (let i = 0; i < this._layoutManager.openPopouts.length; i++) {\n            const childGl = this._layoutManager.openPopouts[i].getGlInstance();\n            if (childGl) {\n                childGl.eventHub.propagateToThisAndSubtree(eventName, args);\n            }\n        }\n    }\n}\n/** @public */\n(function (EventHub) {\n    /** @internal */\n    EventHub.ChildEventName = 'gl_child_event';\n})(EventHub || (EventHub = {}));\n//# sourceMappingURL=event-hub.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/utils/event-hub.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/utils/i18n-strings.js":
/*!**********************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/utils/i18n-strings.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I18nStrings: () => (/* binding */ I18nStrings),\n/* harmony export */   i18nStrings: () => (/* binding */ i18nStrings)\n/* harmony export */ });\n/* harmony import */ var _errors_internal_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors/internal-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js\");\n\n/** @public */\nvar I18nStrings;\n(function (I18nStrings) {\n    /** @internal */\n    let initialised = false;\n    /** @internal */\n    const infosObject = {\n        PopoutCannotBeCreatedWithGroundItemConfig: {\n            id: 0 /* PopoutCannotBeCreatedWithGroundItemConfig */,\n            default: 'Popout cannot be created with ground ItemConfig'\n        },\n        PleaseRegisterAConstructorFunction: {\n            id: 1 /* PleaseRegisterAConstructorFunction */,\n            default: 'Please register a constructor function'\n        },\n        ComponentTypeNotRegisteredAndBindComponentEventHandlerNotAssigned: {\n            id: 2 /* ComponentTypeNotRegisteredAndBindComponentEventHandlerNotAssigned */,\n            default: 'Component type not registered and BindComponentEvent handler not assigned',\n        },\n        ComponentIsAlreadyRegistered: {\n            id: 3 /* ComponentIsAlreadyRegistered */,\n            default: 'Component is already registered',\n        },\n        ComponentIsNotVirtuable: {\n            id: 4 /* ComponentIsNotVirtuable */,\n            default: 'Component is not virtuable. Requires rootHtmlElement field/getter',\n        },\n        VirtualComponentDoesNotHaveRootHtmlElement: {\n            id: 5 /* VirtualComponentDoesNotHaveRootHtmlElement */,\n            default: 'Virtual component does not have getter \"rootHtmlElement\"',\n        },\n        ItemConfigIsNotTypeComponent: {\n            id: 6 /* ItemConfigIsNotTypeComponent */,\n            default: 'ItemConfig is not of type component',\n        },\n        InvalidNumberPartInSizeString: {\n            id: 7 /* InvalidNumberPartInSizeString */,\n            default: 'Invalid number part in size string',\n        },\n        UnknownUnitInSizeString: {\n            id: 8 /* UnknownUnitInSizeString */,\n            default: 'Unknown unit in size string',\n        },\n        UnsupportedUnitInSizeString: {\n            id: 9 /* UnsupportedUnitInSizeString */,\n            default: 'Unsupported unit in size string',\n        },\n    };\n    I18nStrings.idCount = Object.keys(infosObject).length;\n    /** @internal */\n    const infos = Object.values(infosObject);\n    function checkInitialise() {\n        if (!initialised) {\n            for (let i = 0; i < I18nStrings.idCount; i++) {\n                const info = infos[i];\n                if (info.id !== i) {\n                    throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_0__.AssertError('INSI00110', `${i}: ${info.id}`);\n                }\n                else {\n                    i18nStrings[i] = info.default;\n                }\n            }\n        }\n        initialised = true;\n    }\n    I18nStrings.checkInitialise = checkInitialise;\n})(I18nStrings || (I18nStrings = {}));\n/** @public */\nconst i18nStrings = new Array(I18nStrings.idCount);\n//# sourceMappingURL=i18n-strings.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/utils/i18n-strings.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/utils/style-constants.js":
/*!*************************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/utils/style-constants.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StyleConstants: () => (/* binding */ StyleConstants)\n/* harmony export */ });\n/** @public */\nvar StyleConstants;\n(function (StyleConstants) {\n    StyleConstants.defaultComponentBaseZIndex = 'auto';\n    StyleConstants.defaultComponentDragZIndex = '32';\n    StyleConstants.defaultComponentStackMaximisedZIndex = '41';\n})(StyleConstants || (StyleConstants = {}));\n//# sourceMappingURL=style-constants.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/utils/style-constants.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/utils/types.js":
/*!***************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/utils/types.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ItemType: () => (/* binding */ ItemType),\n/* harmony export */   JsonValue: () => (/* binding */ JsonValue),\n/* harmony export */   LogicalZIndex: () => (/* binding */ LogicalZIndex),\n/* harmony export */   LogicalZIndexToDefaultMap: () => (/* binding */ LogicalZIndexToDefaultMap),\n/* harmony export */   ResponsiveMode: () => (/* binding */ ResponsiveMode),\n/* harmony export */   Side: () => (/* binding */ Side),\n/* harmony export */   SizeUnitEnum: () => (/* binding */ SizeUnitEnum),\n/* harmony export */   WidthOrHeightPropertyName: () => (/* binding */ WidthOrHeightPropertyName)\n/* harmony export */ });\n/* harmony import */ var _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/internal-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js\");\n/* harmony import */ var _style_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style-constants */ \"./node_modules/golden-layout/dist/esm/ts/utils/style-constants.js\");\n\n\n/** @internal */\nvar WidthOrHeightPropertyName;\n(function (WidthOrHeightPropertyName) {\n    WidthOrHeightPropertyName.width = 'width';\n    WidthOrHeightPropertyName.height = 'height';\n})(WidthOrHeightPropertyName || (WidthOrHeightPropertyName = {}));\n/** @public */\nvar Side;\n(function (Side) {\n    Side.top = 'top';\n    Side.left = 'left';\n    Side.right = 'right';\n    Side.bottom = 'bottom';\n})(Side || (Side = {}));\n/** @public */\nvar LogicalZIndex;\n(function (LogicalZIndex) {\n    LogicalZIndex.base = 'base';\n    LogicalZIndex.drag = 'drag';\n    LogicalZIndex.stackMaximised = 'stackMaximised';\n})(LogicalZIndex || (LogicalZIndex = {}));\n/** @public */\nconst LogicalZIndexToDefaultMap = {\n    base: _style_constants__WEBPACK_IMPORTED_MODULE_0__.StyleConstants.defaultComponentBaseZIndex,\n    drag: _style_constants__WEBPACK_IMPORTED_MODULE_0__.StyleConstants.defaultComponentDragZIndex,\n    stackMaximised: _style_constants__WEBPACK_IMPORTED_MODULE_0__.StyleConstants.defaultComponentStackMaximisedZIndex,\n};\n/** @public */\nvar JsonValue;\n(function (JsonValue) {\n    function isJson(value) {\n        return isJsonObject(value);\n    }\n    JsonValue.isJson = isJson;\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    function isJsonObject(value) {\n        return !Array.isArray(value) && value !== null && typeof value === 'object';\n    }\n    JsonValue.isJsonObject = isJsonObject;\n})(JsonValue || (JsonValue = {}));\n/** @public */\nvar ItemType;\n(function (ItemType) {\n    ItemType.ground = 'ground';\n    ItemType.row = 'row';\n    ItemType.column = 'column';\n    ItemType.stack = 'stack';\n    ItemType.component = 'component';\n})(ItemType || (ItemType = {}));\n/** @public */\nvar ResponsiveMode;\n(function (ResponsiveMode) {\n    ResponsiveMode.none = 'none';\n    ResponsiveMode.always = 'always';\n    ResponsiveMode.onload = 'onload';\n})(ResponsiveMode || (ResponsiveMode = {}));\n/** @public */\nvar SizeUnitEnum;\n(function (SizeUnitEnum) {\n    SizeUnitEnum[\"Pixel\"] = \"px\";\n    SizeUnitEnum[\"Percent\"] = \"%\";\n    SizeUnitEnum[\"Fractional\"] = \"fr\";\n    SizeUnitEnum[\"Em\"] = \"em\";\n})(SizeUnitEnum || (SizeUnitEnum = {}));\n/** @public */\n(function (SizeUnitEnum) {\n    function tryParse(value) {\n        switch (value) {\n            case SizeUnitEnum.Pixel: return SizeUnitEnum.Pixel;\n            case SizeUnitEnum.Percent: return SizeUnitEnum.Percent;\n            case SizeUnitEnum.Fractional: return SizeUnitEnum.Fractional;\n            case SizeUnitEnum.Em: return SizeUnitEnum.Em;\n            default: return undefined;\n        }\n    }\n    SizeUnitEnum.tryParse = tryParse;\n    function format(value) {\n        switch (value) {\n            case SizeUnitEnum.Pixel: return SizeUnitEnum.Pixel;\n            case SizeUnitEnum.Percent: return SizeUnitEnum.Percent;\n            case SizeUnitEnum.Fractional: return SizeUnitEnum.Fractional;\n            case SizeUnitEnum.Em: return SizeUnitEnum.Em;\n            default:\n                throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.UnreachableCaseError('SUEF44998', value);\n        }\n    }\n    SizeUnitEnum.format = format;\n})(SizeUnitEnum || (SizeUnitEnum = {}));\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/utils/types.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/utils/utils.js":
/*!***************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/utils/utils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deepExtend: () => (/* binding */ deepExtend),\n/* harmony export */   deepExtendValue: () => (/* binding */ deepExtendValue),\n/* harmony export */   ensureElementPositionAbsolute: () => (/* binding */ ensureElementPositionAbsolute),\n/* harmony export */   extend: () => (/* binding */ extend),\n/* harmony export */   getElementHeight: () => (/* binding */ getElementHeight),\n/* harmony export */   getElementWidth: () => (/* binding */ getElementWidth),\n/* harmony export */   getElementWidthAndHeight: () => (/* binding */ getElementWidthAndHeight),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   getUniqueId: () => (/* binding */ getUniqueId),\n/* harmony export */   isDigit: () => (/* binding */ isDigit),\n/* harmony export */   numberToPixels: () => (/* binding */ numberToPixels),\n/* harmony export */   pixelsToNumber: () => (/* binding */ pixelsToNumber),\n/* harmony export */   removeFromArray: () => (/* binding */ removeFromArray),\n/* harmony export */   setElementDisplayVisibility: () => (/* binding */ setElementDisplayVisibility),\n/* harmony export */   setElementHeight: () => (/* binding */ setElementHeight),\n/* harmony export */   setElementWidth: () => (/* binding */ setElementWidth),\n/* harmony export */   splitStringAtFirstNonNumericChar: () => (/* binding */ splitStringAtFirstNonNumericChar)\n/* harmony export */ });\n/** @internal */\nfunction numberToPixels(value) {\n    return value.toString(10) + 'px';\n}\n/** @internal */\nfunction pixelsToNumber(value) {\n    const numberStr = value.replace(\"px\", \"\");\n    return parseFloat(numberStr);\n}\n/** @internal */\nfunction splitStringAtFirstNonNumericChar(value) {\n    value = value.trimStart();\n    const length = value.length;\n    if (length === 0) {\n        return { numericPart: '', firstNonNumericCharPart: '' };\n    }\n    else {\n        let firstNonDigitPartIndex = length;\n        let gotDecimalPoint = false;\n        for (let i = 0; i < length; i++) {\n            const char = value[i];\n            if (!isDigit(char)) {\n                if (char !== '.') {\n                    firstNonDigitPartIndex = i;\n                    break;\n                }\n                else {\n                    if (gotDecimalPoint) {\n                        firstNonDigitPartIndex = i;\n                        break;\n                    }\n                    else {\n                        gotDecimalPoint = true;\n                    }\n                }\n            }\n        }\n        const digitsPart = value.substring(0, firstNonDigitPartIndex);\n        const firstNonDigitPart = value.substring(firstNonDigitPartIndex).trim();\n        return { numericPart: digitsPart, firstNonNumericCharPart: firstNonDigitPart };\n    }\n}\n/** @internal */\nfunction isDigit(char) {\n    return char >= '0' && char <= '9';\n}\n/** @internal */\nfunction getElementWidth(element) {\n    return element.offsetWidth;\n}\n/** @internal */\nfunction setElementWidth(element, width) {\n    const widthAsPixels = numberToPixels(width);\n    element.style.width = widthAsPixels;\n}\n/** @internal */\nfunction getElementHeight(element) {\n    return element.offsetHeight;\n}\n/** @internal */\nfunction setElementHeight(element, height) {\n    const heightAsPixels = numberToPixels(height);\n    element.style.height = heightAsPixels;\n}\n/** @internal */\nfunction getElementWidthAndHeight(element) {\n    return {\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n    };\n}\n/** @internal */\nfunction setElementDisplayVisibility(element, visible) {\n    if (visible) {\n        element.style.display = '';\n    }\n    else {\n        element.style.display = 'none';\n    }\n}\n/** @internal */\nfunction ensureElementPositionAbsolute(element) {\n    const absolutePosition = 'absolute';\n    if (element.style.position !== absolutePosition) {\n        element.style.position = absolutePosition;\n    }\n}\n/**\n * Replacement for JQuery $.extend(target, obj)\n * @internal\n*/\nfunction extend(target, obj) {\n    for (const key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            target[key] = obj[key];\n        }\n    }\n    return target;\n}\n/**\n * Replacement for JQuery $.extend(true, target, obj)\n * @internal\n*/\nfunction deepExtend(target, obj) {\n    if (obj !== undefined) {\n        for (const key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                const value = obj[key];\n                const existingTarget = target[key];\n                target[key] = deepExtendValue(existingTarget, value);\n            }\n        }\n    }\n    return target;\n}\n/** @internal */\nfunction deepExtendValue(existingTarget, value) {\n    if (typeof value !== 'object') {\n        return value;\n    }\n    else {\n        if (Array.isArray(value)) {\n            const length = value.length;\n            const targetArray = new Array(length);\n            for (let i = 0; i < length; i++) {\n                const element = value[i];\n                targetArray[i] = deepExtendValue({}, element);\n            }\n            return targetArray;\n        }\n        else {\n            if (value === null) {\n                return null;\n            }\n            else {\n                const valueObj = value;\n                if (existingTarget === undefined) {\n                    return deepExtend({}, valueObj); // overwrite\n                }\n                else {\n                    if (typeof existingTarget !== \"object\") {\n                        return deepExtend({}, valueObj); // overwrite\n                    }\n                    else {\n                        if (Array.isArray(existingTarget)) {\n                            return deepExtend({}, valueObj); // overwrite\n                        }\n                        else {\n                            if (existingTarget === null) {\n                                return deepExtend({}, valueObj); // overwrite\n                            }\n                            else {\n                                const existingTargetObj = existingTarget;\n                                return deepExtend(existingTargetObj, valueObj); // merge\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n/** @internal */\nfunction removeFromArray(item, array) {\n    const index = array.indexOf(item);\n    if (index === -1) {\n        throw new Error('Can\\'t remove item from array. Item is not in the array');\n    }\n    array.splice(index, 1);\n}\n/** @internal */\nfunction getUniqueId() {\n    return (Math.random() * 1000000000000000)\n        .toString(36)\n        .replace('.', '');\n}\n/** @internal */\nfunction getErrorMessage(e) {\n    if (e instanceof Error) {\n        return e.message;\n    }\n    else {\n        if (typeof e === 'string') {\n            return e;\n        }\n        else {\n            return 'Unknown Error';\n        }\n    }\n}\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/utils/utils.js?");

/***/ }),

/***/ "./node_modules/golden-layout/dist/esm/ts/virtual-layout.js":
/*!******************************************************************!*\
  !*** ./node_modules/golden-layout/dist/esm/ts/virtual-layout.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VirtualLayout: () => (/* binding */ VirtualLayout)\n/* harmony export */ });\n/* harmony import */ var _config_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config/config */ \"./node_modules/golden-layout/dist/esm/ts/config/config.js\");\n/* harmony import */ var _config_resolved_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./config/resolved-config */ \"./node_modules/golden-layout/dist/esm/ts/config/resolved-config.js\");\n/* harmony import */ var _errors_external_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./errors/external-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/external-error.js\");\n/* harmony import */ var _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors/internal-error */ \"./node_modules/golden-layout/dist/esm/ts/errors/internal-error.js\");\n/* harmony import */ var _layout_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layout-manager */ \"./node_modules/golden-layout/dist/esm/ts/layout-manager.js\");\n/* harmony import */ var _utils_i18n_strings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/i18n-strings */ \"./node_modules/golden-layout/dist/esm/ts/utils/i18n-strings.js\");\n\n\n\n\n\n\n/** @public */\nclass VirtualLayout extends _layout_manager__WEBPACK_IMPORTED_MODULE_0__.LayoutManager {\n    /** @internal */\n    constructor(configOrOptionalContainer, containerOrBindComponentEventHandler, unbindComponentEventHandler, skipInit) {\n        super(VirtualLayout.createLayoutManagerConstructorParameters(configOrOptionalContainer, containerOrBindComponentEventHandler));\n        /** @internal @deprecated use while constructor is not determinate */\n        this._bindComponentEventHanlderPassedInConstructor = false; // remove when constructor is determinate\n        /** @internal  @deprecated use while constructor is not determinate */\n        this._creationTimeoutPassed = false; // remove when constructor is determinate\n        if (containerOrBindComponentEventHandler !== undefined) {\n            if (typeof containerOrBindComponentEventHandler === 'function') {\n                this.bindComponentEvent = containerOrBindComponentEventHandler;\n                this._bindComponentEventHanlderPassedInConstructor = true;\n                if (unbindComponentEventHandler !== undefined) {\n                    this.unbindComponentEvent = unbindComponentEventHandler;\n                }\n            }\n        }\n        if (!this._bindComponentEventHanlderPassedInConstructor) {\n            // backward compatibility\n            if (this.isSubWindow) {\n                // document.body.style.visibility = 'hidden';\n                // Set up layoutConfig since constructor is not determinate and may exit early. Other functions may need\n                // this.layoutConfig. this.layoutConfig is again calculated in the same way when init() completes.\n                // Remove this when constructor is determinate.\n                if (this._constructorOrSubWindowLayoutConfig === undefined) {\n                    throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.UnexpectedUndefinedError('VLC98823');\n                }\n                else {\n                    const resolvedLayoutConfig = _config_config__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.resolve(this._constructorOrSubWindowLayoutConfig);\n                    // remove root from layoutConfig\n                    this.layoutConfig = Object.assign(Object.assign({}, resolvedLayoutConfig), { root: undefined });\n                }\n            }\n        }\n        if (skipInit !== true) {\n            if (!this.deprecatedConstructor) {\n                this.init();\n            }\n        }\n    }\n    destroy() {\n        this.bindComponentEvent = undefined;\n        this.unbindComponentEvent = undefined;\n        super.destroy();\n    }\n    /**\n     * Creates the actual layout. Must be called after all initial components\n     * are registered. Recurses through the configuration and sets up\n     * the item tree.\n     *\n     * If called before the document is ready it adds itself as a listener\n     * to the document.ready event\n     * @deprecated LayoutConfig should not be loaded in {@link (LayoutManager:class)} constructor, but rather in a\n     * {@link (LayoutManager:class).loadLayout} call.  If LayoutConfig is not specified in {@link (LayoutManager:class)} constructor,\n     * then init() will be automatically called internally and should not be called externally.\n     */\n    init() {\n        /**\n         * If the document isn't ready yet, wait for it.\n         */\n        if (!this._bindComponentEventHanlderPassedInConstructor && (document.readyState === 'loading' || document.body === null)) {\n            document.addEventListener('DOMContentLoaded', () => this.init(), { passive: true });\n            return;\n        }\n        /**\n         * If this is a subwindow, wait a few milliseconds for the original\n         * page's js calls to be executed, then replace the bodies content\n         * with GoldenLayout\n         */\n        if (!this._bindComponentEventHanlderPassedInConstructor && this.isSubWindow === true && !this._creationTimeoutPassed) {\n            setTimeout(() => this.init(), 7);\n            this._creationTimeoutPassed = true;\n            return;\n        }\n        if (this.isSubWindow === true) {\n            if (!this._bindComponentEventHanlderPassedInConstructor) {\n                this.clearHtmlAndAdjustStylesForSubWindow();\n            }\n            // Expose this instance on the window object to allow the opening window to interact with it\n            window.__glInstance = this;\n        }\n        super.init();\n    }\n    /**\n     * Clears existing HTML and adjusts style to make window suitable to be a popout sub window\n     * Curently is automatically called when window is a subWindow and bindComponentEvent is not passed in the constructor\n     * If bindComponentEvent is not passed in the constructor, the application must either call this function explicitly or\n     * (preferably) make the window suitable as a subwindow.\n     * In the future, it is planned that this function is NOT automatically called in any circumstances.  Applications will\n     * need to determine whether a window is a Golden Layout popout window and either call this function explicitly or\n     * hide HTML not relevant to the popout.\n     * See apitest for an example of how HTML is hidden when popout windows are displayed\n     */\n    clearHtmlAndAdjustStylesForSubWindow() {\n        const headElement = document.head;\n        const appendNodeLists = new Array(4);\n        appendNodeLists[0] = document.querySelectorAll('body link');\n        appendNodeLists[1] = document.querySelectorAll('body style');\n        appendNodeLists[2] = document.querySelectorAll('template');\n        appendNodeLists[3] = document.querySelectorAll('.gl_keep');\n        for (let listIdx = 0; listIdx < appendNodeLists.length; listIdx++) {\n            const appendNodeList = appendNodeLists[listIdx];\n            for (let nodeIdx = 0; nodeIdx < appendNodeList.length; nodeIdx++) {\n                const node = appendNodeList[nodeIdx];\n                headElement.appendChild(node);\n            }\n        }\n        const bodyElement = document.body;\n        bodyElement.innerHTML = '';\n        bodyElement.style.visibility = 'visible';\n        this.checkAddDefaultPopinButton();\n        /*\n        * This seems a bit pointless, but actually causes a reflow/re-evaluation getting around\n        * slickgrid's \"Cannot find stylesheet.\" bug in chrome\n        */\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const x = document.body.offsetHeight;\n    }\n    /**\n     * Will add button if not popinOnClose specified in settings\n     * @returns true if added otherwise false\n     */\n    checkAddDefaultPopinButton() {\n        if (this.layoutConfig.settings.popInOnClose) {\n            return false;\n        }\n        else {\n            const popInButtonElement = document.createElement('div');\n            popInButtonElement.classList.add(\"lm_popin\" /* Popin */);\n            popInButtonElement.setAttribute('title', this.layoutConfig.header.dock);\n            const iconElement = document.createElement('div');\n            iconElement.classList.add(\"lm_icon\" /* Icon */);\n            const bgElement = document.createElement('div');\n            bgElement.classList.add(\"lm_bg\" /* Bg */);\n            popInButtonElement.appendChild(iconElement);\n            popInButtonElement.appendChild(bgElement);\n            popInButtonElement.addEventListener('click', () => this.emit('popIn'));\n            document.body.appendChild(popInButtonElement);\n            return true;\n        }\n    }\n    /** @internal */\n    bindComponent(container, itemConfig) {\n        if (this.bindComponentEvent !== undefined) {\n            const bindableComponent = this.bindComponentEvent(container, itemConfig);\n            return bindableComponent;\n        }\n        else {\n            if (this.getComponentEvent !== undefined) {\n                return {\n                    virtual: false,\n                    component: this.getComponentEvent(container, itemConfig),\n                };\n            }\n            else {\n                // There is no component registered for this type, and we don't have a getComponentEvent defined.\n                // This might happen when the user pops out a dialog and the component types are not registered upfront.\n                const text = _utils_i18n_strings__WEBPACK_IMPORTED_MODULE_3__.i18nStrings[2 /* ComponentTypeNotRegisteredAndBindComponentEventHandlerNotAssigned */];\n                const message = `${text}: ${JSON.stringify(itemConfig)}`;\n                throw new _errors_external_error__WEBPACK_IMPORTED_MODULE_4__.BindError(message);\n            }\n        }\n    }\n    /** @internal */\n    unbindComponent(container, virtual, component) {\n        if (this.unbindComponentEvent !== undefined) {\n            this.unbindComponentEvent(container);\n        }\n        else {\n            if (!virtual && this.releaseComponentEvent !== undefined) {\n                if (component === undefined) {\n                    throw new _errors_internal_error__WEBPACK_IMPORTED_MODULE_1__.UnexpectedUndefinedError('VCUCRCU333998');\n                }\n                else {\n                    this.releaseComponentEvent(container, component);\n                }\n            }\n        }\n    }\n}\n/** @public */\n(function (VirtualLayout) {\n    /** @internal\n     * Veriable to hold the state whether we already checked if we are running in a sub window.\n     * Fixes popout and creation of nested golden-layouts.\n     */\n    let subWindowChecked = false;\n    /** @internal */\n    function createLayoutManagerConstructorParameters(configOrOptionalContainer, containerOrBindComponentEventHandler) {\n        const windowConfigKey = subWindowChecked ? null : new URL(document.location.href).searchParams.get('gl-window');\n        subWindowChecked = true;\n        const isSubWindow = windowConfigKey !== null;\n        let containerElement;\n        let config;\n        if (windowConfigKey !== null) {\n            const windowConfigStr = localStorage.getItem(windowConfigKey);\n            if (windowConfigStr === null) {\n                throw new Error('Null gl-window Config');\n            }\n            localStorage.removeItem(windowConfigKey);\n            const minifiedWindowConfig = JSON.parse(windowConfigStr);\n            const resolvedConfig = _config_resolved_config__WEBPACK_IMPORTED_MODULE_5__.ResolvedLayoutConfig.unminifyConfig(minifiedWindowConfig);\n            config = _config_config__WEBPACK_IMPORTED_MODULE_2__.LayoutConfig.fromResolved(resolvedConfig);\n            if (configOrOptionalContainer instanceof HTMLElement) {\n                containerElement = configOrOptionalContainer;\n            }\n        }\n        else {\n            if (configOrOptionalContainer === undefined) {\n                config = undefined;\n            }\n            else {\n                if (configOrOptionalContainer instanceof HTMLElement) {\n                    config = undefined;\n                    containerElement = configOrOptionalContainer;\n                }\n                else {\n                    // backwards compatibility\n                    config = configOrOptionalContainer;\n                }\n            }\n            if (containerElement === undefined) {\n                if (containerOrBindComponentEventHandler instanceof HTMLElement) {\n                    containerElement = containerOrBindComponentEventHandler;\n                }\n            }\n        }\n        return {\n            constructorOrSubWindowLayoutConfig: config,\n            isSubWindow,\n            containerElement,\n        };\n    }\n    VirtualLayout.createLayoutManagerConstructorParameters = createLayoutManagerConstructorParameters;\n})(VirtualLayout || (VirtualLayout = {}));\n//# sourceMappingURL=virtual-layout.js.map\n\n//# sourceURL=webpack://dpv/./node_modules/golden-layout/dist/esm/ts/virtual-layout.js?");

/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./style.css */ \"./node_modules/css-loader/dist/cjs.js!./src/style.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\noptions.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://dpv/./src/style.css?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://dpv/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://dpv/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://dpv/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://dpv/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://dpv/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://dpv/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var golden_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! golden-layout */ \"./node_modules/golden-layout/dist/esm/ts/golden-layout.js\");\n/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style.css */ \"./src/style.css\");\n\n\n // Your custom styles (optional)\n\n\nconst layoutConfig = {\n  root: {\n    type: 'stack', // Groups panels into a tabbed stack\n    content: [\n        {\n            type: 'component',\n            componentType: 'listComponent',\n            title: 'Productivity Ideas',\n            componentState: { text: 'Productivity Workshop Ideas' },\n          },\n      {\n        type: 'component',\n        componentType: 'exampleComponent',\n        title: 'Panel 2',\n        componentState: { text: 'This is Panel 2' },\n      },\n      {\n        type: 'component',\n        componentType: 'exampleComponent',\n        title: 'Panel 3',\n        componentState: { text: 'This is Panel 3' },\n      },\n      {\n        type: 'component',\n        componentType: 'exampleComponent',\n        title: 'Panel 4',\n        componentState: { text: 'This is Panel 4' },\n      },\n      {\n        type: 'component',\n        componentType: 'exampleComponent',\n        title: 'Panel 5',\n        componentState: { text: 'This is Panel 5' },\n      },\n      {\n        type: 'component',\n        componentType: 'exampleComponent',\n        title: 'Panel 6',\n        componentState: { text: 'This is Panel 6' },\n      },\n    ],\n  },\n};\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  const container = document.getElementById('layout-container');\n\n  if (!container) {\n    console.error('Error: #layout-container not found in the DOM.');\n    return;\n  }\n\n  const goldenLayout = new golden_layout__WEBPACK_IMPORTED_MODULE_1__.GoldenLayout(container);\n\n\n\n\n  // Register components\n\n  goldenLayout.registerComponentFactoryFunction('listComponent', (container, state) => {\n    container.element.innerHTML = `\n      <div style=\"padding: 20px; color: white;\">\n        <h2>${state.text}</h2>\n        <ul style=\"line-height: 1.8;\">\n          <li><strong>Task Management System</strong>\n            <ul>\n              <li>To-Do List, Completed Tasks, Daily Goals, Weekly Plan</li>\n              <li>Enhancements: Drag-and-drop tasks, API integrations</li>\n            </ul>\n          </li>\n          <li><strong>Learning Hub</strong>\n            <ul>\n              <li>Notes, Reference Material, Flashcards, Progress Tracker</li>\n              <li>Enhancements: Quiz generator, Spaced repetition</li>\n            </ul>\n          </li>\n          <li><strong>Personal Finance Tracker</strong>\n            <ul>\n              <li>Budget Overview, Expense Tracker, Investments, Financial Goals</li>\n              <li>Enhancements: API integration, Visualizations</li>\n            </ul>\n          </li>\n          <li><strong>Developer Dashboard</strong>\n            <ul>\n              <li>Code Editor, API Documentation, Debugging Logs, Task Tracker</li>\n              <li>Enhancements: Live preview, Git client</li>\n            </ul>\n          </li>\n          <li><strong>Content Creator Workspace</strong>\n            <ul>\n              <li>Content Calendar, Drafts, Inspiration, Analytics</li>\n              <li>Enhancements: Templates, API for social media</li>\n            </ul>\n          </li>\n          <li><strong>Productivity Dashboard</strong>\n            <ul>\n              <li>Pomodoro Timer, Notes, Calendar, Habit Tracker</li>\n              <li>Enhancements: Gamification, Calendar sync</li>\n            </ul>\n          </li>\n          <li><strong>Health & Wellness Tracker</strong>\n            <ul>\n              <li>Fitness Log, Meal Plan, Sleep Tracker, Meditation</li>\n              <li>Enhancements: Wearable integration, Trends visualization</li>\n            </ul>\n          </li>\n          <li><strong>Project Management Workspace</strong>\n            <ul>\n              <li>Overview, Tasks, Milestones, Resources</li>\n              <li>Enhancements: Gantt charts, API integrations</li>\n            </ul>\n          </li>\n          <li><strong>Journal & Reflection Hub</strong>\n            <ul>\n              <li>Daily Journal, Mood Tracker, Vision Board, Reflections</li>\n              <li>Enhancements: Sentiment analysis, Reminder notifications</li>\n            </ul>\n          </li>\n        </ul>\n      </div>\n    `;\n  });\n\n\n\n  goldenLayout.registerComponentFactoryFunction('exampleComponent', (container, state) => {\n    container.element.innerHTML = `<div style=\"padding: 10px;\">${state.text}</div>`;\n  });\n\n  // Load the layout configuration\n  goldenLayout.loadLayout(layoutConfig);\n});\n\n\n//# sourceURL=webpack://dpv/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;